# Синхронизация线程 Execution Barrier

`Thread\Barrier` - это механизм синхронизации线程. Он позволяет многим线程ам синхронизироваться в определенном точке, чтобы убедиться, что все线程 завершили свою работу до определенного критической точки (барьера). Только когда все участвующие线程 достигнут этого барьера, они смогут продолжить выполнение последующего кода.

Например, мы создали `4`线程 и хотим, чтобы эти线程 начали выполнять задачи одновременно после того, как все они будут готовы, как в беговой гонке, когда судья подает сигнал старта, и все участники начинают бежать одновременно. Это можно реализовать с помощью `Thread\Barrier`.

## Пример
```php
use Swoole\Thread;
use Swoole\Thread\Barrier;

const N = 4;
$args = Thread::getArguments();

if (empty($args)) {
    $barrier = new Barrier(N);
    $n = N;
    $threads = [];
    while($n--) {
        $threads[] = new Thread(__FILE__, $barrier, $n);
    }
} else {
    $barrier = $args[0];
    $n = $args[1];
    // Ждем, пока все线程 будут готовы
    $barrier->wait();
    echo "thread $n is running\n";
}
```

## Методы

### __construct()
Конструктор

```php
Thread\Barrier()->__construct(int $count): void
```

  * **Параметры**
      * `int $count`
          * Функция: количество线程, которое должно быть больше `1`.
          * По умолчанию: нет.
          * Другие значения: нет.
  
Количество线程, выполняющих операцию `wait`, должно соответствовать установленному значению счетчика, иначе все线程 будут заблокированы.

### wait()

Блокировать ожидание других线程, пока все线程 не окажутся в состоянии `wait`, затем одновременно разбудить все ожидающие线程, чтобы они могли продолжить выполнение ниже.

```php
Thread\Barrier()->wait(): void
```
