#必读指南 по программированию

Эта глава подробно расскажет о различиях между программированием с использованием корутин и синхронным программированием, а также о том, что следует учитывать.

## Примечания

* Не следует выполнять в коде `sleep` и другие функции сна, так как это может привести к блокировке всего процесса; в корутинах можно использовать [Co::sleep()](/coroutine/system?id=sleep) или `sleep` после [односторонней корутинизации](/runtime); см. также: [Влияние sleep/usleep](/getting_started/notice?id=sleepusleep的影响)
* `exit/die` опасны и могут привести к выходу `Worker` процесса; см. также: [Влияние функций exit/die](/getting_started/notice?id=exitdie函数的影响)
* Можно использовать `register_shutdown_function` для захватаFatal errors и выполнения очистных работ при необычном завершении процесса; см. также: [ЗахватываниеFatal errors во время работы Server](/getting_started/notice?id=捕获server运行期致命错误)
* Если в `PHP` коде抛出 исключение, оно должно быть захвачено в обратном вызове с помощью `try/catch`, иначе это может привести к выходу рабочего процесса; см. также: [Захватывание исключений и ошибок](/getting_started/notice?id=捕获异常和错误)
* Не поддерживается `set_exception_handler`, необходимо использовать `try/catch` для обработки исключений;
* `Worker` процессы не должны делиться одним и тем же клиентом сети, например, `Redis` или `MySQL`, код создания соединений с `Redis/MySQL` может быть размещен в обратном вызове `onWorkerStart`. См. также: [Можно ли использовать один Redis или MySQL соединение](/question/use?id=是否可以共用一个redis或mysql连接)

## Программирование с использованием корутин

При использовании `Coroutine`Features, пожалуйста, внимательно прочитайте [Пр必读指南 по программированию с использованием корутин](/coroutine/notice)

## Параллельное программирование

Не забывайте, что в отличие от синхронного блокирующего режима, в режиме `корутин` программы выполняются **параллельно**, и в один момент времени на `Server` может быть несколько запросов, поэтому **приложение должно создавать разные ресурсы и контексты для каждого клиента или запроса**. В противном случае между разными клиентами и запросами могут возникнуть проблемы с данными и логикой.

## Двойное определение классов/функций

Новые пользователи часто допускают эту ошибку, поскольку `Swoole` остается в памяти, файлы, содержащие определение классов/функций, не освобождаются после их загрузки. Поэтому при включении файлов PHP, содержащих классы/функции, необходимо использовать `include_once` или `require_once`, иначе может возникнуть смертельная ошибка `cannot redeclare function/class`.

## Управление памятью

!> При написании `Server` или других постоянных процессов необходимо быть особенно внимательным.

Жизненный цикл переменных и способ управления памятью в PHP-демоне совершенно отличается от обычного веб-приложения. После запуска `Server` основные принципы управления памятью такие же, как в обычных php-cli программах. Для более подробной информации смотрите статьи о управлении памятью в `Zend VM`.

### локальные переменные

После возврата из функции события все локальные объекты и переменные полностью удаляются и не требуют `unset`. Если переменная является ресурсом, то соответствующий ресурс также будет освобожден PHP на уровне.

```php
function test()
{
	$a = new Object;
	$b = fopen('/data/t.log', 'r+');
	$c = new swoole_client(SWOOLE_SYNC);
	$d = new swoole_client(SWOOLE_SYNC);
	global $e;
	$e['client'] = $d;
}
```

* `$a`, `$b`, `$c` являются локальными переменными, и когда эта функция `return`, эти `3` переменные немедленно освобождаются, соответствующая память немедленно освобождается, и открытый файловый дескриптор IO немедленно закрывается.
* `$d` также является локальной переменной, но перед `return` она была сохранена в глобальной переменной `$e`, поэтому она не будет освобождена. Когда выполняется `unset($e['client'])` и нет других `PHP переменных`, которые все еще ссылаются на `$d` переменную, `$d` будет освобождена.

### Глобальные переменные

В `PHP` есть три вида глобальных переменных.

* Переменные, объявленные с использованием ключевого слова `global`
* Статические переменные классов и статические переменные функций, объявленные с использованием ключевого слова `static`
* Суперглобальные переменные PHP, включая `$_GET`, `$_POST`, `$GLOBALS` и т.д.

Глобальные переменные и объекты, статические переменные классов, переменные, хранящиеся на объекте `Server`, не будут освобождены. Программист должен самостоятельно заниматься уничтожением этих переменных и объектов.

```php
class Test
{
	static $array = array();
	static $string = '';
}

function onReceive($serv, $fd, $reactorId, $data)
{
	Test::$array[] = $fd;
	Test::$string .= $data;
}
```

* В обратных функциях события необходимо особенно внимательно следить за не локальными переменными типа `array`, некоторые операции, такие как  `TestClass::$array[] = "string"`, могут привести к утечке памяти, в серьезных случаях может произойти переполнение памяти, при необходимости следует обращать внимание на очистку больших массивов.

* В обратных функциях события, при конкатенации строк не локальных переменных, необходимо быть осторожным с утечкой памяти, например, `TestClass::$string .= $data`, может возникнуть утечка памяти, в серьезных случаях может произойти переполнение памяти.

### Решение

* Синхронные блокирующие и запросно-ответные безграничные `Server` программы могут устанавливать [max_request](/server/setting?id=max_request) и [task_max_request](/server/setting?id=task_max_request), когда [Worker进程](/learn?id=worker进程) / [Task进程](/learn?id=taskworker进程) заканчивают работу или достигают предела задач, процесс автоматически выходит, и все его переменные/объекты/ресурсы будут освобождены и удалены.
* Внутри программы в `onClose` или установив `таймер` своевременно используйте `unset` для очистки переменных и восстановления ресурсов.

## Отделение процессов

Отделение процессов также является проблемой, с которой часто сталкиваются начинающие. Почему изменения в глобальных переменных не работают? Причина заключается в том, что глобальные переменные находятся в разных процессах, и память разделена, поэтому они не работают.

Поэтому при разработке `Server` программ с использованием `Swoole` необходимо понимать проблему разделения процессов. Разные `Worker` процессы программы `Swoole\Server` изолированы друг от друга, и операции с глобальными переменными, таймерами, событиями监听ers действительны только в текущем процессе.

* В разных процессах PHP переменные не делятся, даже глобальные переменные, изменения в которых в процессе A не будут отражаться в процессе B
* Если необходимо поделиться данными между разными Worker процессами, можно использовать инструменты, такие как `Redis`, `MySQL`, `файлы`, `Swoole\Table`, `APCu`, `shmget` и т.д.
* Фile descriptors в разных процессах изолированы, поэтому сокеты, созданные в процессе A или открытые файлы, будут недействительными в процессе B, даже если вы отправите их fd в процесс B, они будут бесполезны

Пример:

```php
$server = new Swoole\Http\Server('127.0.0.1', 9500);

$i = 1;

$server->on('Request', function ($request, $response) {
	global $i;
    $response->end($i++);
});

$server->start();
```

В многопроцессном сервере, хотя `$i` переменная является глобальной (`global`), из-за разделения процессов. Если предположить, что есть `4` рабочих процесса, и в `процессе 1` выполняется `$i++`, на самом деле только `$i` в `процессе 1` становится `2`, а в других `3` процессах значение `$i` остается `1`.

Правильный подход заключается в использовании структур данных `Swoole`, предоставляемых для хранения данных, таких как [Swoole\Atomic](/memory/atomic) или [Swoole\Table](/memory/table). Как показано в вышеупомянутом коде, для этого можно использовать `Swoole\Atomic`.

```php
$server = new Swoole\Http\Server('127.0.0.1', 9500);

$atomic = new Swoole\Atomic(1);

$server->on('Request', function ($request, $response) use ($atomic) {
    $response->end($atomic->add(1));
});

$server->start();
```

!> Память, на которой основаны данные `Swoole\Atomic`, создается на основе общего памяти, и когда используется метод `add` для увеличения на `1`, это также эффективно в других рабочих процессах

Компоненты `Swoole`, предоставляемые для многопроцессного программирования, такие как [Table](/memory/table), [Atomic](/memory/atomic), [Lock](/memory/lock), должны быть созданы до начала работы `Server`. Кроме того, TCP-клиенты, поддерживаемые `Server`, также могут работать между процессами, например, `Server->send` и `Server->close`.
## очистка缓存 stat

В PHP на уровне системы вызовов `stat` появилась `Cache`, и когда используются функции `stat`, `fstat`, `filemtime` и другие, на нижнем уровне возможно попадание в缓存 и возврат исторических данных.

Использовать функцию [clearstatcache](https://www.php.net/manual/en/function.clearstatcache.php) можно для очистки缓存 stat файлов.


## Случайные числа mt_rand

В `Swoole`, если внутри родительского процесса вызван `mt_rand`, то результаты `mt_rand` в разных дочерних процессах будут одинаковыми, поэтому необходимо в каждом дочернем процессе вызвать `mt_srand` для пересева.

!> Функции PHP, зависящие от случайных чисел, такие как `shuffle` и `array_rand`, также будут повлиять  

Пример:

```php
mt_rand(0, 1);

// Начало
$worker_num = 16;

// Fork процесс
for($i = 0; $i < $worker_num; $i++) {
    $process = new Swoole\Process('child_async', false, 2);
    $pid = $process->start();
}

// асинхронно выполнять процесс
function child_async(Swoole\Process $worker) {
    mt_srand(); // пересев
    echo mt_rand(0, 100).PHP_EOL;
    $worker->exit();
}
```


## Уловление исключений и ошибок


### Вещие исключения/ошибки

В PHP есть три основных типа manageable exceptions/errors:

1. `Error`: специальный тип ошибок, выбрасываемых ядром PHP, таких как отсутствие класса, отсутствия функции, неправильные параметры функции и т.д. В PHP-коде не следует использовать класс `Error` для выбрасывания исключений.
2. `Exception`: базовый класс исключений, который должны использовать разработчики приложений.
3. `ErrorException`: этот базовый класс exception-ов специализирован для преобразования предупреждений/уведомлений PHP в исключения с помощью `set_error_handler`. В будущем план PHP заключается в том, чтобы превратить все предупреждения/уведомления в исключения, чтобы программы PHP могли более эффективно и контролируемо обрабатывать различные ошибки.

!> Все вышеупомянутые классы реализуют интерфейс `Throwable`, то есть, используя `try {} catch(Throwable $e) {}`, можно поймать все выбрасываемые исключения/ошибки.

Пример 1:
```php
try {
	test();
} 
catch(Throwable $e) {
	var_dump($e);
}
```
Пример 2:
```php
try {
	test();
}
catch (Error $e) {
	var_dump($e);
}
catch(Exception $e) {
	var_dump($e);
}
```


### Необходимые для захватаFatal ошибки и исключения

Один из важных уровней ошибок в PHP, например, когда исключение/ошибка не捕获ется, когда недостаточно памяти или некоторые ошибки на уровне компиляции (отсутствие наследуемого класса), будет выброшен Fatal Error уровня E_ERROR, который срабатывает, когда происходит непригодная для обратной связи ошибка в программе. PHP-программы не могут捕获 такие уровни ошибок и могут только обработать их после завершения программы с помощью `register_shutdown_function`.


### В协程ах捕获 выполнения времени исключений/ошибок

В программировании с использованием Swoole4 для协程, если в коде какой-либо协ورة возникает ошибка, это приведет к завершению всего процесса, к прекращению выполнения всех协ور в процессе. На верхнем уровне协ор можно сначала провести `try/catch`, чтобы поймать исключения/ошибки и прекратить только ошибочную协ору.

```php
use Swoole\Coroutine;
use function Swoole\Coroutine\run;

run(function () {
    Coroutine::create(function () {
        try {
            call_user_func($func);
        }
        catch (Error $e) {
            var_dump($e);
        }
        catch(Exception $e) {
            var_dump($e);
        }
    });

    // Ошибки в协оре 1 не влияют на协ору 2
    Coroutine::create(function () {
        Coroutine::sleep(5);
        echo 2;
    });
});
```


### Уловление серьезных ошибок в процессе Server

Если во время работы Server происходит серьезная ошибка, то клиенты не смогут получить ответ. Например, если веб-сервер сталкивается с серьезной ошибкой, он должен отправить клиентам информацию о ошибке HTTP 500.

В PHP можно использовать функции `register_shutdown_function` и `error_get_last` для захвата серьезных ошибок и отправки информации об ошибке клиентам.

Конкретный пример кода следующий:

```php
$http = new Swoole\Http\Server("127.0.0.1", 9501);
$http->on('request', function ($request, $response) {
    register_shutdown_function(function () use ($response) {
        $error = error_get_last();
        var_dump($error);
        switch ($error['type'] ?? null) {
            case E_ERROR :
            case E_PARSE :
            case E_CORE_ERROR :
            case E_COMPILE_ERROR :
                // log or send:
                // error_log($message);
                // $server->send($fd, $error['message']);
                $response->status(500);
                $response->end($error['message']);
                break;
        }
    });
    exit(0);
});
$http->start();
```


## Влияние использования


### Влияние sleep/usleep

В программах с асинхронным IO **не следует использовать sleep/usleep/time_sleep_until/time_nanosleep** (далее в тексте `sleep` будет относиться ко всем функциям сна).

* Функция `sleep` заставляет процесс войти в спящий блок
* Операционная система разбудит текущий процесс только после наступления указанного времени
* Во время `sleep` процесс может быть прерван только сигналом
* Поскольку обработка сигналов в Swoole основана на `signalfd`, даже отправка сигнала не сможет прервать `sleep`

Swoole предоставляет [Swoole\Event::add](/event?id=add), [Swoole\Timer::tick](/timer?id=tick), [Swoole\Timer::after](/timer?id=after), [Swoole\Process::signal](/process/process?id=signal), которые перестают работать после того, как процесс `sleep`. [Swoole\Server](/server/tcp_init) также не сможет обрабатывать новые запросы.

#### Пример

```php
$server = new Swoole\Server("127.0.0.1", 9501);
$server->set(['worker_num' => 1]);
$server->on('receive', function ($server, $fd, $reactor_id, $data) {
    sleep(100);
    $server->send($fd, 'Swoole: '.$data);
});
$server->start();
```

!> В событии [onReceive](/server/events?id=onreceive) выполнена функция `sleep`, и Server не сможет принимать какие-либо новые запросы от клиентов в течение 100 секунд.


### Влияние функций exit/die

В программах Swoole запрещено использовать `exit/die`. Если в PHP-коде есть `exit/die`, текущий рабочий [Worker процесс](/learn?id=worker进程), [Task процесс](/learn?id=taskworker进程), [User процесс](/server/methods?id=addprocess) и процесс Swoole\Process немедленно завершат работу.

Использование `exit/die` приводит к тому, что Worker процесс завершится из-за исключения и будет снова запущен master-процессом, что в конечном итоге приведет к постоянному завершению и запуску процессов, а также к созданию большого количества警告ов и логов.

Рекомендуется использовать `try/catch` вместо `exit/die`, чтобы реализовать прерывание выполнения и выход из PHP-функции.

```php
Swoole\Coroutine\run(function () {
    try
    {
        exit(0);
    } catch (Swoole\ExitException $e)
    {
        echo $e->getMessage()."\n";
    }
});
```

!> `Swoole\ExitException` с версии Swoole v4.1.0 и выше напрямую поддерживает использование PHP `exit` в协орах и Server, в этот момент на нижнем уровне автоматически будет выброшен ловимый `Swoole\ExitException`, и разработчики могут поймать его в необходимом месте и реализовать логику выхода, аналогичную естественному PHP. Для конкретного использования смотрите [выход из协ор](/coroutine/notice?id=выход из协ор);

Способ обработки исключений более дружелюбен, чем `exit/die`, потому что исключения контролируемы, в то время как `exit/die` неконтролируемы. Просто поставьте `try/catch` на самый внешний уровень, чтобы поймать исключение и прекратить только текущую задачу. Worker-процесс может продолжить обработку новых запросов, в то время как `exit/die` приведет к прямому завершению процесса, все сохраненные переменные и ресурсы процесса будут уничтожены. Если в процессе есть еще задачи для обработки, то при столкновении с `exit/die` они также будут потеряны.
### Влияние цикла `while`

В асинхронных программах, если наступает бесконечный цикл, события не смогут быть обработаны. Асинхронные программы используют модель `Reaktor`, в процессе работы они должны постоянно проверять `reactor->wait`. Если наступить бесконечный цикл, то контроль над программой переходит к `while`, `reactor` не сможет получить контроль и обнаружить события, поэтому callback-функции для IO событий также не смогут быть вызваны.

!> Код с интенсивным вычислением не выполняет никаких IO операций, поэтому он не может считаться заблокированным  

#### Пример программы

```php
$server = new Swoole\Server('127.0.0.1', 9501);
$server->set(['worker_num' => 1]);
$server->on('receive', function ($server, $fd, $reactorId, $data) {
    $i = 0;
    while(true)
    {
        $i++;
    }
    $server->send($fd, 'Swoole: '.$data);
});
$server->start();
```

!> В событии `[onReceive](/server/events?id=onreceive)` произошел бесконечный цикл, `server` больше не сможет принимать какие-либо запросы от клиентов, ему придется ждать завершения цикла, прежде чем начать procesирование новых событий.
