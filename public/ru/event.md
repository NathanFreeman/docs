# Событие

Расширение `Swoole` также предоставляет интерфейс для прямого управления базовым циклом событий `epoll/kqueue`. Можно добавить `socket`, созданный другими расширениями, или `socket`, созданный в PHP с использованием расширения `stream/socket`, в [Круглую цикл событий Swoole](/learn?id=что такое eventloop).
Иначе, если `$fd` стороннего производителя является синхронным IO, это может привести к тому, что цикл событий Swoole не будет выполнен, [см. пример для справки](/learn?id=синхронный io в асинхронный io).

!> Модуль `Event` довольно низкоуровнев, это первичная обертка для `epoll`, и пользователям лучше иметь опыт программирования с множественным доступом к IO.


## Приоритет событий

1. Функции обратной связи для обработки сигналов, установленные с помощью `Process::signal`
2. Функции обратной связи для таймеров, установленные с помощью `Timer::tick` и `Timer::after`
3. Функции задержанного выполнения, установленные с помощью `Event::defer`
4. Циклические функции обратной связи, установленные с помощью `Event::cycle`


## Методы


### add()

Добавьте `socket` в базовый реактор событий для наблюдения. Эта функция может использоваться в режиме `Server` или `Client`.
```php
Swoole\Event::add(mixed $sock, callable $read_callback, callable $write_callback = null, int $flags = null): bool
```

!> При использовании в `Server` программе, необходимо использовать после запуска `Worker` процесса. Не следует вызывать никаких асинхронных `IO` интерфейсов до начала `Server::start`

* **Параметры** 

  * **`mixed $sock`**
    * **Функция**: Файловый дескриптор, `stream` ресурс, `sockets` ресурс, `object`
    * **По умолчанию**: нет
    * **Другие значения**: нет

  * **`callable $read_callback`**
    * **Функция**: Функция обратной связи для событий чтения
    * **По умолчанию**: нет
    * **Другие значения**: нет

  * **`callable $write_callback`**
    * **Функция**: Функция обратной связи для событий письма【Этот параметр может быть именем функции строки, объектом+методом, статическим методом класса или анонимной функцией. Когда этот `socket`可读 или письменен, будет вызвана указанная функция.】
    * **По умолчанию**: нет
    * **Другие значения**: нет

  * **`int $flags`**
    * **Функция**: Маска типов событий【Можно выбрать отключение/включение чтения и письма событий, например `SWOOLE_EVENT_READ`, `SWOOLE_EVENT_WRITE` или `SWOOLE_EVENT_READ|SWOOLE_EVENT_WRITE`】
    * **По умолчанию**: нет
    * **Другие значения**: нет

* **4 типа `$sock`**


Тип | Описание
---|---
int | Файловый дескриптор, включая `Swoole\Client->$sock`, `Swoole\Process->$pipe` или другой `$fd`
ресурс stream | Ресурс, созданный с помощью `stream_socket_client`/`fsockopen`
ресурс sockets | Ресурс, созданный с помощью `socket_create` в расширении `sockets`, необходимо добавить при сборке с [./configure --enable-sockets](/environment?id=сборочные опции)
object | `Swoole\Process` или `Swoole\Client`, на нижнем уровне автоматически преобразуется в [UnixSocket](/learn?id=что такое IPC) ( `Process` ) или `socket` клиента ( `Swoole\Client` )

* **Возвращаемое значение**

  * Успешное добавление наблюдения за событием возвращает `true`
  * Неудача добавления возвращает `false`, пожалуйста, используйте `swoole_last_error` для получения ошибки
  * Уже добавленный `socket` не может быть добавлен повторно, можно использовать `swoole_event_set` для изменения обратной связи и типа события для `socket`

  !> Использование `Swoole\Event::add` для добавления `socket` в наблюдение за событием на нижнем уровне автоматически установит этот `socket` в несинхронный режим

* **Пример использования**

```php
$fp = stream_socket_client("tcp://www.qq.com:80", $errno, $errstr, 30);
fwrite($fp,"GET / HTTP/1.1\r\nHost: www.qq.com\r\n\r\n");

Swoole\Event::add($fp, function($fp) {
    $resp = fread($fp, 8192);
    // после обработки socket, удалить socket из события epoll
    Swoole\Event::del($fp);
    fclose($fp);
});
echo "Finish\n";  // `Swoole\Event::add` не будет блокировать процесс, эта строка кода будет выполняться последовательно
```

* **Функции обратной связи**

  * В функции обратной связи для события чтения ($read_callback) необходимо использовать функции, такие как `fread`, `recv`, чтобы прочитать данные из буфера `socket`, иначе событие будет продолжаться с триггером, и если вы не хотите продолжать чтение, необходимо использовать `Swoole\Event::del` для удаления наблюдения за событием
  * В функции обратной связи для события письма ($write_callback), после написания в `socket`, необходимо вызвать `Swoole\Event::del` для удаления наблюдения за событием, иначе событие письма будет продолжаться с триггером
  * Если `fread`, `socket_recv`, `socket_read`, `Swoole\Client::recv` возвращают `false` и код ошибки является `EAGAIN`, это означает, что в текущем буфере приема `socket` нет никаких данных, в этот момент необходимо добавить наблюдение за чтением в ожидании уведомления от [Круглого цикла событий](/learn?id=что такое eventloop)
  * Если `fwrite`, `socket_write`, `socket_send`, `Swoole\Client::send` возвращают `false` и код ошибки является `EAGAIN`, это означает, что текущий буфер отправки `socket`已满 и временно нельзя отправлять данные. Необходимо наблюдать за событиями письма в ожидании уведомления от [Круглого цикла событий](/learn?id=что такое eventloop)


### set()

Изменить функцию обратной связи и маску наблюдения за событием.

```php
Swoole\Event::set($fd, mixed $read_callback, mixed $write_callback, int $flags): bool
```

* **Параметры** 

  * Параметры полностью идентичны [Event::add](/event?id=add). Если传入ный `$fd` не существует в [Круглом цикле событий](/learn?id=что такое eventloop), возвращается `false`.
  * Когда `$read_callback` не равен `null`, будет изменена функция обратной связи для чтения на указанную функцию
  * Когда `$write_callback` не равен `null`, будет изменена функция обратной связи для письма на указанную функцию
  * `$flags` может быть включен/отключен, можно контролировать прослушивание событий чтения ( `SWOOLE_EVENT_READ` ) и письма ( `SWOOLE_EVENT_WRITE` )  

  !> Обратите внимание, что если вы настраиваете прослушивание события чтения `SWOOLE_EVENT_READ`, но в настоящее время не установлена функция обратной связи для чтения, низший уровень просто сохранит информацию о функции обратной связи и не вызовет никакого события обратной связи.
  * Можно использовать `Event::set($fd, null, null, SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE)`, чтобы изменить тип события наблюдения, в этот момент низший уровень вызовет событие чтения.

* **Изменение состояния**

  * Использование `Event::add` или `Event::set` для установки функции обратной связи для чтения событий, но не прослушивание события чтения `SWOOLE_EVENT_READ`, в этот момент низший уровень сохраняет информацию только о функции обратной связи и не вызывает никаких событий обратной связи.
  * Можно использовать `Event::set($fd, null, null, SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE)`, чтобы изменить тип событий наблюдения, в этот момент низший уровень вызовет событие чтения.

* **Освобождение функции обратной связи**

!> Обратите внимание, что `Event::set` может заменить только функцию обратной связи, но не может освободить функцию обратной связи события. Например: `Event::set($fd, null, null, SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE)`, где в параметрах传入ые `$read_callback` и `$write_callback` равны `null`, что означает не изменение функции обратной связи, установленной с помощью `Event::add`, а не установление функции обратной связи события на `null`.

Функции обратной связи `$read_callback` и `$write_callback` будут освобождены только при вызове `Event::del` для удаления наблюдения за событием.


### isset()

Проверить, добавлен ли传入ный `$fd` в наблюдение за событием.

```php
Swoole\Event::isset(mixed $fd, int $events = SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE): bool
```

* **Параметры** 

  * **`mixed $fd`**
    * **Функция**: Любой файловый дескриптор `socket`【Смотрите документацию по [Event::add](/event?id=add)】
    * **По умолчанию**: нет
    * **Другие значения**: нет

  * **`int $events`**
    * **Функция**: Типы событий для проверки
    * **По умолчанию**: нет
    * **Другие значения**: нет

* **$events**
Вид события | Описание
---|---
`SWOOLE_EVENT_READ` | Слушается ли событие чтения
`SWOOLE_EVENT_WRITE` | Слушается ли событие письма
`SWOOLE_EVENT_READ \| SWOOLE_EVENT_WRITE` | Слушается событие чтения или письма

* **Пример использования**

```php
use Swoole\Event;

$fp = stream_socket_client("tcp://www.qq.com:80", $errno, $errstr, 30);
fwrite($fp,"GET / HTTP/1.1\r\nHost: www.qq.com\r\n\r\n");

Event::add($fp, function($fp) {
    $resp = fread($fp, 8192);
    Swoole\Event::del($fp);
    fclose($fp);
}, null, SWOOLE_EVENT_READ);
var_dump(Event::isset($fp, SWOOLE_EVENT_READ)); //возвращает true
var_dump(Event::isset($fp, SWOOLE_EVENT_WRITE)); //возвращает false
var_dump(Event::isset($fp, SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE)); //возвращает true
```

### write()

Используется для сокетов, созданных с использованием встроенной в PHP расширения `stream/sockets`, для отправки данных на另一方 с помощью функций `fwrite/socket_send` и т.д. Когда объем отправляемых данных большой, а буфер для письма сокета полон, это может привести к блокировке ожидания или возвращению ошибки [EAGAIN](/other/errno?id=linux).

Функция `Event::write` может сделать отправку данных через `stream/sockets` ресурсы **асинхронной**, когда буфер полон или возвращается [EAGAIN](/other/errno?id=linux), Swoole на нижнем уровне добавит данные в очередь отправки и будет слушать возможность письма. Когда сокет может быть написан, Swoole на нижнем уровне автоматически пишет

```php
Swoole\Event::write(mixed $fd, miexd $data): bool
```

* **Параметры** 

  * **`mixed $fd`**
    * **Функция**: Любой файловый дескриптор сокета 【Смотрите [Event::add](/event?id=add) документ】
    * **По умолчанию**: нет
    * **Другие значения**: нет

  * **`miexd $data`**
    * **Функция**: Данные для отправки 【Длина отправляемых данных не должна превышать размер буфера `Socket`】
    * **По умолчанию**: нет
    * **Другие значения**: нет

!> `Event::write` не может использоваться для ресурсов `stream/sockets` с туннельным шифрованием, такими как `SSL/TLS`  
После успешной операции `Event::write`, автоматически установится режим неблокировки для этого `$socket`

* **Пример использования**

```php
use Swoole\Event;

$fp = stream_socket_client('tcp://127.0.0.1:9501');
$data = str_repeat('A', 1024 * 1024*2);

Event::add($fp, function($fp) {
     echo fread($fp);
});

Event::write($fp, $data);
```

#### логика работы Swoole на нижнем уровне после того, как буфер сокета был полностью заполнен

Продолжительное письмо в `SOCKET`, если другая сторона не читает быстро достаточно, то буфер сокета будет заполнен. На нижнем уровне Swoole сохранит данные в памяти, пока не наступит событие возможности письма, и тогда он будет написан в `SOCKET`.

Если и память для缓存 также была полностью заполнена, в этот момент на нижнем уровне Swoole抛出ет ошибку `pipe buffer overflow, reactor will block.`, и перейдет в блокирующее ожидание.

!> Возвращение `false` при заполнении缓存 - это атомарная операция, может произойти только полный успех или полный отказ от написания


### del()

Удалить прослушивание сокета из `reactor`. `Event::del` должен использоваться в паре с `Event::add`.

```php
Swoole\Event::del(mixed $sock): bool
```

!> Необходимо использовать `Event::del` для удаления события прослушивания до закрытия `socket`, иначе может возникнуть утечка памяти

* **Параметры** 

  * **`mixed $sock`**
    * **Функция**: Файловый дескриптор сокета
    * **По умолчанию**: нет
    * **Другие значения**: нет


### exit()

Выход из события цикла мониторинга.

!> Эта функция действительна только в программе `Client`

```php
Swoole\Event::exit(): void
```


### defer()

Выполнить функцию после начала следующего цикла событий. 

```php
Swoole\Event::defer(mixed $callback_function);
```

!> КCALLBACK функции `Event::defer` будет применяться после завершения текущего цикла событий `EventLoop`, и перед началом следующего.

* **Параметры** 

  * **`mixed $callback_function`**
    * **Функция**: Функция, которая будет вызвана по истечении времени. 【Ключевым требованием является то, что функция должна быть invocируемой. КCALLBACK функции не принимаются никакие параметры, можно передавать параметры к КCALLBACK функции с помощью семантики `use` анонимной функции; при выполнении функции `$callback_function` можно добавить новые задания `defer`, которые также будут выполнены в рамках текущего цикла событий】
    * **По умолчанию**: нет
    * **Другие значения**: нет

* **Пример использования**

```php
Swoole\Event::defer(function(){
    echo "После EventLoop\n";
});
```


### cycle()

Определить функцию для периодического выполнения в цикле событий. Эта функция будет вызвана после завершения каждого цикла событий. 

```php
Swoole\Event::cycle(callable $callback, bool $before = false): bool
```

* **Параметры** 

  * **`callable $callback_function`**
    * **Функция**: Функция, которую следует установить. 【Если `$callback` равен `null`, это означает очистку функции `cycle`, установленной ранее функции `cycle`, при повторном установке она заменит предыдущую настройку】
    * **По умолчанию**: нет
    * **Другие значения**: нет

  * **`bool $before`**
    * **Функция**: Вызвать эту функцию до [EventLoop](/learn?id=что такоеeventloop)
    * **По умолчанию**: нет
    * **Другие значения**: нет

!> Можно существовать одновременно две функции обратного вызова `before=true` и `before=false`.

  * **Пример использования**

```php
Swoole\Timer::tick(2000, function ($id) {
    var_dump($id);
});

Swoole\Event::cycle(function () {
    echo "Привет [1]\n";
    Swoole\Event::cycle(function () {
        echo "Привет [2]\n";
        Swoole\Event::cycle(null);
    });
});
```


### wait()

Запустить прослушивание событий.

!> Пожалуйста, размещайте эту функцию в конце PHP программы

```php
Swoole\Event::wait();
```

* **Пример использования**

```php
Swoole\Timer::tick(1000, function () {
    echo "Привет\n";
});

Swoole\Event::wait();
```

### dispatch()

Запустить прослушивание событий.

!> Выполняет только одну операцию `reactor->wait`, что на платформе `Linux` эквивалентно ручному вызову `epoll_wait`. В отличие от `Event::wait`, `Event::dispatch` на нижнем уровне поддерживает цикл.

```php
Swoole\Event::dispatch();
```

* **Пример использования**

```php
while(true)
{
    Event::dispatch();
}
```

Цель этой функции - совместимость с некоторыми фреймворками, такими как `amp`, которые внутри контролируют цикл `reactor`, а использование `Event::wait` не дает Swoole нижнему уровню контролировать, что не позволяет передать контроль фреймворку.
