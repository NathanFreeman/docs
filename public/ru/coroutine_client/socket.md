# Корутины\Сocket

Модуль `Swoole\Coroutine\Socket` по сравнению с [корутинным стилем серверного端的](/server/co_init) и [корутинным клиентским](/coroutine_client/init) соответствующих модулей `Socket` может выполнять более мелкие операции `IO`.

!> Можно использовать краткое название `Co\Socket` для упрощения имени класса. Этот модуль довольно низкоуровневый, и пользователям лучше иметь опыт работы с сокетами.


## Полный пример

```php
use Swoole\Coroutine;
use function Swoole\Coroutine\run;

run(function () {
    $socket = new Coroutine\Socket(AF_INET, SOCK_STREAM, 0);

    $retval = $socket->connect('127.0.0.1', 9601);
    while ($retval)
    {
        $n = $socket->send('hello');
        var_dump($n);

        $data = $socket->recv();
        var_dump($data);

        // Произошла ошибка или противник закрыл соединение, и нужно также закрыть его
        if ($data === '' || $data === false) {
            echo "errCode: {$socket->errCode}\n";
            $socket->close();
            break;
        }

        Coroutine::sleep(1.0);
    }

    var_dump($retval, $socket->errCode, $socket->errMsg);
});
```


## Корутинное планирование

Итераторы операций `IO`, предоставляемые модулем `Coroutine\Socket`, выполнены в стиле синхронного программирования, а на нижнем уровне автоматически используется [корутинный планировщик](/coroutine?id=корутинный планировщик) для реализации [асинхронного IO](/learn?id=синхронныйioасинхронныйio).


## Ошибочные коды

При выполнении системных вызовов, связанных с `socket`, возможно возвращение ошибки `-1`, в нижнем слое будет установлен свойство `Coroutine\Socket->errCode` на системный номер ошибки `errno`, пожалуйста, ознакомьтесь с соответствующим документом `man`. Например, если `socket->accept()` возвращает ошибку, значение `errCode` может быть найдено в документе об ошибках, перечисленных в `man accept`.


## Свойства


### fd

Идентификационный номер файла сокета


### errCode

Ошибочный код


## Методы


### __construct()

Конструктор. Создание объекта `Coroutine\Socket`.

```php
Swoole\Coroutine\Socket::__construct(int $domain, int $type, int $protocol);
```

!> Подробности можно найти в документе `man socket`.

  * **Параметры** 

    * **`int $domain`**
      * **Функция**: протокол домена【возможно использовать `AF_INET`, `AF_INET6`, `AF_UNIX`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`int $type`**
      * **Функция**: тип【возможно использовать `SOCK_STREAM`, `SOCK_DGRAM`, `SOCK_RAW`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`int $protocol`**
      * **Функция**: протокол【возможно использовать `IPPROTO_TCP`, `IPPROTO_UDP`, `IPPROTO_STCP`, `IPPROTO_TIPC`, `0`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

!> Конструктор вызывает системный вызов `socket` для создания сокетного дескриптора. В случае неудачи抛出 исключение `Swoole\Coroutine\Socket\Exception`. И устанавливает свойство `$socket->errCode`. С помощью этого свойства можно узнать причину неудачи системного вызова.


### getOption()

Получение настроек.

!> Этот метод соответствует системному вызову `getsockopt`, подробности можно найти в документе `man getsockopt`.  
Этот метод эквивалентен функции `socket_get_option` расширения `sockets`, подробности можно посмотреть в [документе PHP](https://www.php.net/manual/zh/function.socket-get-option.php).

!> Версия Swoole >= v4.3.2

```php
Swoole\Coroutine\Socket->getOption(int $level, int $optname): mixed
```

  * **Параметры** 

    * **`int $level`**
      * **Функция**: указывает уровень протокола, в котором находятся настройки
      * **По умолчанию**: нет
      * **Другие значения**: нет

      !> Например, чтобы получить настройки на уровне сокета, используется параметр `level` с значением `SOL_SOCKET`.  
      Можно использовать другие уровни, указывая номер протокола этого уровня, например `TCP`. Использовать функцию [getprotobyname](https://www.php.net/manual/zh/function.getprotobyname.php) можно найти номер протокола.

    * **`int $optname`**
      * **Функция**: доступные опции сокета такие же, как и у функции [socket_get_option()](https://www.php.net/manual/zh/function.socket-get-option.php)
      * **По умолчанию**: нет
      * **Другие значения**: нет


### setOption()

Установка настроек.

!> Этот метод соответствует системному вызову `setsockopt`, подробности можно найти в документе `man setsockopt`. Этот метод эквивалентен функции `socket_set_option` расширения `sockets`, подробности можно посмотреть в [документе PHP](https://www.php.net/manual/zh/function.socket-set-option.php)

!> Версия Swoole >= v4.3.2

```php
Swoole\Coroutine\Socket->setOption(int $level, int $optname, mixed $optval): bool
```

  * **Параметры** 

    * **`int $level`**
      * **Функция**: указывает уровень протокола, в котором находятся настройки
      * **По умолчанию**: нет
      * **Другие значения**: нет

      !> Например, чтобы установить настройки на уровне сокета, используется параметр `level` с значением `SOL_SOCKET`.  
      Можно использовать другие уровни, указывая номер протокола этого уровня, например `TCP`. Использовать функцию [getprotobyname](https://www.php.net/manual/zh/function.getprotobyname.php) можно найти номер протокола.

    * **`int $optname`**
      * **Функция**: доступные опции сокета такие же, как и у функции [socket_get_option()](https://www.php.net/manual/zh/function.socket-get-option.php)
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`int $optval`**
      * **Функция**: значение опции 【возможно `int`, `bool`, `string`, `array`. Определяется в зависимости от `level` и `optname`】
      * **По умолчанию**: нет
      * **Другие значения**: нет


### setProtocol()

Обеспечивает сокету способность обрабатывать протокол, можно настроить, включать ли шифрование передачи по `SSL` и решить проблемы с [границами пакетов TCP](/learn?id=tcpграницыпакетов) и т.д.

!> Версия Swoole >= v4.3.2

```php
Swoole\Coroutine\Socket->setProtocol(array $settings): bool
```

  * **Поддерживаемые параметры `$settings`**


Параметр | Тип
---|---
open_ssl |布尔
ssl_cert_file | string
ssl_key_file | string
open_eof_check |布尔
open_eof_split |布尔
open_mqtt_protocol |布尔
open_fastcgi_protocol |布尔
open_length_check |布尔
package_eof | string
package_length_type | string
package_length_offset | int
package_body_offset | int
package_length_func | callable
package_max_length | int

!> Все вышеупомянутые параметры имеют то же значение, что и у метода [Server->set()](/server/setting?id=open_eof_check), и здесь мы не будем повторяться.

  * **Пример**

```php
$socket->setProtocol([
    'open_length_check'     => true,
    'package_max_length'    => 1024 * 1024,
    'package_length_type'   => 'N',
    'package_length_offset' => 0,
    'package_body_offset'   => 4,
]);
```


### bind()

Привязывание адреса и порта.

!> Этот метод не выполняет `IO` операций и не вызывает переключение корутин

```php
Swoole\Coroutine\Socket->bind(string $address, int $port = 0): bool
```

  * **Параметры** 

    * **`string $address`**
      * **Функция**: привязанный адрес 【например `0.0.0.0`, `127.0.0.1`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`int $port`**
      * **Функция**: привязанный порт 【по умолчанию `0`, система будет случайно выбрать подходящий порт, используя метод [getsockname](/coroutine_client/socket?id=getsockname) можно получить порты, выделенные системой】
      * **По умолчанию**: `0`
      * **Другие значения**: нет

  * **Возвращаемое значение** 

    * Успешное привлечение возвращает `true`
    * Неудача привязанности возвращает `false`, пожалуйста, проверьте свойство `errCode`, чтобы узнать причину неудачи

### слушать()

Слушать `Socket`.

!> Этот метод не involves операции `IO` и не вызывает переключение корутин.

```php
Swoole\Coroutine\Socket->listen(int $backlog = 0): bool
```

  * **Параметры** 

    * **`int $backlog`**
      * **Функция**: Длина очереди ожидания【По умолчанию `0`, система использует `epoll` для реализации асинхронного `IO`,不存在 блокировки, поэтому важность `backlog` не так велика】
      * **Значение по умолчанию**: `0`
      * **Другие значения**: Нет

      !> Если в приложении есть блокирующие или длительные операции, `accept` не принимает соединения вовремя, новые соединения будут накапливаться в очереди ожидания `backlog`, и если они превышают длину `backlog`, служба будет отказываться от новых подключений.

  * **Возвращаемое значение** 

    * Успешное связывание возвращает `true`
    * Неудача связывания возвращает `false`, пожалуйста, проверьте свойство `errCode` чтобы узнать причину неудачи

  * **Ключевые параметры ядра** 

    Максимальная значение `backlog` ограничена ключевым параметром ядра `net.core.somaxconn`, и на `Linux` можно использовать инструмент `sysctl` для динамического регулирования всех параметров ядра. Динамическое регулирование вступает в силу немедленно после изменения значения ядра. Однако это применение ограничивается на уровне операционной системы, чтобы действительно применить изменения, необходимо перезапустить приложение, команда `sysctl -a` будет отображать все параметры ядра и их значения.

    ```shell
    sysctl -w net.core.somaxconn=2048
    ```

    Вышеуказанная команда изменяет значение ключевого параметра ядра `net.core.somaxconn` на `2048`. Такие изменения могут вступать в силу немедленно, но после перезагрузки машины они вернутся к умолчанию. Чтобы сохранить изменения навсегда, необходимо изменить `/etc/sysctl.conf`, добавить `net.core.somaxconn=2048`, а затем выполнить команду `sysctl -p` для применения изменений.


### принимать()

Принимать соединения, инициированные клиентом.

Вызов этого метода немедленно замораживает текущую корутину и добавляет ее в [EventLoop](/learn?id=что такоеeventloop) для мониторинга событий чтения. Когда `Socket` становится доступным для чтения и приходит новое соединение, корутина автоматически просыпается и возвращает объект `Socket`, corresponding к подключению клиента.

!> Этот метод должен использоваться после использования метода `listen` и подходит для серверной стороны.

```php
Swoole\Coroutine\Socket->accept(float $timeout = 0): Coroutine\Socket|false;
```

  * **Параметры** 

    * **`float $timeout`**
      * **Функция**: Установить тайм-out【После установки параметра тайм-out, нижний уровень установит таймер, и если в установленном времени не приходит соединение от клиента, метод `accept` вернет `false`】
      * **Единица измерения**: секунды【Поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`】
      * **Значение по умолчанию**: См. [правила тайм-out для клиентов](/coroutine_client/init?id=правила_тайм-out)
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * Возвращает `false` в случае тайм-out или ошибки системного вызова `accept`, можно использовать свойство `errCode` для получения кода ошибки, где код ошибки тайм-out составляет `ETIMEDOUT`
    * Успешное возвращение `socket` клиента, также типа `Swoole\Coroutine\Socket` объекта. Можно выполнять на нем операции, такие как `send`, `recv`, `close` и т.д.

  * **Пример**

```php
use Swoole\Coroutine;
use function Swoole\Coroutine\run;

run(function () {
$socket = new Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
$socket->bind('127.0.0.1', 9601);
$socket->listen(128);

    while(true) {
        echo "Accept: \n";
        $client = $socket->accept();
        if ($client === false) {
            var_dump($socket->errCode);
        } else {
            var_dump($client);
        }
    }
});
```


### соединиться()

Соединиться с целевым сервером.

Вызов этого метода инициирует асинхронный системный вызов `connect` и замораживает текущую корутину, нижний уровень будет наблюдать за события написания, и когда соединение завершено или потерпело неудачу, корутина будет восстановлена.

Этот метод подходит для клиентской стороны, поддерживает `IPv4`, `IPv6`, [unixSocket](/learn?id=что такоеIPC).

```php
Swoole\Coroutine\Socket->connect(string $host, int $port = 0, float $timeout = 0): bool
```

  * **Параметры** 

    * **`string $host`**
      * **Функция**: Адрес целевого сервера【Например, `127.0.0.1`, `192.168.1.100`, `/tmp/php-fpm.sock`, `www.baidu.com` и т.д., можно传入 `IP` адрес, путь к `Unix Socket` или домен. Если это домен, нижний уровень автоматически выполняет асинхронный `DNS` çözüm и не вызывает блокировки】
      * **Значение по умолчанию**: Нет
      * **Другие значения**: Нет

    * **`int $port`**
      * **Функция**: Порт целевого сервера【Если `Socket` имеет `domain` `AF_INET` или `AF_INET6`, необходимо установить порт】
      * **Значение по умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установить время ожидания【Нижний уровень установит таймер, и если в установленном времени невозможно установить соединение, `connect` вернет `false`】
      * **Единица измерения**: секунды【Поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`】
      * **Значение по умолчанию**: См. [правила тайм-out для клиентов](/coroutine_client/init?id=правила_тайм-out)
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * Возвращает `false` в случае тайм-out или ошибки системного вызова `connect`, можно использовать свойство `errCode` для получения кода ошибки, где код ошибки тайм-out составляет `ETIMEDOUT`
    * Успешное возвращение `true`


### проверить жизнеспособность()

Проверить, жива ли связь (не работает при необычном отключении, может обнаружить только отключение другой стороны после нормального закрытия)

!> С版本的Swoole >= `v4.5.0` доступна

```php
Swoole\Coroutine\Socket->checkLiveness(): bool
```

  * **Возвращаемое значение** 

    * Возвращает `true`, если связь живой, в противном случае `false`


### отправить()

Отправьте данные на другой конец.

!> Метод `send` немедленно выполняет системный вызов `send` для отправки данных, и когда системный вызов `send` возвращает ошибку `EAGAIN`, нижний уровень автоматически наблюдает за событиями написания и замораживает текущую корутину, ожидая, когда событие написания будет активировано, затем снова выполняет системный вызов `send` для отправки данных и просыпает эту корутину.  

!> Если `send` слишком быстро и `recv` слишком медленно, в конечном итоге это может привести к тому, что операционная система переполняет буфер написания, и текущая корутина будет заморожена в методе `send`. Можно увеличить буфер, [/proc/sys/net/core/wmem_max и SO_SNDBUF](https://stackoverflow.com/questions/21856517/whats-the-practical-limit-on-the-size-of-single-packet-transmitted-over-domain)

```php
Swoole\Coroutine\Socket->send(string $data, float $timeout = 0): int|false
```

  * **Параметры** 

    * **`string $data`**
      * **Функция**: Содержание данных для отправки【Можно быть текстом или двоичным данными】
      * **Значение по умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установить время ожидания
      * **Единица измерения**: секунды【Поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`】
      * **Значение по умолчанию**: См. [правила тайм-out для клиентов](/coroutine_client/init?id=правила_тайм-out)
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * Успешная отправка возвращает количество написанных字节, **пожалуйста, обратите внимание, что на самом деле написанные данные могут быть меньше длины `$data` параметра**, код приложения должен сравнивать возвращенное значение с `strlen($data)` чтобы определить, завершилась ли отправка
    * Неудача отправки возвращает `false` и устанавливает свойство `errCode`

### sendAll()

Отправка данных на противоположный конец. В отличие от метода `send`, `sendAll` будет пытаться отправить данные как можно более полно, пока не будет успешно отправлено все данные или не произойдет ошибка и не будет прекращено.

!> Метод `sendAll` немедленно выполняет несколько системных вызовов `send` для отправки данных, и когда системный вызов `send` возвращает ошибку `EAGAIN`, нижестоящий уровень автоматически 监听ит событие готовности к написанию и замораживает текущую коруoutine, ожидая, пока событие готовности к написанию не наступит, чтобы снова выполнить системный вызов `send` для отправки данных, пока данные не будут полностью отправлены или до ошибки, и разбудить соответствующую коруoutine.  

!> Версия Swoole >= v4.3.0

```php
Swoole\Coroutine\Socket->sendAll(string $data, float $timeout = 0) : int | false;
```

  * **Параметры** 

    * **`string $data`**
      * **Функция**: Содержание данных для отправки [можно текст или бинарные данные]
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установка времени ожидания
      * **Единица измерения**: секунды [поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`]
      * **По умолчанию**: См. [правила времени ожидания клиента](/coroutine_client/init?id=правила времени ожидания)
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * `sendAll` гарантирует успешную отправку всех данных, но в течение `sendAll` противоположный конец может отключиться от соединения, и в этом случае возможно, что только часть данных будет успешно отправлена, и возвращаемое значение будет содержать длину успешно отправленных данных. Приложение должно сравнивать возвращенное значение с `strlen($data)` чтобы определить, завершено ли отправка, и в зависимости от бизнес-потребностей是否需要 продолжить отправку.
    * Отправка потерпела неудачу, возвращается `false`, и устанавливается свойство `errCode`


### peek()

Смотреть на данные в буфере чтения, эквивалентно системному вызову `recv(length, MSG_PEEK)`.

!> `peek` выполняется немедленно и не замораживает коруoutine, но есть одно системное вызов开销

```php
Swoole\Coroutine\Socket->peek(int $length = 65535): string|false
```

  * **Параметры** 

    * **`int $length`**
      * **Функция**: Указывает размер памяти, используемый для копирования данных, которые будут получены во время просмотра ( примечание: здесь будет выделена память, слишком большой размер может привести к исчерпанию памяти)
      * **Единица измерения**:字节
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * Успешное просмотр возвращает данные
    * Отказ в просмотре возвращает `false`, и устанавливается свойство `errCode`


### recv()

Получение данных.

!> Метод `recv` немедленно замораживает текущую коруoutine и 监听ит событие готовности к чтению, ожидая, пока противоположный конец не отправит данные, после чего, когда наступит событие готовности к чтению, будет выполнен системный вызов `recv` для получения данных из буфера `socket`, и эта коруoutine будет разбужена.

```php
Swoole\Coroutine\Socket->recv(int $length = 65535, float $timeout = 0): string|false
```

  * **Параметры** 

    * **`int $length`**
      * **Функция**: Указывает размер памяти, используемый для получения данных ( примечание: здесь будет выделена память, слишком большой размер может привести к исчерпанию памяти)
      * **Единица измерения**:字节
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установка времени ожидания
      * **Единица измерения**: секунды [поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`]
      * **По умолчанию**: См. [правила времени ожидания клиента](/coroutine_client/init?id=правила времени ожидания)
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * Успешное получение возвращает реальные данные
    * Отказ в получении возвращает `false`, и устанавливается свойство `errCode`
    * Отказ в получении из-за истечения времени, код ошибки `ETIMEDOUT`

!> Возвращаемое значение не обязательно равно ожидаемой длине, необходимо самостоятельно проверить длину полученной в этот раз данных. Если необходимо гарантировать получение данных определенной длины за один вызов, используйте метод `recvAll` или самостоятельно циклически получать данные  
Проблема границы TCP-пакетов смотрите в методе `setProtocol()`, или используйте `sendto()`;


### recvAll()

Получение данных. В отличие от `recv`, `recvAll` будет пытаться получить данные как можно более полно, пока не будет получено все данные или не произойдет ошибка и не будет прекращено.

!> Метод `recvAll` немедленно замораживает текущую коруoutine и 监听ит событие готовности к чтению, ожидая, пока противоположный конец не отправит данные, после чего, когда наступит событие готовности к чтению, будет выполнен системный вызов `recv` для получения данных из буфера `socket`, и этот процесс будет повторяться до тех пор, пока не будут получены данные определенного размера или не произойдет ошибка, после чего коруoutine будет разбужена.

!> Версия Swoole >= v4.3.0

```php
Swoole\Coroutine\Socket->recvAll(int $length = 65535, float $timeout = 0): string|false
```

  * **Параметры** 

    * **`int $length`**
      * **Функция**: Ожидаемая длина получаемых данных ( примечание: здесь будет выделена память, слишком большой размер может привести к исчерпанию памяти)
      * **Единица измерения**:字节
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установка времени ожидания
      * **Единица измерения**: секунды [поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`]
      * **По умолчанию**: См. [правила времени ожидания клиента](/coroutine_client/init?id=правила времени ожидания)
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * Успешное получение возвращает реальные данные, и длина возвращенной строки совпадает с заданным размером
    * Отказ в получении возвращает `false`, и устанавливается свойство `errCode`
    * Отказ в получении из-за истечения времени, код ошибки `ETIMEDOUT`


### readVector()

Получение данных в сегментах.

!> Метод `readVector` немедленно выполняет системный вызов `readv` для чтения данных, и когда системный вызов `readv` возвращает ошибку `EAGAIN`, нижестоящий уровень автоматически 监听ит событие готовности к чтению и замораживает текущую коруoutine, ожидая, пока событие готовности к чтению не наступит, чтобы снова выполнить системный вызов `readv` для чтения данных, и разбудить соответствующую коруoutine.  

!> Версия Swoole >= v4.5.7

```php
Swoole\Coroutine\Socket->readVector(array $io_vector, float $timeout = 0): array|false
```

  * **Параметры** 

    * **`array $io_vector`**
      * **Функция**: Ожидаемая длина данных в сегментах для получения
      * **Единица измерения**:字节
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установка времени ожидания
      * **Единица измерения**: секунды [поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`]
      * **По умолчанию**: См. [правила времени ожидания клиента](/coroutine_client/init?id=правила времени ожидания)
      * **Другие значения**: Нет

  * **Возвращаемое значение**

    * Успешное получение возвращает данные в сегментах
    * Отказ в получении возвращает пустой массив, и устанавливается свойство `errCode`
    * Отказ в получении из-за истечения времени, код ошибки `ETIMEDOUT`

  * **Пример** 

```php
$socket = new Swoole\Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
// Если противоположный конец отправил "helloworld"
$ret = $socket->readVector([5, 5]);
// Тогда, $ret будет ['hello', 'world']
```


### readVectorAll()

Получение данных в сегментах.

!> Метод `readVectorAll` немедленно выполняет несколько системных вызовов `readv` для чтения данных, и когда системный вызов `readv` возвращает ошибку `EAGAIN`, нижестоящий уровень автоматически 监听ит событие готовности к чтению и замораживает текущую коруoutine, ожидая, пока событие готовности к чтению не наступит, чтобы снова выполнить системный вызов `readv` для чтения данных, и продолжит этот процесс до тех пор, пока данные не будут полностью прочитаны или не произойдет ошибка, после чего соответствующая коруoutine будет разбужена.

!> Версия Swoole >= v4.5.7

```php
Swoole\Coroutine\Socket->readVectorAll(array $io_vector, float $timeout = 0): array|false
```

  * **Параметры** 

    * **`array $io_vector`**
      * **Функция**: Ожидаемая длина данных в сегментах для получения
      * **Единица измерения**:字节
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установка времени ожидания
      * **Единица измерения**: секунды [поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`]
      * **По умолчанию**: См. [правила времени ожидания клиента](/coroutine_client/init?id=правила времени ожидания)
      * **Другие значения**: Нет

  * **Возвращаемое значение**

    * Успешное получение возвращает данные в сегментах
    * Отказ в получении возвращает пустой массив, и устанавливается свойство `errCode`
    * Отказ в получении из-за истечения времени, код ошибки `ETIMEDOUT`
### writeVector()

Отправка данных по частям.

!> Метод `writeVector` немедленно выполняет системный вызов `writev` для отправки данных. Когда системный вызов `writev` возвращает ошибку `EAGAIN`, нижестоящий уровень автоматически 监听ит событие готовности к написанию и замораживает текущую корутину, ожидая, пока событие готовности к написанию не произойдет, чтобы снова выполнить системный вызов `writev` для отправки данных и разбудить эту корутину.  

!> Версия Swoole >= v4.5.7

```php
Swoole\Coroutine\Socket->writeVector(array $io_vector, float $timeout = 0): int|false
```

  * **Параметры** 

    * **`array $io_vector`**
      * **Функция**: Ожидаемые куски данных для отправки
      * **Единица измерения**: Байты
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установка времени ожидания
      * **Единица измерения**: секунды【Поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`】
      * **По умолчанию**: См. [правила таймаута клиента](/coroutine_client/init?id=правила таймаута)
      * **Другие значения**: Нет

  * **Возвращаемое значение**

    * В случае успешной отправки возвращается количество отправленных байтов, **пожалуйста, обратите внимание, что на самом деле отправленные данные могут быть меньше общей длины `$io_vector`** , чтобы определить, завершена ли отправка, приложение должно сравнить возвращенное значение с общей длиной `$io_vector`
    * В случае неудачи отправки возвращается `false`, и устанавливается свойство `errCode`

  * **Пример** 

```php
$socket = new Swoole\Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
// В этот момент данные будут отправлены в порядке, указанного в массиве, на самом деле это будет отправка "hello world"
$socket->writeVector(['hello', 'world']);
```


### writeVectorAll()

Отправка данных на另一方. В отличие от метода `writeVector`, `writeVectorAll` будет стараться отправить данные как можно более полно, пока не будет успешно отправлено все данные или не будет получена ошибка и отправка будет прервана.

!> Метод `writeVectorAll` немедленно выполняет несколько системных вызовов `writev` для отправки данных, когда системный вызов `writev` возвращает ошибку `EAGAIN`, нижестоящий уровень автоматически 监听ит событие готовности к написанию и замораживает текущую корутину, ожидая, пока событие готовности к написанию не произойдет, чтобы снова выполнить системный вызов `writev` для отправки данных, пока данные не будут отправлены или не будет получена ошибка, и разбудить соответствующую корутину.

!> Версия Swoole >= v4.5.7

```php
Swoole\Coroutine\Socket->writeVectorAll(array $io_vector, float $timeout = 0): int|false
```

  * **Параметры** 

    * **`array $io_vector`**
      * **Функция**: Ожидаемые куски данных для отправки
      * **Единица измерения**: Байты
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Установка времени ожидания
      * **Единица измерения**: секунды【Поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`】
      * **По умолчанию**: См. [правила таймаута клиента](/coroutine_client/init?id=правила таймаута)
      * **Другие значения**: Нет

  * **Возвращаемое значение**

    * `writeVectorAll` гарантирует успешную отправку всех данных, но во время `writeVectorAll` на стороне получателя может быть закрыта связь, и в этот момент возможно было успешно отправлено только часть данных, возвращаемое значение будет содержать длину успешно отправленных данных, приложение должно сравнить возвращенное значение с общей длиной `$io_vector` чтобы определить, завершена ли отправка, и в зависимости от бизнес-потребностей是否需要 пересылка.
    * В случае неудачи отправки возвращается `false`, и устанавливается свойство `errCode`

  * **Пример** 

```php
$socket = new Swoole\Coroutine\Socket(AF_INET, SOCK_STREAM, 0);
// В этот момент данные будут отправлены в порядке, указанного в массиве, на самом деле это будет отправка "hello world"
$socket->writeVectorAll(['hello', 'world']);
```


### recvPacket()

Для объекта Socket, на котором уже установлена protocols с помощью метода `setProtocol`, можно вызвать этот метод для приема целой пакета данных по протоколу.

!> Версия Swoole >= v4.4.0

```php
Swoole\Coroutine\Socket->recvPacket(float $timeout = 0): string|false
```

  * **Параметры** 
    * **`float $timeout`**
      * **Функция**: Установка времени ожидания
      * **Единица измерения**: секунды【Поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`】
      * **По умолчанию**: См. [правила таймаута клиента](/coroutine_client/init?id=правила таймаута)
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * В случае успешного приема возвращается целая пакетная данные по протоколу
    * В случае неудачи приема возвращается `false`, и устанавливается свойство `errCode`
    * В случае просроченного приема, код ошибки `ETIMEDOUT`


### recvLine()

Используется для решения проблемы совместимости с [socket_read](https://www.php.net/manual/en/function.socket-read.php)

```php
Swoole\Coroutine\Socket->recvLine(int $length = 65535, float $timeout = 0): string|false
```


### recvWithBuffer()

Используется для решения проблемы большого количества системных вызовов при использовании `recv(1)` для приема данных по одному биту.

```php
Swoole\Coroutine\Socket->recvWithBuffer(int $length = 65535, float $timeout = 0): string|false
```


### recvfrom()

Получение данных и определение адреса и порта источника. Используется для `SOCK_DGRAM` типов `socket`.

!> Этот метод вызывает [координацию корутин](/coroutine?id=координация корутин), нижестоящий уровень немедленно замораживает текущую корутину и 监听ит событие готовности к чтению. Когда происходит событие готовности к чтению, после получения данных выполняется системный вызов `recvfrom` для получения пакета данных.

```php
Swoole\Coroutine\Socket->recvfrom(array &$peer, float $timeout = 0): string|false
```

* **Параметры**

    * **`array $peer`**
        * **Функция**: Адрес и порт источника, тип ссылки.【Когда функция успешно возвращается, она будет установлена как массив, включая два элемента: `address` и `port`】
        * **По умолчанию**: Нет
        * **Другие значения**: Нет

    * **`float $timeout`**
        * **Функция**: Установка времени ожидания【Если данные не возвращаются в течение установленного времени, метод `recvfrom` вернет `false`】
        * **Единица измерения**: секунды【Поддерживается плавающая точка, например, `1.5` означает `1s`+`500ms`】
        * **По умолчанию**: См. [правила таймаута клиента](/coroutine_client/init?id=правила таймаута)
        * **Другие значения**: Нет

* **Возвращаемое значение**

    * В случае успешного приема данных возвращается содержание данных и `$peer` устанавливается как массив
    * В случае неудачи возвращается `false`, и устанавливается свойство `errCode`, не изменяя содержание `$peer`

* **Пример**

```php
use Swoole\Coroutine;
use function Swoole\Coroutine\run;

run(function () {
    $socket = new Coroutine\Socket(AF_INET, SOCK_DGRAM, 0);
    $socket->bind('127.0.0.1', 9601);
    while (true) {
        $peer = null;
        $data = $socket->recvfrom($peer);
        echo "[Сервер] recvfrom[{$peer['address']}:{$peer['port']}] : $data\n";
        $socket->sendto($peer['address'], $peer['port'], "Swoole: $data");
    }
});
```


### sendto()

Отправка данных на указанную адрес и порт. Используется для `SOCK_DGRAM` типов `socket`.

!> Этот метод не имеет [координации корутин](/coroutine?id=координация корутин), нижестоящий уровень немедленно вызывает `sendto` для отправки данных на целевой хост. Этот метод не будет监听 готовности к написанию, `sendto` может вернуться `false` из-за переполнения буфера, в этом случае необходимо самостоятельно обработать это или использовать метод `send`.

```php
Swoole\Coroutine\Socket->sendto(string $address, int $port, string $data): int|false
```

  * **Параметры** 

    * **`string $address`**
      * **Функция**: IP-адрес целевого хоста или путь к [unixSocket](/learn?id=что такое IPC)【`sendto` не поддерживает доменные имена, при использовании `AF_INET` или `AF_INET6` необходимо传入 действительный IP-адрес, иначе отправка будет неудачной】
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`int $port`**
      * **Функция**: Порт целевого хоста【При отправке широковещания может быть `0`】
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`string $data`**
      * **Функция**: Отправляемые данные【Можно использовать как текст, так и двоичные данные, пожалуйста, обратите внимание, что максимальная длина отправляемого пакета `SOCK_DGRAM` составляет `64K`】
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * В случае успешной отправки возвращается количество отправленных байтов
    * В случае неудачи отправки возвращается `false`, и устанавливается свойство `errCode`

  * **Пример** 

```php
$socket = new Swoole\Coroutine\Socket(AF_INET, SOCK_DGRAM, 0);
$socket->sendto('127.0.0.1', 9601, 'Hello');
```
### getsockname()

Получить информацию о адресе и порту сокета.

!> Этот метод не имеет [координации корутин](/coroutine?id=координации_корутин) издержек.

```php
Swoole\Coroutine\Socket->getsockname(): array|false
```

  * **Возвращаемое значение** 

    * Если вызов успешен, возвращается массив, содержащий `address` и `port`
    * Если вызов неудачен, возвращается `false`, и устанавливается свойство `errCode`


### getpeername()

Получить информацию о адресе и порту сокета-поставителя, используемую только для `SOCK_STREAM` типов сокетов, которые являются соединенными.

?> Этот метод не имеет [координации корутин](/coroutine?id=координации_корутин) издержек.

```php
Swoole\Coroutine\Socket->getpeername(): array|false
```

  * **Возвращаемое значение** 

    * Если вызов успешен, возвращается массив, содержащий `address` и `port`
    * Если вызов неудачен, возвращается `false`, и устанавливается свойство `errCode`


### close()

Завершить сокет.

!> Если объект `Swoole\Coroutine\Socket` уничтожается автоматически и выполняет `close`, этот метод не имеет [координации корутин](/coroutine?id=координации_корутин) издержек.

```php
Swoole\Coroutine\Socket->close(): bool
```

  * **Возвращаемое значение** 

    * Если закрытие успешно, возвращается `true`
    * Если неудачно, возвращается `false`
    

### isClosed()

Сокет уже закрыт?

```php
Swoole\Coroutine\Socket->isClosed(): bool
```

## Константы

Соответствуют константам, предоставляемым расширением `sockets`, и не будут конфликтовать с расширением `sockets`

!> Значения могут различаться на разных системах, приведенный ниже код является лишь примером и не следует использовать его значения

```php
define ('AF_UNIX', 1);
define ('AF_INET', 2);

/**
 * Только доступно, если собран с поддержкой IPv6.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('AF_INET6', 10);
define ('SOCK_STREAM', 1);
define ('SOCK_DGRAM', 2);
define ('SOCK_RAW', 3);
define ('SOCK_SEQPACKET', 5);
define ('SOCK_RDM', 4);
define ('MSG_OOB', 1);
define ('MSG_WAITALL', 256);
define ('MSG_CTRUNC', 8);
define ('MSG_TRUNC', 32);
define ('MSG_PEEK', 2);
define ('MSG_DONTROUTE', 4);

/**
 * Не доступно на платформах Windows.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('MSG_EOR', 128);

/**
 * Не доступно на платформах Windows.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('MSG_EOF', 512);
define ('MSG_CONFIRM', 2048);
define ('MSG_ERRQUEUE', 8192);
define ('MSG_NOSIGNAL', 16384);
define ('MSG_DONTWAIT', 64);
define ('MSG_MORE', 32768);
define ('MSG_WAITFORONE', 65536);
define ('MSG_CMSG_CLOEXEC', 1073741824);
define ('SO_DEBUG', 1);
define ('SO_REUSEADDR', 2);

/**
 * Эта константа доступна только в PHP 5.4.10 или более поздних версиях на платформах, которые поддерживают опцию сокета `SO_REUSEPORT`: это включает Mac OS X и FreeBSD, но не включает Linux или Windows.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SO_REUSEPORT', 15);
define ('SO_KEEPALIVE', 9);
define ('SO_DONTROUTE', 5);
define ('SO_LINGER', 13);
define ('SO_BROADCAST', 6);
define ('SO_OOBINLINE', 10);
define ('SO_SNDBUF', 7);
define ('SO_RCVBUF', 8);
define ('SO_SNDLOWAT', 19);
define ('SO_RCVLOWAT', 18);
define ('SO_SNDTIMEO', 21);
define ('SO_RCVTIMEO', 20);
define ('SO_TYPE', 3);
define ('SO_ERROR', 4);
define ('SO_BINDTODEVICE', 25);
define ('SOL_SOCKET', 1);
define ('SOMAXCONN', 128);

/**
 * Используется для禁用 алгоритма Nagle TCP.
 * Добавлен в PHP 5.2.7.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('TCP_NODELAY', 1);
define ('PHP_NORMAL_READ', 1);
define ('PHP_BINARY_READ', 2);
define ('MCAST_JOIN_GROUP', 42);
define ('MCAST_LEAVE_GROUP', 45);
define ('MCAST_BLOCK_SOURCE', 43);
define ('MCAST_UNBLOCK_SOURCE', 44);
define ('MCAST_JOIN_SOURCE_GROUP', 46);
define ('MCAST_LEAVE_SOURCE_GROUP', 47);
define ('IP_MULTICAST_IF', 32);
define ('IP_MULTICAST_TTL', 33);
define ('IP_MULTICAST_LOOP', 34);
define ('IPV6_MULTICAST_IF', 17);
define ('IPV6_MULTICAST_HOPS', 18);
define ('IPV6_MULTICAST_LOOP', 19);
define ('IPV6_V6ONLY', 27);

/**
 * Операция не разрешена.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPERM', 1);

/**
 * Нет такого файла или директории.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOENT', 2);

/**
 * Interrupted system call.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EINTR', 4);

/**
 * I/O error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EIO', 5);

/**
 * Нет такого устройства или адреса.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENXIO', 6);

/**
 * Arg list too long.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_E2BIG', 7);

/**
 * Bad file number.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADF', 9);

/**
 * Попытка снова.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EAGAIN', 11);

/**
 * Out of memory.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOMEM', 12);

/**
 * Permission denied.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EACCES', 13);

/**
 * Bad address.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EFAULT', 14);

/**
 * Block device required.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTBLK', 15);

/**
 * Device or resource busy.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBUSY', 16);

/**
 * File exists.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EEXIST', 17);

/**
 * Cross-device link.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EXDEV', 18);

/**
 * No such device.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENODEV', 19);

/**
 * Not a directory.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTDIR', 20);

/**
 * Is a directory.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EISDIR', 21);

/**
 * Invalid argument.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EINVAL', 22);

/**
 * File table overflow.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENFILE', 23);

/**
 * Too many open files.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EMFILE', 24);

/**
 * Not a typewriter.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTTY', 25);

/**
 * No space left on device.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOSPC', 28);

/**
 * Illegal seek.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ESPIPE', 29);

/**
 * Read-only file system.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EROFS', 30);

/**
 * Too many links.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EMLINK', 31);

/**
 * Broken pipe.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPIPE', 32);

/**
 * File name too long.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENAMETOOLONG', 36);

/**
 * No record locks available.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOLCK', 37);

/**
 * Function not implemented.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOSYS', 38);

/**
 * Directory not empty.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOTEMPTY', 39);

/**
 * Too many symbolic links encountered.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ELOOP', 40);

/**
 * Operation would block.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EWOULDBLOCK', 11);

/**
 * No message of desired type.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOMSG', 42);

/**
 * Identifier removed.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EIDRM', 43);

/**
 * Channel number out of range.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ECHRNG', 44);

/**
 * Level 2 not synchronized.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EL2NSYNC', 45);

/**
 * Level 3 halted.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EL3HLT', 46);

/**
 * Level 3 reset.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EL3RST', 47);

/**
 * Link number out of range.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ELNRNG', 48);

/**
 * Protocol driver not attached.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EUNATCH', 49);

/**
 * No CSI structure available.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOCSI', 50);

/**
 * Level 2 halted.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EL2HLT', 51);

/**
 * Invalid exchange.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADE', 52);

/**
 * Invalid request descriptor.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADR', 53);

/**
 * Exchange full.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EXFULL', 54);

/**
 * No anode.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOANO', 55);

/**
 * Invalid request code.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADRQC', 56);

/**
 * Invalid slot.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EBADSLT', 57);

/**
 * Device not a stream.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOSTR', 60);

/**
 * No data available.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENODATA', 61);

/**
 * Timer expired.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ETIME', 62);

/**
 * Out of streams resources.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOSR', 63);

/**
 * Machine is not on the network.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENONET', 64);

/**
 * Object is remote.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EREMOTE', 66);

/**
 * Link has been severed.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ENOLINK', 67);

/**
 * Advertise error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EADV', 68);

/**
 * Srmount error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ESRMNT', 69);

/**
 * Communication error on send.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_ECOMM', 70);

/**
 * Protocol error.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EPROTO', 71);

/**
 * Multihop attempted.
 * @link http://php.net/manual/en/sockets.constants.php
 */
define ('SOCKET_EMULTIHOP', 72);

/**
 * Not a data message.
 * @link http://php.net/manual/en/sockets.constants.php
