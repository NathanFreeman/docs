# 无锁计数器 Atomic между процессами/потоками

`Atomic` - это класс операций атомических счетов, предоставляемый на уровне `Swoole`, который позволяет легко выполнять беззастенчивые атомные операции с целыми числами.

* Используется общий память, что позволяет operated счетами между разными процессами
* Опирается на атомные инструкции CPU, предоставляемые `gcc/clang`, и не требует блокировки
* Чтобы использовать в серверных программах, необходимо создать его до начала работы `Server->start`, чтобы его можно было использовать в `Worker` процессах
* По умолчанию использует `32`-битное беззignерное целое, если требуется `64`-битное значительное целое, можно использовать `Swoole\Atomic\Long`
* В многопутевых моделях необходимо использовать `Swoole\Thread\Atomic` и `Swoole\Thread\Atomic\Long`, кроме различия в命名空间ах, их интерфейсы полностью идентичны `Swoole\Atomic` и `Swoole\Atomic\Long`.

!> Не создавайте счетчик в таких обратных вызовах, как [onReceive](/server/events?id=onreceive), иначе память будет продолжать расти и привести к утечке памяти.

!> Поддерживается атомный счетчик для `64`-битных значительных длинных целых чисел, для создания следует использовать `new Swoole\Atomic\Long`. `Atomic\Long` не поддерживает методы `wait` и `wakeup`.


## Полный пример

```php
$atomic = new Swoole\Atomic();

$serv = new Swoole\Server('127.0.0.1', '9501');
$serv->set([
    'worker_num' => 1,
    'log_file' => '/dev/null'
]);
$serv->on("start", function ($serv) use ($atomic) {
    if ($atomic->add() == 2) {
        $serv->shutdown();
    }
});
$serv->on("ManagerStart", function ($serv) use ($atomic) {
    if ($atomic->add() == 2) {
        $serv->shutdown();
    }
});
$serv->on("ManagerStop", function ($serv) {
    echo "shutdown\n";
});
$serv->on("Receive", function () {
    
});
$serv->start();
```


## Методы


### __construct()

Конструктор. Создание объекта атомного счетчика.

```php
Swoole\Atomic::__construct(int $init_value = 0);
```

  * **Переданные параметры** 

    * **`int $init_value`**
      * **Функция** : Указывает начальное значение
      * **По умолчанию** : `0`
      * **Другие значения** : Нет


!> -`Atomic` может работать только с `32`-битными беззignерными целыми числами, максимальное значение в `4.2 миллиарда`, не поддерживается отрицательное число;  

- Для использования атомного счетчика в `Server` его необходимо создать до начала работы `Server->start`;  
- Для использования атомного счетчика в [Process](/process/process) его необходимо создать до начала работы `Process->start`.


### add()

Увеличить счет.

```php
Swoole\Atomic->add(int $add_value = 1): int
```

  * **Переданные параметры** 

    * **`int $add_value`**
      * **Функция** : Значение, которое следует добавить【должно быть положительным целым числом】
      * **По умолчанию** : `1`
      * **Другие значения** : Нет

  * **Вычислительный результат**

    * Возвращается результат операции add

!> Если текущее значение добавлено к исходному превышает `4.2 миллиарда`, произойдет переполнение, и высшие bits будут потеряны.


### sub()

Уменьшить счет.

```php
Swoole\Atomic->sub(int $sub_value = 1): int
```

  * **Переданные параметры** 

    * **`int $sub_value`**
      * **Функция** : Значение, которое следует уменьшить【должно быть положительным целым числом】
      * **По умолчанию** : `1`
      * **Другие значения** : Нет

  * **Вычислительный результат**

    * Возвращается результат операции sub

!> Если текущее значение уменьшено до Below 0 произойдет переполнение, и высшие bits будут потеряны.


### get()

Получить текущее значение счетчика.

```php
Swoole\Atomic->get(): int
```

  * **Вычислительный результат**

    * Возвращается текущее значение


### set()

Установить текущее значение указанного числа.

```php
Swoole\Atomic->set(int $value): void
```

  * **Переданные параметры** 

    * **`int $value`**
      * **Функция** : Указать целевое значение, которое следует установить
      * **По умолчанию** : Нет
      * **Другие значения** : Нет


### cmpset()

Если текущее значение равно аргументу `1`, то текущее значение будет установлено на значение аргумента `2`.   

```php
Swoole\Atomic->cmpset(int $cmp_value, int $set_value): bool
```

  * **Переданные параметры** 

    * **`int $cmp_value`**
      * **Функция** : Если текущее значение равно `$cmp_value`, возвращает `true`, и устанавливает текущее значение на `$set_value`, если не равно - возвращает `false`【должен быть меньшим, чем `4.2 миллиарда`, целым числом】
      * **По умолчанию** : Нет
      * **Другие значения** : Нет

    * **`int $set_value`**
      * **Функция** : Если текущее значение равно `$cmp_value`, возвращает `true`, и устанавливает текущее значение на `$set_value`, если не равно - возвращает `false`【должен быть меньшим, чем `4.2 миллиарда`, целым числом】
      * **По умолчанию** : Нет
      * **Другие значения** : Нет


### wait()

Установить в состояние ожидания.

!> Когда значение атомического счетчика равно `0`, процедура входит в состояние ожидания. Другой процесс может разбудить процедуру с помощью вызова `wakeup`. На уровне реализации используется `Linux Futex`, с использованием этой функции можно реализовать функции ожидания, оповещения и блокировки с только `4` Байтами памяти. На платформах, где не поддерживается `Futex`, на уровне реализации будет использоваться циклический `usleep(1000)` для имитации реализации.

```php
Swoole\Atomic->wait(float $timeout = 1.0): bool
```

  * **Переданные параметры** 

    * **`float $timeout`**
      * **Функция** : Указать время ожидания【 при установке `-1` означает бесконечное ожидание, будет продолжаться до тех пор, пока другой процесс не разбудит】
      * **Единица измерения** : секунда【поддерживается плавающая точка, например, `1.5` означает `1 секунда`+`500 мс`】
      * **По умолчанию** : `1`
      * **Другие значения** : Нет

  * **Вычислительный результат** 

    * Возвращает `false` при истечении времени ожидания, ошибочный код будет `EAGAIN`, который можно получить с помощью функции `swoole_errno`
    * Возвращает `true`, если успешно разбудили текущую блокировку другой процессом с помощью вызова `wakeup`

  * **Окружение для корoutine**

  `wait` блокирует весь процесс, а не корoutine, поэтому не используйте `Atomic->wait()` в контексте корoutine, чтобы избежать зависания процесса.


!> - При использовании функции `wait/wakeup` значение атомического счетчика может быть только `0` или `1`, в противном случае это приведет к неправильной работе;  
- Конечно, когда значение атомического счетчика равно `1`, это означает, что нет процесса в состоянии ожидания, функция `wait` немедленно вернет `true`.

  * **Пример использования**

    ```php
    $n = new Swoole\Atomic;
    if (pcntl_fork() > 0) {
        echo "master start\n";
        $n->wait(1.5);
        echo "master end\n";
    } else {
        echo "child start\n";
        sleep(1);
        $n->wakeup();
        echo "child end\n";
    }
    ```

### wakeup()

Разбудить другие процессы, находящиеся в состоянии ожидания.

```php
Swoole\Atomic->wakeup(int $n = 1): bool
```

  * **Переданные параметры** 

    * **`int $n`**
      * **Функция** : Количество процессов, которые следует разбудить
      * **По умолчанию** : Нет
      * **Другие значения** : Нет

* Если текущее значение атомического счетчика равно `0`, это означает, что нет процессов, ожидающих в состоянии ожидания, функция `wakeup` немедленно вернет `true`;
* Если текущее значение атомического счетчика равно `1`, это означает, что сейчас есть процесс, ожидающий в состоянии ожидания, функция `wakeup` разбудит ожидающий процесс и вернет `true`;
* После возврата процесса, который был разбужен, атомический счетчик будет установлен на `0`, что позволяет снова вызвать `wakeup` для разбуждения других ожидающих в состоянии ожидания процессов.
