# Таймер Timer

Таймер с точностью до миллисекунд. На основе реализации `epoll_wait` и `setitimer`, использует структуру данных `минимальный хеш-куча`, что позволяет поддерживать добавление большого количества таймеров.

* Используется `setitimer` и сигналы в синхронных IO процессах, таких как `Manager` и `TaskWorker` процессы
* Используется `epoll_wait`/`kevent`/`poll`/`select` с временем ожидания в асинхронных IO процессах


## Performans

На основе структуры данных минимального хеш-куча реализован таймер, добавление и удаление таймеров полностью осуществляются в памяти, поэтому производительность очень высока.

> В официальном тесте производительности [timer.php](https://github.com/swoole/benchmark/blob/master/timer.php) время добавления или удаления `100 тысяч` случайных таймеров составляет около `0.08 секунды`.

```shell
~/workspace/swoole/benchmark$ php timer.php
add 100000 timer :0.091133117675781s
del 100000 timer :0.084658145904541s
```

!> Таймеры являются операциями в памяти, без `IO` потребления


## Разница

`Timer` отличается от встроенного в `PHP` `pcntl_alarm`. `pcntl_alarm` основан на `сигнале времени + функции tick` и имеет некоторые недостатки:

  * Поддерживается только до секунды, в то время как `Timer` может работать до миллисекундного уровня
  * Не поддерживает одновременное установка нескольких таймеров
  * `pcntl_alarm` зависит от `declare(ticks = 1)`, что приводит к плохой производительности


## Таймер с нулевой毫secONDS

Внутренняя реализация не поддерживает таймеры с временем в `0` миллисекунд. Это отличается от языков программирования, таких как `Node.js`. В `Swoole` можно использовать [Swoole\Event::defer](/event?id=defer) для реализации подобной функции.

```php
Swoole\Event::defer(function () {
  echo "hello\n";
});
```

!> Вышеупомянутое код имеет точно такой же эффект, как и `setTimeout(func, 0)` в `JS`.


## алиасы

`tick()`, `after()`, `clear()` имеют функции-алиасы


Класс静态方法 | Функция-алиас
---|---
`Swoole\Timer::tick()` | `swoole_timer_tick()`
`Swoole\Timer::after()` | `swoole_timer_after()`
`Swoole\Timer::clear()` | `swoole_timer_clear()`


## Методы


### tick()

Установка таймера с интервалом по часам.

В отличие от таймера `after`, таймер `tick` будет постоянно активен до тех пор, пока не будет вызван [Timer::clear](/timer?id=clear) для его очистки.

```php
Swoole\Timer::tick(int $msec, callable $callback_function, ...$params): int
```

!> 1. Таймер работает только в рамках текущего процесса  
   2. Таймер полностью асинхронный, его нельзя использовать вместе с функциями [синхронного IO](/learn?id=同步io异步io), иначе время выполнения таймера может быть искажено  
   3. В процессе выполнения таймера может возникнуть определенное отклонение

  * **Параметры** 

    * **`int $msec`**
      * **Функция**: Указывает время
      * **Единица измерения**: миллисекунда【например, `1000` означает `1` секунду, в версиях ниже `v4.2.10` максимальное значение не должно превышать `86400000`】
      * **Значение по умолчанию**: нет
      * **Другие значения**: нет

    * **`callable $callback_function`**
      * **Функция**: Функция, которая будет вызвана после истечения времени, должна быть выполнимой
      * **Значение по умолчанию**: нет
      * **Другие значения**: нет

    * **`...$params`**
      * **Функция**: Передача данных в функцию выполнения【это также необязательный параметр】
      * **Значение по умолчанию**: нет
      * **Другие значения**: нет
      
      !> Можно использовать `use` синтаксис анонимной функции для передачи параметров в функцию обратного вызова

  * **Функция обратного вызова $callback_function** 

    ```php
    callbackFunction(int $timer_id, ...$params);
    ```

      * **`int $timer_id`**
        * **Функция**: ID таймера【можно использовать для очистки таймера с помощью [Timer::clear](/timer?id=clear)】
        * **Значение по умолчанию**: нет
        * **Другие значения**: нет

      * **`...$params`**
        * **Функция**: Третий параметр `$param`, переданный `Timer::tick`
        * **Значение по умолчанию**: нет
        * **Другие значения**: нет

  * **Расширения**

    * **Корректировка таймера**

      Время выполнения функции обратного вызова таймера не влияет на время следующего выполнения таймера. Пример: таймер `tick` с интервалом `10ms` установлен в `0.002s`, первый раз он будет вызван в `0.012s`, если функция обратного вызова выполняется `5ms`, следующий таймер все равно будет активирован в `0.022s`, а не `0.027s`.
      
      Но если время выполнения функции обратного вызова таймера слишком долгое, оно может даже перекрыть время следующего выполнения таймера. В底层 будет проведена корректировка времени, отброшенные действия будут удалены, и обратный вызов будет произведен в следующем времени. В вышеупомянутом примере, если функция обратного вызова в `0.012s` выполняется в течение `15ms`, то следующий таймер должен быть активирован в `0.022s`. На самом деле таймер вернется только в `0.027s`, когда таймер уже истек. В底层 таймер будет снова активирован в `0.032s`.
    
    * **Режим корoutine**

      В контексте корoutine回调 `Timer::tick` автоматически создает корoutine, можно напрямую использовать корoutine-с相关的`API`, не нужно вызывать `go` для создания корoutine.
      
      !> Можно настроить [enable_coroutine](/timer?id=close-timer-co) выключить автоматическое создание корoutine

  * **Пример использования**

    ```php
    Swoole\Timer::tick(1000, function(){
        echo "timeout\n";
    });
    ```

    * **Правильный пример**

    ```php
    Swoole\Timer::tick(3000, function (int $timer_id, $param1, $param2) {
        echo "timer_id #$timer_id, after 3000ms.\n";
        echo "param1 is $param1, param2 is $param2.\n";

        Swoole\Timer::tick(14000, function ($timer_id) {
            echo "timer_id #$timer_id, after 14000ms.\n";
        });
    }, "A", "B");
    ```

    * **Ошибочный пример**

    ```php
    Swoole\Timer::tick(3000, function () {
        echo "after 3000ms.\n";
        sleep(14);
        echo "after 14000ms.\n";
    });
    ```


### after()

Выполнение функции после указанного времени. Функция `Swoole\Timer::after` является одноразовым таймером, который будет уничтожен после выполнения.

Эта функция отличается от стандартной в `PHP` функции `sleep`, так как `after` является неблокирующим. В то время как `sleep` заставляет текущий процесс войти в блокировку и не позволяет обрабатывать новые запросы.

```php
Swoole\Timer::after(int $msec, callable $callback_function, ...$params): int
```

  * **Параметры** 

    * **`int $msec`**
      * **Функция**: Указывает время
      * **Единица измерения**: миллисекунда【например, `1000` означает `1` секунду, в версиях ниже `v4.2.10` максимальное значение не должно превышать `86400000`】
      * **Значение по умолчанию**: нет
      * **Другие значения**: нет

    * **`callable $callback_function`**
      * **Функция**: Функция, которая будет вызвана после истечения времени, должна быть выполнимой.
      * **Значение по умолчанию**: нет
      * **Другие значения**: нет

    * **`...$params`**
      * **Функция**: Передача данных в функцию выполнения【это также необязательный параметр】
      * **Значение по умолчанию**: нет
      * **Другие значения**: нет
      
      !> Можно использовать `use` синтаксис анонимной функции для передачи параметров в функцию обратного вызова

  * **Возвращаемое значение**

    * Если выполнение успешно, возвращается ID таймера, если таймер отменяется, можно вызвать [Swoole\Timer::clear](/timer?id=clear)

  * **Расширения**

    * **Режим корoutine**

      В контексте корoutine回调 `Swoole\Timer::after](/timer?id=after)` автоматически создает корoutine, можно напрямую использовать корoutine-с相关的`API`, не нужно вызывать `go` для создания корoutine.
      
      !> Можно настроить [enable_coroutine](/timer?id=close-timer-co) выключить автоматическое создание корoutine

  * **Пример использования**

```php
$str = "Swoole";
Swoole\Timer::after(1000, function() use ($str) {
    echo "Hello, $str\n";
});
```
### clear()

Используйте идентификатор таймера `ID` для удаления таймера.

```php
Swoole\Timer::clear(int $timer_id): bool
```

  * **Параметры** 

    * **`int $timer_id`**
      * **Функция**: идентификатор таймера 【вызов [Timer::tick](/timer?id=tick)、[Timer::after](/timer?id=after) вернет целое число ID】
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

!> `Swoole\Timer::clear` не может использоваться для очистки таймеров других процессов, действует только на текущем процессе

  * **Пример использования**

```php
$timer = Swoole\Timer::after(1000, function () {
    echo "timeout\n";
});

var_dump(Swoole\Timer::clear($timer));
var_dump($timer);

// Вывод: bool(true) int(1)
// Не вывод: timeout
```


### clearAll()

Очистите все таймеры в текущем рабочем процессе Worker.

!> Доступно с версии Swoole `v4.4.0`

```php
Swoole\Timer::clearAll(): bool
```


### info()

Верните информацию о `timer`.

!> Доступно с версии Swoole `v4.4.0`

```php
Swoole\Timer::info(int $timer_id): array
```

  * **Возвращаемое значение**

```php
array(5) {
  ["exec_msec"]=>
  int(6000)
  ["exec_count"]=> // v4.8.0 добавлено
  int(5)
  ["interval"]=>
  int(1000)
  ["round"]=>
  int(0)
  ["removed"]=>
  bool(false)
}
```


### list()

Верните итератор таймеров, который позволяет использовать `foreach` для обхода всех `timer` ID в текущем рабочем процессе Worker

!> Доступно с версии Swoole `v4.4.0`

```php
Swoole\Timer::list(): Swoole\Timer\Iterator
```

  * **Пример использования**

```php
foreach (Swoole\Timer::list() as $timer_id) {
    var_dump(Swoole\Timer::info($timer_id));
}
```


### stats()

Посмотрите на состояние таймеров.

!> Доступно с версии Swoole `v4.4.0`

```php
Swoole\Timer::stats(): array
```

  * **Возвращаемое значение**

```php
array(3) {
  ["initialized"]=>
  bool(true)
  ["num"]=>
  int(1000)
  ["round"]=>
  int(1)
}
```


### set()

Установите параметры таймера.

```php
Swoole\Timer::set(array $array): void
```

!> Эта функция была отмечена как устаревшая с версии `v4.6.0`.

## Отключение координационных функций :id=close-timer-co

По умолчанию таймеры автоматически создают координационные функции при выполнении обратной связи, но можно отдельно настроить таймеры для отключения координационных функций.

```php
swoole_async_set([
  'enable_coroutine' => false,
]);
```
