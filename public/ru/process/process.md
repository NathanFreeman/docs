# Swoole\Process

Модуль управления процессами, предоставляемый Swoole, который заменяет `pcntl` PHP.

!> Этот модуль довольно низкоуровневый, это обер包装ер управления процессами операционной системы, и пользователям требуется опыт программирования многопроцессных приложений в Linux.

Встроенный в `PHP` `pcntl` имеет много недостатков, таких как:

* Не предоставляет функции межпроцессного общения
* Не поддерживает перенаправление стандартного ввода и вывода
* Предоставляет только такой примитивный интерфейс, как `fork`, что легко привести к ошибкам в использовании

`Process` предоставляет более мощные функции и более удобную `API`, что упрощает многопроцессное программирование в PHP.

`Process` предлагает следующие возможности:

* Удобно реализовать межпроцессное общение
* Поддерживает перенаправление стандартного ввода и вывода, в дочерних процессах `echo` не будет печататься на экране, а будет写入 в трубу, чтение клавиатурного ввода можно перенаправить для чтения данных из трубы
* Предоставляется [exec](/process/process?id=exec) интерфейс, создаваемый процесс может выполнять другие программы, и между ним и исходным `PHP` родительским процессом можно легко общаться
* В контексте координационных функций использовать модуль `Process` невозможно, можно использовать `runtime hook` + `proc_open` для реализации, см. [координационное управление процессами](/coroutine/proc_open)


### Примеры использования

  * Создание трех дочерних процессов, родительский процесс использует `wait` для восстановления процессов
  * Когда родительский процесс внезапно завершается, дочерние процессы продолжат работу и покончат все задания перед завершением

```php
use Swoole\Process;

for ($n = 1; $n <= 3; $n++) {
    $process = new Process(function () use ($n) {
        echo 'Ребенок #' . getmypid() . " начинается и спит {$n} секунды" . PHP_EOL;
        sleep($n);
        echo 'Ребенок #' . getmypid() . ' завершается' . PHP_EOL;
    });
    $process->start();
}
for ($n = 3; $n--;) {
    $status = Process::wait(true);
    echo "Восстановлен #{$status['pid']}, код={$status['code']}, сигнал={$status['signal']}" . PHP_EOL;
}
echo 'Родитель #' . getmypid() . ' завершается' . PHP_EOL;
```


## Свойства


### pipe

Файловый дескриптор [unixSocket](/learn?id=что такое IPC).

```php
public int $pipe;
```


### msgQueueId

`id` сообщения队列.

```php
public int $msgQueueId;
```


### msgQueueKey

`key` сообщения队列.

```php
public string $msgQueueKey;
```


### pid

`pid` текущего процесса.

```php
public int $pid;
```


### id

`id` текущего процесса.

```php
public int $id;
```


## Константы

Параметр | Функция
---|---
Swoole\Process::IPC_NOWAIT | Когда в очереди сообщений нет данных, сразу же возвращается
Swoole\Process::PIPE_READ | Закрывает чтение с сокета
Swoole\Process::PIPE_WRITE | Закрывает запись в сокет


## Методы


### __construct()

Конструктор.

```php
Swoole\Process->__construct(callable $function, bool $redirect_stdin_stdout = false, int $pipe_type = SOCK_DGRAM, bool $enable_coroutine = false)
```

* **Параметры** 

  * **`callable $function`**
    * **Функция**: Функция, которую следует выполнить в дочернем процессе после его создания【внутренне функция автоматически сохраняется в private свойстве объекта `callback】, обратите внимание, что это свойство является private.】
    * **По умолчанию**: Нет
    * **Другие значения**: Нет

  * **`bool $redirect_stdin_stdout`**
    * **Функция**: Перенаправляет стандартный ввод и стандартный вывод дочернего процесса.【Если этот параметр включен, содержание, которое вы печатаете внутри дочернего процесса, не будет отображаться на экране, а будет写入 в трубу родительского процесса. Чтение клавиатурного ввода изменится на чтение данных из трубы. По умолчанию - блокирующее чтение. См. метод [exec()](/process/process?id=exec)】
    * **По умолчанию**: Нет
    * **Другие значения**: Нет

  * **`int $pipe_type`**
    * **Функция**: Тип [unixSocket](/learn?id=что такое IPC)【Если `$redirect_stdin_stdout` включен, этот параметр будет игнорировать пользовательские параметры и принудительно установить `SOCK_STREAM`. Если внутри дочернего процесса нет межпроцессного общения, его можно установить как `0`】
    * **По умолчанию**: `SOCK_DGRAM`
    * **Другие значения**: `0`, `SOCK_STREAM`

  * **`bool $enable_coroutine`**
    * **Функция**: Активировать координационные функции в `callback function`, после включения можно напрямую использовать API координации в функции дочернего процесса
    * **По умолчанию**: `false`
    * **Другие значения**: `true`
    * **Влияние версии**: Swoole >= v4.3.0

* **Тип [unixSocket](/learn?id=что такое IPC)**


Тип unixSocket | Описание
---|---
0 | Не создается
1 | Создается [SOCK_STREAM](/learn?id=что такое IPC) типа unixSocket
2 | Создается [SOCK_DGRAM](/learn?id=что такое IPC) типа unixSocket



### useQueue()

Использовать очередь сообщений для межпроцессного общения.

```php
Swoole\Process->useQueue(int $key = 0, int $mode = SWOOLE_MSGQUEUE_BALANCE, int $capacity = -1): bool
```

* **Параметры** 

  * **`int $key`**
    * **Функция**: Ключ очереди сообщений, если传入 значение меньше или равно 0, нижестоящий уровень будет использовать функцию `ftok`, с именем текущей исполнительной программы в качестве параметра, чтобы создать соответствующий ключ.
    * **По умолчанию**: `0`
    * **Другие значения**: Нет

  * **`int $mode`**
    * **Функция**: режим межпроцессного общения,
    * **По умолчанию**: `SWOOLE_MSGQUEUE_BALANCE`, `Swoole\Process::pop()` вернет первое сообщение в очереди, `Swoole\Process::push()` не добавит определенный тип сообщения.
    * **Другие значения**: `SWOOLE_MSGQUEUE_ORIENT`, `Swoole\Process::pop()` вернет первое сообщение в очереди с типом `pid + 1`, `Swoole\Process::push()` добавит тип `pid + 1` к сообщению.

  * **`int $capacity`**
    * **Функция**: Максимальная количество сообщений, разрешенных для хранения в очереди сообщений.
    * **По умолчанию**: `-1`
    * **Другие значения**: Нет

* **Примечание**

  * Когда в очереди сообщений нет данных, `Swoole\Porcess->pop()` будет блокироваться вечно, или когда очереди сообщений не хватает места для новых данных, `Swoole\Porcess->push()` также будет блокироваться вечно. Если вы не хотите блокироваться, значение `$mode` должно быть `SWOOLE_MSGQUEUE_BALANCE|Swoole\Process::IPC_NOWAIT` или `SWOOLE_MSGQUEUE_ORIENT|Swoole\Process::IPC_NOWAIT`.


### statQueue()

Получить состояние очереди сообщений

```php
Swoole\Process->statQueue(): array|false
```

* **Возвращаемое значение** 

  * Возвращает массив в случае успеха, массив содержит две пары ключ-значение, `queue_num` обозначает общее количество сообщений в очереди, `queue_bytes` обозначает общее количество字节 сообщений в очереди.
  * В случае неудачи возвращает `false`.


### freeQueue()

Уничтожить очередь сообщений.

```php
Swoole\Process->freeQueue(): bool
```

* **Возвращаемое значение** 

  * Успешное возвращение `true`.
  * Неудача возвращает `false`.


### pop()

Получить данные из очереди сообщений.

```php
Swoole\Process->pop(int $size = 65536): string|false
```

* **Параметры** 

  * **`int $size`**
    * **Функция**: Размер данных, которые следует получить.
    * **По умолчанию**: `65536`
    * **Другие значения**: Нет


* **Возвращаемое значение** 

  * Возвращает `string` в случае успеха.
  * Неудача возвращает `false`.

* **Примечание**

  * Когда тип очереди сообщений является `SW_MSGQUEUE_BALANCE`, возвращается первое сообщение в очереди.
  * Когда тип очереди сообщений является `SW_MSGQUEUE_ORIENT`, возвращается первое сообщение в очереди с типом `pid + 1`.
### push()

Отправка данных в очередь сообщений.

```php
Swoole\Process->push(string $data): bool
```

* **Параметры**

  * **`string $data`**
    * **Функция**: Отправляемые данные.
    * **По умолчанию**: ``
    * **Другие значения**: `нет`


* **Возвращаемое значение**

  * Успешное возвращение `true`.
  * Неудача возвращает `false`.


* **Примечание**

  * Когда тип очереди сообщений равен `SW_MSGQUEUE_BALANCE`, данные будут вставлены непосредственно в очередь сообщений.
  * Когда тип очереди сообщений равен `SW_MSGQUEUE_ORIENT`, данные будут наделены типом, который равен текущему `PID + 1`.


### setTimeout()

Установка времени ожидания чтения и письма в очереди сообщений.

```php
Swoole\Process->setTimeout(float $seconds): bool
```

* **Параметры**

  * **`float $seconds`**
    * **Функция**: Время ожидания
    * **По умолчанию**: `нет`
    * **Другие значения**: `нет`


* **Возвращаемое значение**

  * Успешное возвращение `true`.
  * Неудача возвращает `false`.


### setBlocking()

Установка того, является ли сокет очереди сообщений блокирующим.

```php
Swoole\Process->setBlocking(bool $$blocking): void
```

* **Параметры**

  * **`bool $blocking`**
    * **Функция**: Блокировать или нет, `true` означает блокировку, `false` означает неблокировку
    * **По умолчанию**: `нет`
    * **Другие значения**: `нет`


* **Примечание**

  * Сokiеты новых процессов по умолчанию блокируются, поэтому при использовании коммуникации через Unix-доменные сокеты отправка или чтение сообщений может заблокировать процесс.


### write()

Письмо от отца к сыну процесса (Unix-доменный сокет).

```php
Swoole\Process->write(string $data): false|int
```

* **Параметры**

  * **`string $data`**
    * **Функция**: Данные для отправки
    * **По умолчанию**: `нет`
    * **Другие значения**: `нет`


* **Возвращаемое значение**

  * Успешное возвращение `int`, представляющее количество字节 успешно отправленных.
  * Неудача возвращает `false`.


### read()

Чтение сообщений от отца к сыну процесса (Unix-доменный сокет).

```php
Swoole\Process->read(int $size = 8192): false|string
```

* **Параметры**

  * **`int $size`**
    * **Функция**: Размер данных для чтения
    * **По умолчанию**: `8192`
    * **Другие значения**: `нет`


* **Возвращаемое значение**

  * Успешное возвращение `string`.
  * Неудача возвращает `false`.


### set()

Установка параметров.

```php
Swoole\Process->set(array $settings): void
```

Используйте `enable_coroutine`, чтобы контролировать, включена ли协程, что согласуется с четвертым параметром конструктора.

```php
Swoole\Process->set(['enable_coroutine' => true]);
```

!> Версия Swoole >= v4.4.4 доступна


### start()

Выполнение системного вызова `fork`, запуск anakлона. Создание процесса на `Linux` системе требует нескольких сотен микросекунд.

```php
Swoole\Process->start(): int|false
```

* **Возвращаемое значение**

  * Успешное возвращение `PID` Anakлаона
  * Неудача возвращает `false`. Используйте [swoole_errno](/functions?id=swoole_errno) и [swoole_strerror](/functions?id=swoole_strerror) для получения коды ошибки и информации об ошибке.


* **Примечание**

  * Anakлон наследует память и файлы отца процесса
  * При запуске Anakлаона будут удалены [EventLoop](/learn?id=что такоеeventloop), [Signal](/process/process?id=signal), [Timer](/timer), переданные от отца процесса
  
  !> После выполнения Anakлон сохраняет память и ресурсы отца процесса, например, если в отец процессе был создан соединение с Redis, то в Anakлоне будет сохраняться этот объект, и все операции будут выполняться на одном и том же соединении. В следующем примере это показано

```php
$redis = new Redis;
$redis->connect('127.0.0.1', 6379);

function callback_function() {
    swoole_timer_after(1000, function () {
        echo "hello world\n";
    });
    global $redis;//одно соединение
};

swoole_timer_tick(1000, function () {
    echo "parent timer\n";
});//не наследуется

Swoole\Process::signal(SIGCHLD, function ($sig) {
    while ($ret = Swoole\Process::wait(false)) {
        // создать новый anakлона
        $p = new Swoole\Process('callback_function');
        $p->start();
    }
});

// создать новый anakлона
$p = new Swoole\Process('callback_function');

$p->start();
```

!> 1. После запуска Anakлаона автоматически удаляются таймеры, созданные с помощью [Swoole\Timer::tick](/timer?id=tick) в отец процессе, сигналы, слушаемые с помощью [Process::signal](/process/process?id=signal), и события, добавленные с помощью [Swoole\Event::add](/event?id=add);  
2. Anakлон наследует объект соединения `$redis`, созданный в отец процессе, и отец и anakлоны используют одно и то же соединение.


### exportSocket()

Экспортировать `unixSocket` в объект `Swoole\Coroutine\Socket`, затем использовать методы объекта `Swoole\Coroutine\socket` для межпроцессной коммуникации. Для подробного руководства смотрите [Coroutine\socket](/coroutine_client/socket) и [IPC коммуникация](/learn?id=что такоеIPC).

```php
Swoole\Process->exportSocket(): Swoole\Coroutine\Socket|false
```

!> Когда этот метод вызывается несколько раз, возвращаемый объект одинаков;  
`exportSocket()` экспортирует новый `fd` сокета, и закрытие экспортированного сокета не влияет на существующие трубы процесса.  
Поскольку это объект `Swoole\Coroutine\Socket`, он должен использоваться в [корутине контейнере](/coroutine/scheduler), поэтому параметр `$enable_coroutine` конструктора `Swoole\Process` должен быть设置为 `true`.  
Тот же отец процесса, желающий использовать объект `Swoole\Coroutine\Socket`, должен вручную вызвать `Coroutine\run()` для создания корутинного контейнера.

* **Возвращаемое значение**

  * Успешное возвращение объекта `Coroutine\Socket`
  * Процесс не создал unixSocket, операция потерпела неудачу, возвращение `false`

* **Пример использования**

Реализовано простое общение между отцом и сыном процессами:  

```php
use Swoole\Process;
use function Swoole\Coroutine\run;

$proc1 = new Process(function (Process $proc) {
    $socket = $proc->exportSocket();
    echo $socket->recv();
    $socket->send("hello master\n");
    echo "proc1 stop\n";
}, false, 1, true);

$proc1->start();

// Отец процесса создает корутинный контейнер
run(function() use ($proc1) {
    $socket = $proc1->exportSocket();
    $socket->send("hello pro1\n");
    var_dump($socket->recv());
});
Process::wait(true);
```

Сложный пример коммуникации:

```php
use Swoole\Process;
use Swoole\Timer;
use function Swoole\Coroutine\run;

$process = new Process(function ($proc) {
    Timer::tick(1000, function () use ($proc) {
        $socket = $proc->exportSocket();
        $socket->send("hello master\n");
        echo "child timer\n";
    });
}, false, 1, true);

$process->start();

run(function() use ($process) {
    Process::signal(SIGCHLD, static function ($sig) {
        while ($ret = Swoole\Process::wait(false)) {
            /* очистка, затем event loop будет завершен */
            Process::signal(SIGCHLD, null);
            Timer::clearAll();
        }
    });
    /* вы можете здесь выполнять другие асинхронные или корутинные операции */
    Timer::tick(500, function () {
        echo "parent timer\n";
    });

    $socket = $process->exportSocket();
    while (1) {
        var_dump($socket->recv());
    }
});
```
!> Обратите внимание, что по умолчанию тип является `SOCK_STREAM`, и необходимо обрабатывать проблемы с границей TCP-пакетов, смотрите метод `setProtocol()` в [Coroutine\socket](/coroutine_client/socket).  

Используйте тип `SOCK_DGRAM` для IPC-коммуникации, чтобы избежать проблем с границей TCP-пакетов, смотрите [IPC коммуникация](/learn?id=что такоеIPC):

```php
use Swoole\Process;
use function Swoole\Coroutine\run;

// IPC коммуникация даже для сокетов типа SOCK_DGRAM не требует использования функций sendto/recvfrom, достаточно send/recv.
$proc1 = new Process(function (Process $proc) {
    $socket = $proc->exportSocket();
    while (1) {
        var_dump($socket->send("hello master\n"));
    }
    echo "proc1 stop\n";
}, false, 2, 1);// в конструкторе传递给 pipe type значение 2, то есть SOCK_DGRAM

$proc1->start();

run(function() use ($proc1) {
    $socket = $proc1->exportSocket();
    Swoole\Coroutine::sleep(5);
    var_dump(strlen($socket->recv()));// при одном recv будет получен только один字符串 "hello master\n", и не будет нескольких "hello master\n"
});

Process::wait(true);
```
### name()

Изменяет имя процесса. Эта функция является синонимом [swoole_set_process_name](/functions?id=swoole_set_process_name).

```php
Swoole\Process->name(string $name): bool
```

!> После выполнения `exec` имя процесса будет переопределено новой программы; метод `name` должен использоваться в обратном вызове дочернего процесса после `start`.


### exec()

Выполняет внешнюю программу, эта функция является обернутым вызовом системного вызова `exec`.

```php
Swoole\Process->exec(string $execfile, array $args);
```

* **Параметры** 

  * **`string $execfile`**
    * **Функция**: Указывает абсолютный путь к исполняемой файлу, например `"/usr/bin/python"`
    * **По умолчанию**: Нет
    * **Другие значения**: Нет

  * **`array $args`**
    * **Функция**: список параметров для `exec`【например, `array('test.py', 123)`, что эквивалентно `python test.py 123`】
    * **По умолчанию**: Нет
    * **Другие значения**: Нет

После успешного выполнения код текущего процесса будет заменен новой программы. Дочерний процесс превращается в другую программу. Отец-процесс и текущий процесс по-прежнему являются родителями и детьми.

Отец-процесс может общаться с новым процессом через стандартный вход и выход, необходимо включить перенаправление стандартного ввода и вывода.

!> `$execfile` должен быть указана абсолютным путем, иначе будет получен ошибочный статус отсутствия файла;  
Поскольку системный вызов `exec` использует указанную программу для замены текущей программы, дочерний процесс должен читать и писать стандартный вывод для общения с отцом-процессом;  
Если не указать `redirect_stdin_stdout = true`, после выполнения `exec` дочерний процесс не сможет общаться с отцом-процессом.

* **Примеры использования**

Пример 1: Можно использовать [Swoole\Server](/server/init) в созданном с помощью `Swoole\Process` дочернем процессе, но для безопасности необходимо вызвать `$worker->exec()` после создания процесса с `$process->start`. Вот пример:

```php
$process = new Swoole\Process('callback_function', true);

$pid = $process->start();

function callback_function(Swoole\Process $worker)
{
    $worker->exec('/usr/local/bin/php', array(__DIR__.'/swoole_server.php'));
}

Swoole\Process::wait();
```

Пример 2: Запустить программу Yii

```php
$process = new \Swoole\Process(function (\Swoole\Process $childProcess) {
    // Не поддерживается такой写法
    // $childProcess->exec('/usr/local/bin/php /var/www/project/yii-best-practice/cli/yii t/index -m=123 abc xyz');

    // Обернуть системный вызов exec
    // Абсолютный путь
    // Параметры должны быть разделены в массиве
    $childProcess->exec('/usr/local/bin/php', ['/var/www/project/yii-best-practice/cli/yii', 't/index', '-m=123', 'abc', 'xyz']); // системный вызов exec
});
$process->start(); // Запустить дочерний процесс
```

Пример 3: Отец-процесс общается со `exec` дочерним процессом через стандартный ввод и выход:

```php
// exec - общаться с процессом exec через трубу
use Swoole\Process;
use function Swoole\Coroutine\run;

$process = new Process(function (Process $worker) {
    $worker->exec('/bin/echo', ['hello']);
}, true, 1, true); // Необходимо включить перенаправление стандартного ввода и вывода

$process->start();

run(function() use($process) {
    $socket = $process->exportSocket();
    echo "от exec: " . $socket->recv() . "\n";
});
```

Пример 4: Выполнить командный shell

Метод `exec` отличается от `shell_exec`, предоставляемой `PHP`, он является более низкоуровневым обернутым вызовом системного вызова. Если необходимо выполнить командный shell, используйте следующий метод:

```php
$worker->exec('/bin/sh', array('-c', "cp -rf /data/test/* /tmp/test/"));
```


### close()

Используется для закрытия созданного [unixSocket](/learn?id=что такоеIPC). 

```php
Swoole\Process->close(int $which): bool
```

* **Параметры** 

  * **`int $which`**
    * **Функция**: Поскольку unixSocket является двусторонним, укажите,关闭 какой конец【по умолчанию `0` означает закрытие чтения и письма одновременно, `1`: закрытие письма, `2` закрытие чтения】
    * **По умолчанию**: `0`, закрытие чтения и письма сокета.
    * **Другие значения**: `Swoole/Process::SW_PIPE_CLOSE_READ` закрывает чтение сокета, `Swoole/Process::SW_PIPE_CLOSE_WRITE` закрывает письмо сокета,

!> В некоторых особых случаях объект `Process` не может быть освобожден, и постоянное создание процессов может привести к утечке соединений. CALLING этой функции позволяет напрямую закрыть `unixSocket`, освободить ресурсы.


### exit()

Выход из дочернего процесса.

```php
Swoole\Process->exit(int $status = 0);
```

* **Параметры** 

  * **`int $status`**
    * **Функция**: Статус выхода процесса【если `0`, то означает нормальный конец, будет продолжаться уборка работы】
    * **По умолчанию**: `0`
    * **Другие значения**: Нет

!> Работа по уборке включает:

  * `PHP` `shutdown_function`
  * Деструктор объекта ( `__destruct` )
  * Другие расширенные функции `RSHUTDOWN`

Если `$status` не равен `0`, это означает необычный выход, процесс будет немедленно завершен, и не будут выполняться уборочные работы, связанные с завершением процесса.

В родительском процессе, выполнение `Process::wait` может вернуть событие и статус выхода дочернего процесса.


### kill()

Отправляет сигнал процессу с указанным `pid`.

```php
Swoole\Process::kill(int $pid, int $signo = SIGTERM): bool
```

* **Параметры** 

  * **`int $pid`**
    * **Функция**: Процесс `pid`
    * **По умолчанию**: Нет
    * **Другие значения**: Нет

  * **`int $signo`**
    * **Функция**: Отправляемый сигнал【`$signo=0`, можно проверить, существует ли процесс, сигнал не будет отправлен】
    * **По умолчанию**: `SIGTERM`
    * **Другие значения**: Нет


### signal()

Установка прослушивания асинхронных сигналов.

```php
Swoole\Process::signal(int $signo, callable $callback): bool
```

Эта метод основан на `signalfd` и [EventLoop](/learn?id=что такоеeventloop) является асинхронным `IO`, его нельзя использовать в блокирующих программах, так как зарегистрированные прослушивающие обратные вызовы не будут распределяться;

Блокирующие программы могут использовать `pcntl` расширение, предоставляемый `pcntl_signal`;

Если был установлен обратный вызов для этого сигнала, установление нового будет перезаписывать исторические настройки.

* **Параметры** 

  * **`int $signo`**
    * **Функция**: Сигнал
    * **По умолчанию**: Нет
    * **Другие значения**: Нет

  * **`callable $callback`**
    * **Функция**: Обратный вызов【если `$callback` равен `null`, это означает удаление прослушивания сигнала】
    * **По умолчанию**: Нет
    * **Другие значения**: Нет

!> В [Swoole\Server](/server/init) нельзя устанавливать прослушивание некоторых сигналов, таких как `SIGTERM` и `SIGALRM`

* **Примеры использования**

```php
Swoole\Process::signal(SIGTERM, function($signo) {
     echo "shutdown.";
});
```

!> В версии `v4.4.0`, если в [EventLoop](/learn?id=что такоеeventloop) процесса есть только события прослушивания сигналов, и нет других событий (например, таймеры и т.д.), процесс будет сразу завершен.

```php
Swoole\Process::signal(SIGTERM, function($signo) {
     echo "shutdown.";
});
Swoole\Event::wait();
```

Вышеупомянутая программа не будет входить в [EventLoop](/learn?id=что такоеeventloop), `Swoole\Event::wait()` сразу вернется и процесс будет завершен.
### ожидание()

Отметить конец работы дочерних процессов.

!> При использовании Swoole версии >= `v4.5.0` рекомендуется использовать координационную версию `wait()`, см. [Swoole\Coroutine\System::wait()](/coroutine/system?id=wait)

```php
Swoole\Process::wait(bool $blocking = true): array|false
```

* **Параметры**

  * **`bool $blocking`**
    * **Функция**: Указывает, должен ли ожидание быть блокирующим 【по умолчанию - блокирующим】
    * **По умолчанию**: `true`
    * **Другие значения**: `false`

* **Возвращаемое значение**

  * В случае успеха возвращается массив, содержащий `PID` дочернего процесса, код выхода и сигнал, который его убил
  * В случае неудачи возвращается `false`

!> Каждый дочерний процесс после завершения должен быть отметен с помощью `wait()` в родительском процессе, иначе дочерний процесс станет зомби и будет тратить ресурсы операционной системы. Если у родительского процесса есть другие задачи, он не может блокироваться в `wait`, родительский процесс должен зарегистрировать сигнал `SIGCHLD` для выполнения `wait` на завершившихся процессах. Когда происходит сигнал `SIGCHILD`, могут завершиться несколько дочерних процессов одновременно; необходимо установить `wait()`为非блокирующим и циклически выполнять `wait`, пока не вернется `false`.

* **Пример**

```php
Swoole\Process::signal(SIGCHLD, function ($sig) {
    // Необходимо设置为 false, в неблокирующем режиме
    while ($ret = Swoole\Process::wait(false)) {
        echo "PID={$ret['pid']}\n";
    }
});
```

### daemon()

Превратить текущий процесс в демона.

```php
Swoole\Process::daemon(bool $nochdir = true, bool $noclose = true): bool
```

* **Параметры**

  * **`bool $nochdir`**
    * **Функция**: Переходить ли текущий каталог в корневой каталог 【если `true`, то не переходить】
    * **По умолчанию**: `true`
    * **Другие значения**: `false`

  * **`bool $noclose`**
    * **Функция**: Закрыть ли стандартные входные/выходные файлы 【если `true`, то не закрывать】
    * **По умолчанию**: `true`
    * **Другие значения**: `false`

!> При превращении в демона `PID` процесса изменится, можно использовать `getmypid()` для получения текущего `PID`

### alarm()

Высокоточные таймер, это обернутый системный вызов `setitimer` операционной системы, который позволяет устанавливать таймеры с микросекундной точностью. Таймер вызывает сигнал, его необходимо использовать в сочетании с [Process::signal](/process/process?id=signal) или `pcntl_signal`.

!> `alarm` не может использоваться вместе с [Timer](/timer)

```php
Swoole\Process->alarm(int $time, int $type = 0): bool
```

* **Параметры**

  * **`int $time`**
    * **Функция**: Интервал таймера 【если отрицательный - означает очистку таймера】
    * **Единица измерения**: микросекунды
    * **По умолчанию**: нет
    * **Другие значения**: нет

  * **`int $type`**
    * **Функция**: Тип таймера
    * **По умолчанию**: `0`
    * **Другие значения**:


Тип таймера | Описание
---|---
0 | Относится к реальному времени, вызывает сигнал `SIGALRM`
1 | Относится к времени пользовательского пространства CPU, вызывает сигнал `SIGVTALRM`
2 | Относится к времени пользовательского и ядра пространства, вызывает сигнал `SIGPROF`

* **Возвращаемое значение**

  * Успешное установление возвращает `true`
  * Неудача возвращает `false`, можно использовать `swoole_errno` для получения ошибки

* **Пример использования**

```php
use Swoole\Process;
use function Swoole\Coroutine\run;

run(function () {
    Process::signal(SIGALRM, function () {
        static $i = 0;
        echo "#{$i}\talarm\n";
        $i++;
        if ($i > 20) {
            Process::alarm(-1);
            Process::kill(getmypid());
        }
    });

    // 100 мс
    Process::alarm(100 * 1000);

    while (true) {
        sleep(0.5);
    }
});
```

### setAffinity()
Установить `CPU` аффинность, можно привязать процесс к определенному ядру `CPU`. Эта функция позволяет запускать процесс только на нескольких определенных ядрах `CPU`, освободив некоторые ресурсы `CPU` для выполнения более важных задач.

```php
Swoole\Process->setAffinity(array $cpus): bool
```

* **Параметры**

  * **`array $cpus`**
    * **Функция**: Привязать ядра `CPU` 【например, `array(0,2,3)` означает привязать к ядрам `CPU0/CPU2/CPU3`】
    * **По умолчанию**: нет
    * **Другие значения**: нет

!> - Элементы `$cpus` не должны превышать количество ядер `CPU`;  

- `ID` ядра `CPU` не должен превышать (количество ядер `CPU` - 1);  

- Эта функция требует поддержки операционной системой привязки к ядрам `CPU`;  
- Используйте [swoole_cpu_num()](/functions?id=swoole_cpu_num) для получения количества ядер `CPU` на текущем сервере.

### getAffinity()
Получить `CPU` аффинность процесса

```php
Swoole\Process->getAffinity(): array
```
Возвращаемое значение - массив, элементы которого представляют количество ядер `CPU`, например: `[0, 1, 3, 4]` означает, что этот процесс будет распределяться для выполнения на ядрах `CPU` `0/1/3/4`.

### setPriority()
Установить приоритет процесса, группы процессов и пользовательского процесса.

!> Доступно с версии Swoole >= `v4.5.9`

```php
Swoole\Process->setPriority(int $which, int $priority): bool
```

* **Параметры**

  * **`int $which`**
    * **Функция**: Определить тип, на который следует изменить приоритет
    * **По умолчанию**: нет
    * **Другие значения**:

| Константа | Описание |
| ------------ | -------- |
| PRIO_PROCESS | Процесс |
| PRIO_PGRP    | Группа процессов |
| PRIO_USER    | Пользовательский процесс |

  * **`int $priority`**
    * **Функция**: Priоритет. Чем меньше значение, тем выше приоритет
    * **По умолчанию**: нет
    * **Другие значения**: `[-20, 20]`

* **Возвращаемое значение**

  * Если возвращается `false`, можно использовать [swoole_errno](/functions?id=swoole_errno) и [swoole_strerror](/functions?id=swoole_strerror) для получения ошибки и информации о ошибке.

### getPriority()
Получить приоритет процесса.

!> Доступно с версии Swoole >= `v4.5.9`

```php
Swoole\Process->getPriority(int $which): int
```
