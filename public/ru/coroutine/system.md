# Корутины\Система

Корутинные обернутые API, связанные с системой. Эта модуль стала доступна после официальной версии `v4.4.6`. Большинство API реализованы на основе пула AIO-тредов.

!> Для версий до `v4.4.6` используйте краткое имя `Co` или `Swoole\Coroutine`, например: `Co::sleep` или `Swoole\Coroutine::sleep`.  
Для версий `v4.4.6` и выше официальным **предпочтительным** использованием является `Co\System::sleep` или `Swoole\Coroutine\System::sleep`.  
Эти изменения направлены на стандартизацию命名spaces, но также обеспечивают обратную совместимость (то есть написание до версии `v4.4.6` также возможно и не требует изменений).


## Методы


### statvfs()

Получение информации о файловой системе.

!> Доступно в версиях Swoole >= v4.2.5

```php
Swoole\Coroutine\System::statvfs(string $path): array|false
```

  * **Параметры** 

    * **`string $path`**
      * **Функция**: Директория, на которой висит файловая система【например `/` , можно получить информацию с помощью команд df и `mount -l`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

  * **Пример использования**

    ```php
    Swoole\Coroutine\run(function () {
        var_dump(Swoole\Coroutine\System::statvfs('/'));
    });
    ```
  * **Пример вывода**
    
    ```php
    array(11) {
      ["bsize"]=>
      int(4096)
      ["frsize"]=>
      int(4096)
      ["blocks"]=>
      int(61068098)
      ["bfree"]=>
      int(45753580)
      ["bavail"]=>
      int(42645728)
      ["files"]=>
      int(15523840)
      ["ffree"]=>
      int(14909927)
      ["favail"]=>
      int(14909927)
      ["fsid"]=>
      int(1002377915335522995)
      ["flag"]=>
      int(4096)
      ["namemax"]=>
      int(255)
    }
    ```


### fread()

Корутинный способ чтения файла.

```php
Swoole\Coroutine\System::fread(resource $handle, int $length = 0): string|false
```

!> В версиях ниже `v4.0.4` метод `fread` не поддерживает нефайловые `stream` ресурсы, такие как `STDIN`, `Socket`. Не используйте метод `fread` для этих типов ресурсов.  
В версиях выше `v4.0.4` метод `fread` поддерживает нефайловые `stream` ресурсы, и на нижнем уровне автоматически выбирает между использованием пула AIO-тредов или [EventLoop](/learn?id=что такоеeventloop) в зависимости от типа `stream`.

!> Этот метод был заброшен в версии `5.0` и удален в версии `6.0`

  * **Параметры** 

    * **`resource $handle`**
      * **Функция**: handle файла 【должен быть ресурсом `stream`, полученным с помощью функции `fopen`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`int $length`**
      * **Функция**: длина чтения 【по умолчанию `0`, означает чтение всего содержания файла】
      * **По умолчанию**: `0`
      * **Другие значения**: нет

  * **Возвращаемое значение** 

    * Если чтение успешно, возвращается содержание строки, если чтение неудачно, возвращается `false`

  * **Пример использования**  

    ```php
    $fp = fopen(__FILE__, "r");
    Swoole\Coroutine\run(function () use ($fp)
    {
        $r = Swoole\Coroutine\System::fread($fp);
        var_dump($r);
    });
    ```


### fwrite()

Корутинный способ записи данных в файл.

```php
Swoole\Coroutine\System::fwrite(resource $handle, string $data, int $length = 0): int|false
```

!> В версиях ниже `v4.0.4` метод `fwrite` не поддерживает нефайловые `stream` ресурсы, такие как `STDIN`, `Socket`. Не используйте метод `fwrite` для этих типов ресурсов.  
В версиях выше `v4.0.4` метод `fwrite` поддерживает нефайловые `stream` ресурсы, и на нижнем уровне автоматически выбирает между использованием пула AIO-тредов или [EventLoop](/learn?id=что такоеeventloop) в зависимости от типа `stream`.

!> Этот метод был заброшен в версии `5.0` и удален в версии `6.0`

  * **Параметры** 

    * **`resource $handle`**
      * **Функция**: handle файла 【должен быть ресурсом `stream`, полученным с помощью функции `fopen`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`string $data`**
      * **Функция**: данные для записи 【могут быть текстовыми или бинарных】
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`int $length`**
      * **Функция**: длина записи 【по умолчанию `0`, означает запись всего содержания `$data`, `$length` должен быть меньше длины `$data`】
      * **По умолчанию**: `0`
      * **Другие значения**: нет

  * **Возвращаемое значение** 

    * Если запись успешно, возвращается длина записанных данных, если запись неудачна, возвращается `false`

  * **Пример использования**  

    ```php
    $fp = fopen(__DIR__ . "/test.data", "a+");
    Swoole\Coroutine\run(function () use ($fp)
    {
        $r = Swoole\Coroutine\System::fwrite($fp, "hello world\n", 5);
        var_dump($r);
    });
    ```


### fgets()

Корутинный способ чтения содержания файла по строкам.

На нижнем уровне используется буфер `php_stream`,默认ный размер составляет `8192` байтов, размер буфера можно изменить с помощью функции `stream_set_chunk_size`.

```php
Swoole\Coroutine\System::fgets(resource $handle): string|false
```

!> Функция `fgets` может использоваться только с ресурсами `stream` типа файла, доступными после Swoole version >= `v4.4.4`

!> Этот метод был заброшен в версии `5.0` и удален в версии `6.0`

  * **Параметры** 

    * **`resource $handle`**
      * **Функция**: handle файла 【должен быть ресурсом `stream`, полученным с помощью функции `fopen`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

  * **Возвращаемое значение** 

    * Если достигнута строка-разделитель `EOL` (`\r` или `\n`), будет возвращена строка с `EOL`
    * Если не достигнута `EOL`, но длина содержания превышает размер буфера `php_stream` в `8192` байтов, будет возвращена часть данных размером в `8192` байтов, без `EOL`
    * Когда достигается конец файла `EOF`, будет возвращена пустая строка, можно использовать функцию `feof` для проверки, закончился ли чтение файла
    * Если чтение неудачно, возвращается `false`, можно использовать функцию [swoole_last_error](/functions?id=swoole_last_error) для получения кода ошибки

  * **Пример использования**  

    ```php
    $fp = fopen(__DIR__ . "/defer_client.php", "r");
    Swoole\Coroutine\run(function () use ($fp)
    {
        $r = Swoole\Coroutine\System::fgets($fp);
        var_dump($r);
    });
    ```


### readFile()

Корутинный способ чтения файла.

```php
Swoole\Coroutine\System::readFile(string $filename): string|false
```

  * **Параметры** 

    * **`string $filename`**
      * **Функция**: имя файла
      * **По умолчанию**: нет
      * **Другие значения**: нет

  * **Возвращаемое значение** 

    * Если чтение успешно, возвращается содержание строки, если чтение неудачно, возвращается `false`, можно использовать функцию [swoole_last_error](/functions?id=swoole_last_error) для получения информации об ошибке
    * Метод `readFile` не ограничен по размеру, чтение содержания происходит в памяти, поэтому при чтении очень больших файлов это может потребовать много памяти

  * **Пример использования**  

    ```php
    $filename = __DIR__ . "/defer_client.php";
    Swoole\Coroutine\run(function () use ($filename)
    {
        $r = Swoole\Coroutine\System::readFile($filename);
        var_dump($r);
    });
    ```
### writeFile()

С协程的方式写入文件。

```php
Swoole\Coroutine\System::writeFile(string $filename, string $fileContent, int $flags): bool
```

  * **Параметры** 

    * **`string $filename`**
      * **Функция**: Название файла【должен иметь права на запись, если файл не существует, он будет создан автоматически. Если открытие файла неудачно, сразу же возвращается `false`】
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`string $fileContent`**
      * **Функция**: Содержание, которое будет написано в файл【максимальный размер записи - `4M`】
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`int $flags`**
      * **Функция**: Опции записи【по умолчанию очистит текущее содержание файла, можно использовать `FILE_APPEND` для добавления к концу файла】
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

  * **Возвращаемое значение** 

    * Успешная запись возвращает `true`
    * Неудача записи возвращает `false`

  * **Пример использования**  

    ```php
    $filename = __DIR__ . "/defer_client.php";
    Swoole\Coroutine\run(function () use ($filename)
    {
        $w = Swoole\Coroutine\System::writeFile($filename, "hello swoole!");
        var_dump($w);
    });
    ```


### sleep()

Входит в состояние ожидания.

Подобен функции `sleep` в `PHP`, отличие в том, что `Coroutine::sleep` реализован с помощью диспетчера [координации координированных потоков](/coroutine?id=координация-координированных-потоков), на нижнем уровне происходит `yield` текущего координационного потока, освобождает временной слот и добавляет асинхронный таймер, который при достижении времени истечения возобновляет текущий координационный поток, продолжая его выполнение.

Использование интерфейса `sleep` позволяет легко реализовать функцию ожидания с истечением времени.

```php
Swoole\Coroutine\System::sleep(float $seconds): void
```

  * **Параметры** 

    * **`float $seconds`**
      * **Функция**: Время ожидания【должно быть больше `0`, максимальное значение не должно превышать время в один день（`86400` секунд）】
      * **Единица измерения**: секунды, минимальная точность - миллисекунда（`0.001` секунды）
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

  * **Пример использования**  

    ```php
    $server = new Swoole\Http\Server("127.0.0.1", 9502);

    $server->on('Request', function($request, $response) {
        //ожидание 200 мс перед отправкой ответа браузеру
        Swoole\Coroutine\System::sleep(0.2);
        $response->end("<h1>Hello Swoole!</h1>");
    });

    $server->start();
    ```


### exec()

Выполняет командный shell-команду. На нижнем уровне автоматически осуществляется [координация координированных потоков](/coroutine?id=координация-координированных-потоков).

```php
Swoole\Coroutine\System::exec(string $cmd): array
```

  * **Параметры** 

    * **`string $cmd`**
      * **Функция**: Shell-команда, которую следует выполнить
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

  * **Возвращаемое значение**

    * Если выполнение проваливается, возвращается `false`, если успешно, возвращается массив, содержащий код выхода процесса, сигнал и выходные данные.

    ```php
    array(
        'code'   => 0,  // Код выхода процесса
        'signal' => 0,  // Сигнал
        'output' => '', // Выводной контент
    );
    ```

  * **Пример использования**  

    ```php
    Swoole\Coroutine\run(function() {
        $ret = Swoole\Coroutine\System::exec("md5sum ".__FILE__);
    });
    ```

  * **Примечание**

  !> Если время выполнения команды Shell слишком долгое, это может привести к прерыванию из-за истечения времени, в таких случаях проблему можно решить увеличив [timeout_read_socket](/coroutine_client/init?id=правила-превышения-времени) для сокетов.


### gethostbyname()

Разрешает доменное имя на IP-адрес. Реализовано на основе синхронного пула线程ов, на нижнем уровне автоматически осуществляется [координация координированных потоков](/coroutine?id=координация-координированных-потоков).

```php
Swoole\Coroutine\System::gethostbyname(string $domain, int $family = AF_INET, float $timeout = -1): string|false
```

  * **Параметры** 

    * **`string $domain`**
      * **Функция**: Доменное имя
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`int $family`**
      * **Функция**: Семья адресов【`AF_INET` обозначает возвращение адреса IPv4, использование `AF_INET6` возвращает адрес IPv6】
      * **По умолчанию**: `AF_INET`
      * **Другие значения**: `AF_INET6`

    * **`float $timeout`**
      * **Функция**: Время ожидания
      * **Единица измерения**: секунды, минимальная точность - миллисекунда（`0.001` секунды）
      * **По умолчанию**: `-1`
      * **Другие значения**: Нет

  * **Возвращаемое значение**

    * Успешное возвращение IP-адреса, соответствующего доменному имени, неудача возвращает `false`, можно использовать [swoole_last_error](/functions?id=swoole_last_error) для получения информации об ошибке

    ```php
    array(
        'code'   => 0,  // Код выхода процесса
        'signal' => 0,  // Сигнал
        'output' => '', // Выводной контент
    );
    ```

  * **Расширение**

    * **Контроль за временем ожидания**

      Параметр `$timeout` может контролировать время ожидания координационного потока, если результат не возвращается в установленном времени, координационный поток немедленно возвращает `false` и продолжает выполнение ниже. В реализации на нижнем уровне этот асинхронный запрос будет отмечен как `cancel`, но `gethostbyname` продолжит работу в пуле AIO线程ов.
      
      Можно изменить время ожидания для функций `gethostbyname` и `getaddrinfo` на нижнем уровне C с помощью изменения настроек `/etc/resolv.conf`. Для подробной информации смотрите [настройка задержки и повторных попыток DNS-разрешения](/learn_other?id=настройка-задержки-и-повторных-попыток-dns-разрешения).

  * **Пример использования**  

    ```php
    Swoole\Coroutine\run(function () {
        $ip = Swoole\Coroutine\System::gethostbyname("www.baidu.com", AF_INET, 0.5);
        echo $ip;
    });
    ```


### getaddrinfo()

Проверяет DNS для преобразования доменного имени в соответствующий IP-адрес.

В отличие от `gethostbyname`, `getaddrinfo` поддерживает больше параметров и возвращает несколько результатов IP-адресов.

```php
Swoole\Coroutine\System::getaddrinfo(string $domain, int $family = AF_INET, int $socktype = SOCK_STREAM, int $protocol = STREAM_IPPROTO_TCP, string $service = null, float $timeout = -1): array|false
```

  * **Параметры** 

    * **`string $domain`**
      * **Функция**: Доменное имя
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`int $family`**
      * **Функция**: Семья адресов【`AF_INET` обозначает возвращение адреса IPv4, использование `AF_INET6` возвращает адрес IPv6】
      * **По умолчанию**: Нет
      * **Другие значения**: Нет
      
      !> Для других параметров смотрите документацию `man getaddrinfo`

    * **`int $socktype`**
      * **Функция**: Тип сокета
      * **По умолчанию**: `SOCK_STREAM`
      * **Другие значения**: `SOCK_DGRAM`, `SOCK_RAW`

    * **`int $protocol`**
      * **Функция**: Протокол
      * **По умолчанию**: `STREAM_IPPROTO_TCP`
      * **Другие значения**: `STREAM_IPPROTO_UDP`, `STREAM_IPPROTO_STCP`, `STREAM_IPPROTO_TIPC`, `0`

    * **`string $service`**
      * **Функция**:
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Время ожидания
      * **Единица измерения**: секунды, минимальная точность - миллисекунда（`0.001` секунды）
      * **По умолчанию**: `-1`
      * **Другие значения**: Нет

  * **Возвращаемое значение**

    * Успешное возвращение массива из нескольких IP-адресов, неудача возвращает `false`

  * **Пример использования**  

    ```php
    Swoole\Coroutine\run(function () {
        $ips = Swoole\Coroutine\System::getaddrinfo("www.baidu.com");
        var_dump($ips);
    });
    ```
### dnsLookup()

Иск по имени домена.

В отличие от `Coroutine\System::gethostbyname`, `Coroutine\System::dnsLookup` реализован непосредственно на основе сетевого общения с UDP-клиентом, а не использует функцию `gethostbyname`, предоставляемую `libc`.

!> Версия Swoole >= `v4.4.3` доступна, в качестве основы используется чтение файла `/etc/resolve.conf` для получения адреса DNS-сервера, в настоящее время поддерживается только разрешение доменных имен `AF_INET (IPv4)`. При версии Swoole >= `v4.7` можно использовать третий параметр для поддержки `AF_INET6 (IPv6)`.

```php
Swoole\Coroutine\System::dnsLookup(string $domain, float $timeout = 5, int $type = AF_INET): string|false
```

  * **Параметры** 

    * **`string $domain`**
      * **Функция**: Доменное имя
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`float $timeout`**
      * **Функция**: Время ожидания
      * **Единица измерения**: Секунды, минимальная точность - миллисекунды (0.001 секунды)
      * **По умолчанию**: `5`
      * **Другие значения**: Нет

    * **`int $type`**
        * **Единица измерения**: Секунды, минимальная точность - миллисекунды (0.001 секунды)
        * **По умолчанию**: `AF_INET`
        * **Другие значения**: `AF_INET6`

    !> Параметр `$type` доступен в версии Swoole >= `v4.7`.

  * **Возвращаемое значение**

    * Если разрешение успешно, возвращается соответствующий IP-адрес
    * В случае неудачи возвращается `false`, можно использовать [swoole_last_error](/functions?id=swoole_last_error) для получения информации об ошибке

  * **Частые ошибки**

    * `SWOOLE_ERROR_DNSLOOKUP_RESOLVE_FAILED`: Этот домен невозможно разрешить, запрос на разрешение потерпел неудачу
    * `SWOOLE_ERROR_DNSLOOKUP_RESOLVE_TIMEOUT`: Отсрочка разрешения, DNS-сервер может быть неисправен, и результат не может быть возвращен в установленном времени

  * **Пример использования**  

    ```php
    Swoole\Coroutine\run(function () {
        $ip = Swoole\Coroutine\System::dnsLookup("www.baidu.com");
        echo $ip;
    });
    ```


### wait()

Соответствует оригинальной функции [Process::wait](/process/process?id=wait), отличие в том, что этот API является версией с корoutine, он заставит корoutine замереть, может заменить функции `Swoole\Process::wait` и `pcntl_wait`.

!> Версия Swoole >= `v4.5.0` доступна

```php
Swoole\Coroutine\System::wait(float $timeout = -1): array|false
```

* **Параметры** 

    * **`float $timeout`**
      * **Функция**: Время ожидания, отрицательное значение означает, что ожидание никогда не заканчивается
      * **Единица измерения**: Секунды, минимальная точность - миллисекунды (0.001 секунды)
      * **По умолчанию**: `-1`
      * **Другие значения**: Нет

* **Возвращаемое значение**

  * Если операция успешно, возвращается массив, содержащий `PID` дочернего процесса, код выхода и сигнал, который убил процесс
  * В случае неудачи возвращается `false`

!> После запуска каждого дочернего процесса родительский процесс должен отправить корoutine для вызова `wait()` (или `waitPid()`) для очистки, иначе дочерний процесс станет зомби-процессом, что приведет к тому, что ресурсы операционной системы будут тратиться впустую.  
Если используется корoutine, необходимо сначала создать процесс, а внутри него начать корoutine. Не наоборот, иначе ситуация с forking корoutine будет очень сложной, что затруднит обработку на нижних уровнях.

* **Пример**

```php
use Swoole\Coroutine;
use Swoole\Coroutine\System;
use Swoole\Process;

$process = new Process(function () {
    echo 'Hello Swoole';
});
$process->start();

Coroutine\run(function () use ($process) {
    $status = System::wait();
    assert($status['pid'] === $process->pid);
    var_dump($status);
});
```


### waitPid()

Более или менее аналогичен предыдущему методу wait, отличие в том, что этот API позволяет ждать определенного процесса

!> Версия Swoole >= `v4.5.0` доступна

```php
Swoole\Coroutine\System::waitPid(int $pid, float $timeout = -1): array|false
```

* **Параметры** 

    * **`int $pid`**
      * **Функция**: ID процесса
      * **По умолчанию**: `-1` (означает любой процесс, в этом случае эквивалентен методу wait)
      * **Другие значения**: Любой натуральный номер

    * **`float $timeout`**
      * **Функция**: Время ожидания, отрицательное значение означает, что ожидание никогда не заканчивается
      * **Единица измерения**: Секунды, минимальная точность - миллисекунды (0.001 секунды)
      * **По умолчанию**: `-1`
      * **Другие значения**: Нет

* **Возвращаемое значение**

  * Если операция успешно, возвращается массив, содержащий `PID` дочернего процесса, код выхода и сигнал, который убил процесс
  * В случае неудачи возвращается `false`

!> После запуска каждого дочернего процесса родительский процесс должен отправить корoutine для вызова `wait()` (или `waitPid()`) для очистки, иначе дочерний процесс станет зомби-процессом, что приведет к тому, что ресурсы операционной системы будут тратиться впустую.

* **Пример**

```php
use Swoole\Coroutine;
use Swoole\Coroutine\System;
use Swoole\Process;

$process = new Process(function () {
    echo 'Hello Swoole';
});
$process->start();

Coroutine\run(function () use ($process) {
    $status = System::waitPid($process->pid);
    var_dump($status);
});
```


### waitSignal()

Корейная версия сигнала слушателя, она блокирует текущую корoutine до тех пор, пока сигнал не будет активирован, может заменить функции `Swoole\Process::signal` и `pcntl_signal`.

!> Версия Swoole >= `v4.5.0` доступна

```php
Swoole\Coroutine\System::waitSignal(int $signo, float $timeout = -1): bool
```

  * **Параметры** 

    * **`int $signo`**
      * **Функция**: Тип сигнала
      * **По умолчанию**: Нет
      * **Другие значения**: Константы SIG, такие как `SIGTERM`, `SIGKILL` и т.д.

    * **`float $timeout`**
      * **Функция**: Время ожидания, отрицательное значение означает, что ожидание никогда не заканчивается
      * **Единица измерения**: Секунды, минимальная точность - миллисекунды (0.001 секунды)
      * **По умолчанию**: `-1`
      * **Другие значения**: Нет

  * **Возвращаемое значение**

    * Если был получен сигнал, возвращается `true`
    * Если сигнал не был получен в течение установленного времени, возвращается `false`

  * **Пример**

```php
use Swoole\Coroutine;
use Swoole\Coroutine\System;
use Swoole\Process;

$process = new Process(function () {
    Coroutine\run(function () {
        $bool = System::waitSignal(SIGUSR1);
        var_dump($bool);
    });
});
$process->start();
sleep(1);
$process::kill($process->pid, SIGUSR1);
```

### waitEvent()

Корейная версия сигнала слушателя, она блокирует текущую корoutine до тех пор, пока сигнал не будет активирован. Ожидание IO событий, может заменить функции `swoole_event`.

!> Версия Swoole >= `v4.5` доступна

```php
Swoole\Coroutine\System::waitEvent(mixed $socket, int $events = SWOOLE_EVENT_READ, float $timeout = -1): int | false
```

* **Параметры** 

    * **`mixed $socket`**
      * **Функция**: Файловый дескриптор (любые виды, которые могут быть преобразованы в fd, такие как объект Socket, ресурс и т.д.)
      * **По умолчанию**: Нет
      * **Другие значения**: Нет

    * **`int $events`**
      * **Функция**: Тип события
      * **По умолчанию**: `SWOOLE_EVENT_READ`
      * **Другие значения**: `SWOOLE_EVENT_WRITE` или `SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE`

    * **`float $timeout`**
      * **Функция**: Время ожидания, отрицательное значение означает, что ожидание никогда не заканчивается
      * **Единица измерения**: Секунды, минимальная точность - миллисекунды (0.001 секунды)
      * **По умолчанию**: `-1`
      * **Другие значения**: Нет

* **Возвращаемое значение**

  * Возвращается сумма типов событий, которые были активированы (возможно несколько битов), в зависимости от переданного значения параметра `$events`
  * В случае неудачи возвращается `false`, можно использовать [swoole_last_error](/functions?id=swoole_last_error) для получения информации об ошибке

* **Пример**

> Синхронный блокирующий код может быть превращен в корoutine-нечеблокирующий с помощью этой API

```php
use Swoole\Coroutine;

Coroutine\run(function () {
    $client = stream_socket_client('tcp://www.qq.com:80', $errno, $errstr, 30);
    $events = Coroutine::waitEvent($client, SWOOLE_EVENT_READ | SWOOLE_EVENT_WRITE);
    assert($events === SWOOLE_EVENT_WRITE);
    fwrite($client, "GET / HTTP/1.1\r\nHost: www.qq.com\r\n\r\n");
    $events = Coroutine::waitEvent($client, SWOOLE_EVENT_READ);
    assert($events === SWOOLE_EVENT_READ);
    $response = fread($client, 8192);
    echo $response;
});
```
