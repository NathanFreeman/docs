# Инструкции по программированию с использованием координационных функций

При использовании функции координации Swoole [координаты](/coroutine), пожалуйста, внимательно прочтите эти Инструкции по программированию.

## парадигма программирования

* Внутри координации запрещено использовать глобальные переменные
* Для координации используется ключевое слово `use` для вхождения внешних переменных в текущий контекст, запрещено использовать ссылки
* Для общения между координациями необходимо использовать [канал](/coroutine/channel)

!> То есть для общения между координациями не следует использовать глобальные переменные или ссылки на внешние переменные в текущем контексте, а следует использовать `Channel`

* Если в проекте есть расширения `hook` которые изменяют `zend_execute_ex` или `zend_execute_internal`, необходимо особо обратить внимание на C-стек. Можно использовать [Co::set](/coroutine/coroutine?id=set) для пересоздания размера C-стека

!> После `hook` этих двух входных функций в большинстве случаев прямые вызовы плоских PHP-инструкции превращаются в вызовы C-функций, что увеличивает потребление C-стека.

## Выход из координации

В ранних версиях Swoole использование `exit` в координации для принудительного завершения сценария может привести к ошибкам памяти, непредвиденным результатам или `coredump`, а использование `exit` в сервисе Swoole приведет к завершению всего сервисного процесса и исключительному завершению всех внутренних координаций, что вызовет серьезные проблемы. Swoole долгое время запрещала разработчикам использовать `exit`, но разработчики могут использовать необычный способ -抛出 исключения, чтобы в верхнем уровне `catch` реализовать ту же логику выхода, что и `exit`.

!> В версиях v4.2.2 и выше разрешается сценариям (не создавшим `http_server`) выходить `exit` только в случае наличия только текущей координации

В версиях Swoole **v4.1.0** и выше поддерживается прямое использование `exit` из `координации`, `событийного цикла сервиса` PHP, при этом на нижнем уровне автоматически抛出 ловимый `Swoole\ExitException`, и разработчики могут в необходимом месте поймать его и реализовать логику выхода, аналогичную естественному PHP.

### Swoole\ExitException

`Swoole\ExitException` наследуется от `Exception` и добавляет два метода: `getStatus` и `getFlags`:

```php
namespace Swoole;

class ExitException extends \Exception
{
	public function getStatus(): mixed
	public function getFlags(): int
}
```

#### getStatus()

Получает параметр `status`, переданный в функцию exit($status) при выходе, поддерживает любые виды переменных.

```php
public function getStatus(): mixed
```

#### getFlags()

Получает掩码 информации о окружении при выходе из функции exit.

```php
public function getFlags(): int
```

На данный момент существуют следующие маски:

| Константа | Описание |
| -- | -- |
| SWOOLE_EXIT_IN_COROUTINE | Выход в координации |
| SWOOLE_EXIT_IN_SERVER | Выход в сервере |

### Как использовать

#### Основное использование

```php
use Swoole\Coroutine;
use function Swoole\Coroutine\run;

function route()
{
    controller();
}

function controller()
{
    your_code();
}

function your_code()
{
    Coroutine::sleep(.001);
    exit(1);
}

run(function () {
    try {
        route();
    } catch (\Swoole\ExitException $e) {
        var_dump($e->getMessage());
        var_dump($e->getStatus() === 1);
        var_dump($e->getFlags() === SWOOLE_EXIT_IN_COROUTINE);
    }
});
```

#### Выход с статусным кодом

```php
use function Swoole\Coroutine\run;

$exit_status = 0;
run(function () {
    try {
        exit(123);
    } catch (\Swoole\ExitException $e) {
        global $exit_status;
        $exit_status = $e->getStatus();
    }
});
var_dump($exit_status);
```

## Обработка исключений

В программировании с использованием координации можно напрямую использовать `try/catch` для обработки исключений. **Однако исключения должны быть捕获ены внутри координации, их нельзя ловить между координациями**.

!> Не только исключения, выброшенные на уровне приложения с помощью `throw`, но и некоторые системные ошибки могут быть捕获ены, например, когда `функция`, `класс` или `Метод` не существует

### Плохой пример

В следующем коде `try/catch` и `throw` находятся в разных координациях, и исключение не может быть捕获ено внутри координации. Когда координация завершается, обнаруживается незапасанное исключение, что приводит к смертельному ошибке.

```bash
PHP Fatal error:  Uncaught RuntimeException
```

```php
try {
	Swoole\Coroutine::create(function () {
		throw new \RuntimeException(__FILE__, __LINE__);
	});
}
catch (\Throwable $e) {
	echo $e;
}
```

### Хороший пример

Выполнение исключения внутри координации.

```php
function test() {
	throw new \RuntimeException(__FILE__, __LINE__);
}

Swoole\Coroutine::create(function () {
	try {
		test();
	}
	catch (\Throwable $e) {
		echo $e;
	}
});
```

## В методах __get / __set魔术 не следует вызывать переключение координации

Причина: [См. анализ ядра PHP7](https://github.com/pangudashu/php7-internal/blob/40645cfe087b373c80738881911ae3b178818f11/3/zend_object.md)

> **Примечание:** Если класс имеет метод __get(), то при создании объекта и распределении памяти для свойств (то есть: table_properties) будет дополнительно выделена zval, типа HashTable. Каждый раз, когда вызывается __get($var), имя входящей переменной $var будет сохранено в этой HashTable. Целью этого является предотвращение бесконечного цикла вызовов. Например:
> 
> ***public function __get($var) { return $this->$var; }***
>
> В этом случае, когда вызывается __get(), снова обращается к несуществующему свойству, то есть в методе __get() происходит рекурсивный вызов. Если не проверить входящую переменную $var, то рекурсия будет продолжаться бесконечно. Поэтому перед тем как вызвать __get(), сначала проверяется, не была ли переменная $var уже вызвана в __get(). Если да, то __get() не будет снова вызываться, в противном случае переменная $var будет вставлена в HashTable как ключ, а затем значение хеша будет установлено как: *guard |= IN_ISSET. После завершения вызова __get() значение хеша будет установлено как: *guard &= ~IN_ISSET.
>
> Эта HashTable используется не только для __get(), но и для других волшебных методов, поэтому ее тип значения хеша - zend_long, разные волшебные методы занимают разные биты; кроме того, не все объекты выделяют эту HashTable при создании. При создании объекта определяется, выделять ли ее на основе того, содержит ли ***zend_class_entry.ce_flags*** флаг ***ZEND_ACC_USE_GUARDS***. При компиляции класса, если обнаруживаются методы __get(), __set(), __unset(), __isset(), то флаг ce_flags будет установлен с этим掩码ом.

После переключения координации на следующий вызов будет считаться за циклический вызов, это проблема, присущая PHP**, и после общения с группой разработчиков PHP пока не найдено решения.

Примечание: Хотя в волшебных методах нет кода, который мог бы вызвать переключение координации, установление активной диспетчеризации координации все равно может привести к тому, что волшебные методы будут принудительно переключать координации.

Совет: сам Implementируйте методы `get`/`set` для явного вызова
### Использование классических статических переменных/глобальных переменных для хранения контекста

Когда несколько covariантов выполняются concurrently, их контекст не может быть сохранен с помощью классических статических переменных или глобальных переменных. Использование локальных переменных безопасно, так как их значения автоматически сохраняются в стеке covariантов, и другие covariанты не могут получить доступ к локальным переменным covariанта.

#### Ошибочный пример

```php
$server = new Swoole\Http\Server('127.0.0.1', 9501);

$_array = [];
$server->on('request', function ($request, $response) {
    global $_array;
    // Запрос к /a (кооператив 1)
    if ($request->server['request_uri'] == '/a') {
        $_array['name'] = 'a';
        co::sleep(1.0);
        echo $_array['name'];
        $response->end($_array['name']);
    }
    // Запрос к /b (кооператив 2)
    else {
        $_array['name'] = 'b';
        $response->end();
    }
});
$server->start();
```

Запустите `2` параллельных запроса.

```shell
curl http://127.0.0.1:9501/a
curl http://127.0.0.1:9501/b
```

* Во время выполнения covariанта `1` глобальная переменная `$_array['name']` была изменена на `'a'`
* Кооператив `1` вызывает `co::sleep`, который приостанавливает его
*瞰 cooperativa `2` выполняется, изменяя значения глобальной переменной `$_array['name']` на `'b'`, и cooperative 2 заканчивается
* В это время таймер возвращается, и основной уровень возобновляет выполнение cooperativa `1`. Но воLogic cooperativa `1` есть зависимость о контексте. Когда снова печатается значение глобальной переменной `$_array['name']`, ожидается значение `'a'`, но на самом деле это значение было изменено cooperativa `2`. В результате возникает логическая ошибка.
* Точно так же, использование классических статических переменных класса `Class::$array`, глобальных объектов `$object->array`, других сверхглобальных переменных `$GLOBALS`, и т. д., для хранения контекста в программе covariантов очень опасно. Можно возникнуть непредвиденное поведение.

![](../_images/coroutine/notice-1.png)

#### Правильный пример: Использование Context для управления контекстом

Можно использовать класс `Context` для управления контекстом covariантов. В классе `Context` используются методы `Coroutine::getuid` для получения идентификатора covariанта и изоляции глобальных переменных между различными covariантами. Когда covariант завершается, контекстные данные очищаются.

```php
use Swoole\Coroutine;

class Context
{
    protected static $pool = [];

    static function get($key)
    {
        $cid = Coroutine::getuid();
        if ($cid < 0)
        {
            return null;
        }
        if(isset(self::$pool[$cid][$key])){
            return self::$pool[$cid][$key];
        }
        return null;
    }

    static function put($key, $item)
    {
        $cid = Coroutine::getuid();
        if ($cid > 0)
        {
            self::$pool[$cid][$key] = $item;
        }
    }

    static function delete($key = null)
    {
        $cid = Coroutine::getuid();
        if ($cid > 0)
        {
            if($key){
                unset(self::$pool[$cid][$key]);
            }else{
                unset(self::$pool[$cid]);
            }
        }
    }
}
```

Использование:

```php
use Swoole\Coroutine\Context;

$server = new Swoole\Http\Server('127.0.0.1', 9501);

$server->on('request', function ($request, $response) {
    if ($request->server['request_uri'] == '/a') {
        Context::put('name', 'a');
        co::sleep(1.0);
        echo Context::get('name');
        $response->end(Context::get('name'));
        // Очищение при завершении covariанта
        Context::delete('name');
    } else {
        Context::put('name', 'b');
        $response->end();
        // Очищение при завершении covariанта
        Context::delete();
    }
});
$server->start();
```
