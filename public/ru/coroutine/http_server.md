# HTTP-сервер

?> Полный реализацией синхронного HTTP-сервера является `Co\Http\Server`, написанный на C++ из-за производительности анализа HTTP, и поэтому он не является подклассом [Co\Server](/coroutine/server), написанного на PHP.

Отличия от [Http\Server](/http_server):

* Можно динамически создавать и уничтожать в процессе работы
* Обработка соединений выполняется в отдельных под协程ах, `Connect`, `Request`, `Response`, `Close` клиентов полностью последовательно

!> Требуется версия `v4.4.0` или выше

!> Если во время компиляции [включить HTTP/2](/environment?id=compile_options), то по умолчанию будет включена поддержка протокола HTTP/2, и не требуется настройка [open_http2_protocol](/http_server?id=open_http2_protocol), как в случае с `Swoole\Http\Server` (Примечание: **в версиях ниже v4.4.16 есть известные проблемы с поддержкой HTTP/2, пожалуйста, обновитесь перед использованием**)


## Короткое название

Можно использовать короткое название `Co\Http\Server`.


## Методы


### __construct()

```php
Swoole\Coroutine\Http\Server::__construct(string $host, int $port = 0, bool $ssl = false, bool $reuse_port = false);
```

  * **Параметры** 

    * **`string $host`**
      * **Функция**: IP-адрес для прослушивания 【если это локальный UNIX-сокет, то следует填写 в формате `unix://tmp/your_file.sock`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`int $port`**
      * **Функция**: Порт для прослушивания 
      * **По умолчанию**: 0 (случайно выбирается свободное портное число)
      * **Другие значения**: 0~65535

    * **`bool $ssl`**
      * **Функция**: Включать ли туннельное шифрование `SSL/TLS`
      * **По умолчанию**: нет
      * **Другие значения**: да
      
    * **`bool $reuse_port`**
      * **Функция**: Включать ли特性 повторного использования порта, после включения несколько услуг могут использовать один и тот же порт
      * **По умолчанию**: нет
      * **Другие значения**: да


### handle()

Зарегистрируйте обратный вызов для обработки HTTP-запросов по пути, указанному в параметре `$pattern`.

```php
Swoole\Coroutine\Http\Server->handle(string $pattern, callable $fn): void
```

!> Необходимо установить функцию обработки до [Server::start](/coroutine/server?id=start)

  * **Параметры** 

    * **`string $pattern`**
      * **Функция**: Установить путь 【например, `/index.html`, обратите внимание, что здесь нельзя传入 `http://domain`】
      * **По умолчанию**: нет
      * **Другие значения**: нет

    * **`callable $fn`**
      * **Функция**: Функция обработки, использование смотрите в [OnRequest](/http_server?id=on) обратном вызове в `Swoole\Http\Server`, здесь мы не будем повторяться
      * **По умолчанию**: нет
      * **Другие значения**: нет      

      Пример:

      ```php
      function callback(Swoole\Http\Request $req, Swoole\Http\Response $resp) {
          $resp->end("hello world");
      }
      ```

  * **Примечание**

    * После успешного `Accept` (установления соединения) сервер автоматически создает协 程 и принимает `HTTP`-запросы
    * `$fn` выполняется в новом пространстве под协程, поэтому внутри функции не нужно снова создавать协程
    * Клиенты поддерживают [KeepAlive](/coroutine_client/http_client?id=keep_alive), под协程 будут циклически принимать новые запросы, не выходя
    * Если клиенты не поддерживают `KeepAlive`, под协程 прекратят прием запросов и закончат работу, закрыв соединение

  * **Важное примечание**

    !> - Если `$pattern` установлен одинаково, новое значение заменит старое;  
    - Если не установлена функция обработки корневого пути и запрос не найден匹配ющий какой-либо `$pattern`, Swoole вернет `404` ошибку;  
    - `$pattern` использует метод字符串ового сопоставления, не поддерживает wildcard и регулярные выражения, не различает заглавные и строчные буквы, алгоритм сопоставления основан на префиксном сопоставлении, например: если URL - `/test111`, то он будет соответствовать правилу `/test`, и после сопоставления будет пропущено дальнейшее конфигурационное значение;  
    - Рекомендуется установить функцию обработки корневого пути и использовать `$request->server['request_uri']` в обратном вызове для роутинга запросов.


### start()

?> **Запустить сервер.** 

```php
Swoole\Coroutine\Http\Server->start();
```


### shutdown()

?> **Остановить сервер.** 

```php
Swoole\Coroutine\Http\Server->shutdown();
```

## Полный пример

```php
use Swoole\Coroutine\Http\Server;
use function Swoole\Coroutine\run;

run(function () {
    $server = new Server('127.0.0.1', 9502, false);
    $server->handle('/', function ($request, $response) {
        $response->end("<h1>Индекс</h1>");
    });
    $server->handle('/test', function ($request, $response) {
        $response->end("<h1>Тест</h1>");
    });
    $server->handle('/stop', function ($request, $response) use ($server) {
        $response->end("<h1>Остановка</h1>");
        $server->shutdown();
    });
    $server->start();
});
```
