# Swoole\Async\Client

`Swoole\Async\Client`, в просторечии `Client`, является асинхронным неблокирующим сетевым клиентом для `TCP/UDP/UnixSocket`. Асинхронный клиент требует установки Callback-функций событий, вместо синхронного ожидания.

- Асинхронный клиент является производным от `Swoole\Client` и может использовать некоторые методы синхронного блокирующего клиента
- Доступен только в версиях `6.0` и выше

## Полный пример

```php
$cli = new Swoole\Async\Client(SWOOLE_SOCK_TCP);

$client->on("connect", function(Swoole\Async\Client $client) {
    Assert::true($client->isConnected());
    $client->send(RandStr::gen(1024, RandStr::ALL));
});

$client->on("receive", function(Swoole\Async\Client $client, string $data){
    $recv_len = strlen($data);
    $client->send(RandStr::gen(1024, RandStr::ALL));
    $client->close();
    Assert::false($client->isConnected());
});

$client->on("error", function(Swoole\Async\Client $client) {
    echo "error";
});

$client->on("close", function(Swoole\Async\Client $client) {
    echo "close";
});

$client->connect("127.0.0.1", 9501, 0.2);
```

## Методы

На этой странице представлены только методы, отличные от `Swoole\Client`. Методы, которые не изменены в производном классе, см. в [синхронном блокирующем клиенте](client.md).

### __construct()

Конструктор, см. в родительском классе

```php
Swoole\Async\Client::__construct(int $sock_type, bool $async = true, string $key);
```

> Второй параметр асинхронного клиента должен быть `true`


### on()

регистрация Callback-функции событий для `Client`.

```php
Swoole\Async\Client->on(string $event, callable $callback): bool
```

!> Если `on`-метод вызывается повторно, предыдущее настройки будут перезаписаны

  * **Параметры**

    * `string $event`

      * Функция: Название события обратной связи, чувствительно к letter case
      * По умолчанию: нет
      * Другие значения: нет

    * `callable $callback`

      * Функция:回调 функция
      * По умолчанию: нет
      * Другие значения: нет

      !> Можно быть строкой с именем функции, статическим методом класса, массивом методов объекта, анонимной функцией. См. [эту главу](/learn?id=способы установки обратной связи).
  
  * **Возвращаемое значение**

    * Возвращает `true`, если операция прошла успешно, возвращает `false`, если операции失败.



### isConnected()
Проверка, установилась ли текущая客户端ская связь с сервером.

```php
Swoole\Async\Client->isConnected(): bool
```

* Возвращает `true`, если соединено, возвращает `false`, если не соединено


### sleep()
Временное прекращение приема данных, после вызова будет удален из событийого цикла и больше не будут вызваны события приема данных, если только `wakeup()` метод не будет вызван для возобновления.

```php
Swoole\Async\Client->sleep(): bool
```

* Возвращает `true`, если операция прошла успешно, возвращает `false`, если операция失败


### wakeup()
Восстановление приема данных, после вызова будет добавлен в событияого цикла.

```php
Swoole\Async\Client->wakeup(): bool
```

* Возвращает `true`, если операция прошла успешно, возвращает `false`, если операция失败



### enableSSL()
Динамическое включение шифрования `SSL/TLS`, обычно используется для клиентов `startTLS`. После установления соединения сначала отправляются данные в明文е, затем начинается шифрованный обмен.

```php
Swoole\Async\Client->enableSSL(callable $callback): bool
```

* Эта функция может быть вызвана только после успешного `connect`
* Для асинхронного клиента необходимо установить `$callback`, который будет вызван после завершения `SSL` рукопожатия
* Возвращает `true`, если операция прошла успешно, возвращает `false`, если операция失败


## Объекты обратной связи


### connect
Вызывается после установления соединения, если установлены прокси `HTTP` или `Socks5` и туннель `SSL`, то после завершения рукопожатия с прокси и `SSL`.

```php
$client->on("connect", function(Swoole\Async\Client $client) {
    Assert::true($client->isConnected());    
});
```

После этого события обратной связи использование `isConnected()` вернет `true`



### error 
Вызывается при неудачном установлении соединения, можно получить информацию об ошибке с помощью `$client->errCode`.
```php
$client->on("error", function(Swoole\Async\Client $client) {
    var_dump($client->errCode);  
});
```



- Обратите внимание, что `connect` и `error` могут быть вызваны только один раз, после успешного или неудачного установления соединения может быть только одно исходное значение

- `Client::connect()` может напрямую вернуть `false`, что означает неудачу соединения, в этом случае `error` обратной связи не будет вызвана, поэтому обязательно проверьте результат вызова `connect`

- `error` событие является асинхронным результатом, между началом соединения и возникновением события `error` может быть определенный `IO` ожидание времени
- Отказ от соединения `connect` означает немедленный отказ, этот ошибочный случай напрямую вызван операционной системой и между ним нет никакого `IO` ожидания времени


### receive
Вызывается после приема данных

```php
$client->on("receive", function(Swoole\Async\Client $client, string $data){
    var_dump(strlen($data));
});
```



- Если не установлены никакие протоколы, например `EOF` или `LENGTH`, максимальная длина возвращаемых данных составляет `64K`

- Если установлены параметры обработки протоколов, максимальная длина данных составляет значение, установленное для параметра `package_max_length`, по умолчанию `2M`
- `$data` определенно не пуст, если получена системная ошибка или соединение закрыто, то будет вызвано событие `close`

### close
Вызывается при закрытии соединения

```php
$client->on("close", function(Swoole\Async\Client $client) {
    echo "close";
});
```
