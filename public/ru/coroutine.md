# Корутины <!-- {docsify-ignore-all} -->

В этом разделе представлены основные понятия и распространенные проблемы корутин.

Начиная с версии 4.0, `Swoole` предоставляет полный набор функций для **корутин (Coroutine)** и **каналов (Channel)**, что приводит к новой модели программирования **CSP (Communicating Sequential Processes)**.

1. разработчики могут писать синхронный код без особого ощущения, достигая эффекта и производительности [асинхронного ввода/вывода](/learn?id=syncioasyncio), избегая разрозненной логики кода и проблем с управлением, которые возникают в традиционных асинхронных обратных вызовах.
2. Кроме того, поскольку корутины на уровне API скрыты, по сравнению с традиционными фреймворками корутин на уровне PHP, разработчикам не требуется использовать ключевое слово **[yield](https://www.php.net/manual/zh/language.generators.syntax.php)** для обозначения корутинового операции ввода/вывода, что значительно повышает эффективность разработки.
3. Предоставляются различные полностью функциональные **[клиенты корутин](/coroutine_client/init)**, удовлетворяющие потребности большинства разработчиков.

## Что такое корутина

Корутина можно简单地 понимать как поток, но этот поток работает в пользовательском пространстве и не требует участия операционной системы, что делает создание, уничтожение и переключение очень быстрыми. В отличие от потоков, корутины не могут использовать многопроцессорный CPU и для использования многопроцессорного CPU необходимо полагаться на модель многопроцессоров `Swoole`.

## Что такое канал

**Канал** можно рассматривать как очередь сообщений, но это очередь сообщений между корутинами. Множество корутин через операции `push` и `pop` добавляют и удаляют сообщения из очереди для передачи или приема данных между корутинами. Стоит отметить, что каналы не могут пересекать процессы и могут использоваться только для коммуникации между корутинами в одном процессе `Swoole`. Типичным примером использования является **[пул соединений](/coroutine/conn_pool)** и **[многоп酵тная вызов](/coroutine/multi_call)**.

## Что такое контейнер корутин

Корутины создаются с помощью методов `Coroutine::create` или `go()` (см. раздел [Псевдонимы](/other/alias?id=корутинные краткие имена)). В созданных корутинах можно использовать API корутин, а корутины должны быть созданы внутри контейнера корутин, см. раздел [Контроллер корутин](/coroutine/scheduler).

## Рас Scheduling корутин

Здесь мы постараемся объяснить, что такое рас Scheduling корутин, как можно просто понять, что каждая корутина может быть đơn giảnно понята как поток. Как известно, многопоточные программы предназначены для повышения параллельности программы, и так же и многокорутинные программы предназначены для повышения параллельности.

Каждый запрос пользователя создает корутину, и после завершения запроса корутина заканчивается. Если одновременно существует тысячи параллельных запросов, то в один момент времени в каком-то процессе могут существовать тысячи корутин. Таким образом, ресурсы CPU ограничены. Какой именно код корутины должен быть выполнен CPU?

Процесс принятия решения о том, какой именно код корутины должен быть выполнен CPU, называется **рас Scheduling корутин**. Какова стратегия расписания в Swoole?

Во-первых, в процессе выполнения кода корутины обнаруживается, что этот код встретил `Co::sleep()` или возникла сетевая `IO`, например, `MySQL->query()`. Это, безусловно, процесс, требующий времени, и Swoole помещает Fd этого соединения MySQL в **[EventLoop](/learn?id=что такое eventloop)**.

* Затем CPU этой корутины передается другим корутинам: **то есть `yield` (замедление)**
* Ожидая возврата данных от MySQL, снова продолжается выполнение этой корутины: **то есть `resume` (возрождение)**

Во-вторых, если в коде корутины есть CPU-密集型 операции, можно включить **[enable_preemptive_scheduler](/other/config)**, и Swoole принудительно заставит эту корутину отказаться от CPU.

## Приоритет родительских и дочерних корутин

Приоритет принадлежит выполнению дочерних корутин (то есть логики внутри `go()`), пока не наступит `yield` корутины (в месте Co::sleep()), затем **[рас Scheduling](/coroutine?id=рас-scheduling-корутин)** происходит к внешним корутинам.

```php
use Swoole\Coroutine;
use function Swoole\Coroutine\run;

echo "main start\n";
run(function () {
    echo "coro " . Coroutine::getcid() . " start\n";
    Coroutine::create(function () {
        echo "coro " . Coroutine::getcid() . " start\n";
        Coroutine::sleep(.2);
        echo "coro " . Coroutine::getcid() . " end\n";
    });
    echo "coro " . Coroutine::getcid() . " do not wait children coroutine\n";
    Coroutine::sleep(.1);
    echo "coro " . Coroutine::getcid() . " end\n";
});
echo "end\n";

/*
main start
coro 1 start
coro 2 start
coro 1 do not wait children coroutine
coro 1 end
coro 2 end
end
*/
```
  

## Внимание

Перед использованием программирования в Swoole следует обратить внимание на следующие моменты:

### Глобальные переменные

Корутины делают существующую асинхронную логику синхронной, но переключение между корутинами происходит незаметно, поэтому перед и после переключения корутин нельзя гарантировать согласованность глобальных переменных и `static` переменных.

Под `PHP-FPM` можно получить доступ к запросным параметрам, серверным параметрам и т.д. через глобальные переменные. В `Swoole` **не** можно получить доступ к какой-либо атрибутной Parameter через переменные, начинающиеся с `_` таких как `$_GET/$_POST/$_REQUEST/$_SESSION/$_COOKIE/$_SERVER`.

Используйте **[контекст](/coroutine/coroutine?id=getcontext)** с идентификатором корутины для изоляции и реализации изоляции глобальных переменных.

### Множество корутин делятся одной и той же TCP-соединением

[См.](/question/use?id=клиент уже привязан к другой корутине)
