# Метод


## __construct() 

Создает объект TCP Server с поддержкой асинхронного ввода/вывода.

```php
Swoole\Server::__construct(string $host = '0.0.0.0', int $port = 0, int $mode = SWOOLE_PROCESS, int $sockType = SWOOLE_SOCK_TCP): \Swoole\Server
```

  * **Параметры**

    * `string $host`

      * Функция: Указывает IP-адрес, на который следует слушать.
      * По умолчанию: нет.
      * Другие значения: нет.

      !> Для IPv4 используется `127.0.0.1`, чтобы слушать локальный адрес, `0.0.0.0` - все адреса.
      Для IPv6 используется `::1`, чтобы слушать локальный адрес, `::` (соответствует `0:0:0:0:0:0:0:0`) - все адреса.

    * `int $port`

      * Функция: Указывает порт, на который следует слушать, например `9501`.
      * По умолчанию: нет.
      * Другие значения: нет.

      !> Если `$sockType` равен [UnixSocket Stream/Dgram](/learn?id=что такоеIPC), этот параметр будет игнорирован.
      Для прослушивания портов ниже `1024` требуется привилегия `root`.
      Если этот порт занят, `server->start` потерпит неудачу при попытке начать сервер.

    * `int $mode`

      * Функция: Указывает режим работы.
      * По умолчанию: [SWOOLE_PROCESS](/learn?id=swoole_process) - многопроцессный режим (по умолчанию).
      * Другие значения: [SWOOLE_BASE](/learn?id=swoole_base) - базовый режим, [SWOOLE_THREAD](/learn?id=swoole_thread) - многопроцессный режим с поддержкой线程 (доступен в Swoole 6.0).

      ?> В режиме `SWOOLE_THREAD` можно посмотреть, как создать сервер в многопроцессном режиме с использованием线程 [Thread + Server (async style)](/thread/thread?id=thread-server-(async-style)).

      !> Начиная с Swoole 5,默认ным значением режима работы является `SWOOLE_BASE`.

    * `int $sockType`

      * Функция: Указывает тип сокета для этого набора Server.
      * По умолчанию: нет.
      * Другие значения:
        * `SWOOLE_TCP/SWOOLE_SOCK_TCP` - tcp ipv4 сокет
        * `SWOOLE_TCP6/SWOOLE_SOCK_TCP6` - tcp ipv6 сокет
        * `SWOOLE_UDP/SWOOLE_SOCK_UDP` - udp ipv4 сокет
        * `SWOOLE_UDP6/SWOOLE_SOCK_UDP6` - udp ipv6 сокет
        * [SWOOLE_UNIX_DGRAM](https://github.com/swoole/swoole-src/blob/master/examples/unixsock/dgram_server.php) - unix сокет datagram
        * [SWOOLE_UNIX_STREAM](https://github.com/swoole/swoole-src/blob/master/examples/unixsock/stream_server.php) - unix сокет stream 

      !> Использование `$sock_type` | `SWOOLE_SSL` может активировать шифрование туннеля SSL. После активации SSL необходимо настроить [ssl_key_file](/server/setting?id=ssl_cert_file) и [ssl_cert_file](/server/setting?id=ssl_cert_file).

  * **Пример**

```php
$server = new \Swoole\Server($host, $port = 0, $mode = SWOOLE_PROCESS, $sockType = SWOOLE_SOCK_TCP);

// Можно смешивать использование UDP/TCP, одновременно слушать внутренние и внешние сети, многоport прослушивание смотрите в разделе addlistener.
$server->addlistener("127.0.0.1", 9502, SWOOLE_SOCK_TCP); // Добавление TCP
$server->addlistener("192.168.1.100", 9503, SWOOLE_SOCK_TCP); // Добавление Web Socket
$server->addlistener("0.0.0.0", 9504, SWOOLE_SOCK_UDP); // UDP
$server->addlistener("/var/run/myserv.sock", 0, SWOOLE_UNIX_STREAM); //UnixSocket Stream
$server->addlistener("127.0.0.1", 9502, SWOOLE_SOCK_TCP | SWOOLE_SSL); //TCP + SSL

$port = $server->addListener("0.0.0.0", 0, SWOOLE_SOCK_TCP); // Система распределяет порт случайно, возвращаемое значение - случайный назначенный порт
echo $port->port;
```
  

## set()

Используется для установки различных параметров во время работы сервера. После запуска сервера параметры, установленные с помощью метода `Server->set`, можно получить через `$serv->setting`.

```php
Swoole\Server->set(array $setting): void
```

!> Метод `Server->set` должен быть вызван до `Server->start`, конкретное значение каждого конфигурационного параметра смотрите в [этой секции](/server/setting).

  * **Пример**

```php
$server->set(array(
    'reactor_num'   => 2,     // Количество线程
    'worker_num'    => 4,     // Количество процессов
    'backlog'       => 128,   // Установить длину очереди Listen
    'max_request'   => 50,    // Максимальная количество запросов, принимаемых каждым процессом
    'dispatch_mode' => 1,     // Стратегия распределения пакетов
));
```


## on()

Зарегистрировать回调-функцию события `Server`.

```php
Swoole\Server->on(string $event, callable $callback): bool
```

!> повторное использование метода `on`覆盖 предыдущее определение.

!> Начиная с PHP 8.2, прямое определение динамических свойств не поддерживается, и если `$event` не является события, определенным Swoole, будет выброшен предупреждение.

  * **Параметры**

    * `string $event`

      * Функция: Название события обратной связи
      * По умолчанию: нет
      * Другие значения: нет

      !> Не чувствительно к casу, конкретные события обратной связи смотрите в [этой секции](/server/events), названия событий не должны оканчиваться на `on`.

    * `callable $callback`

      * Функция:回调-функция
      * По умолчанию: нет
      * Другие значения: нет

      !> Может быть строкой с именем функции, статическим методом класса, методом объекта или анонимной функцией. Смотрите [эту секцию](/learn?id=как установить回调-функцию) для различных способов установки обратной связи.
  
  * **Возвращаемое значение**

    * Возвращает `true`, если операция прошла успешно, или `false`, если операция потерпела неудачу.

  * **Пример**

```php
$server = new Swoole\Server("127.0.0.1", 9501);
$server->on('connect', function ($server, $fd){
    echo "Client:Connect.\n";
});
$server->on('receive', function ($server, $fd, $reactor_id, $data) {
    $server->send($fd, 'Swoole: '.$data);
    $server->close($fd);
});
$server->on('close', function ($server, $fd) {
    echo "Client: Close.\n";
});
$server->start();
```


## addListener()

Добавление 监听端口. В бизнес-коде можно получить информацию о том, из какого порта был установлен某个 соединение, используя метод [Swoole\Server->getClientInfo](/server/methods?id=getclientinfo).

```php
Swoole\Server->addListener(string $host, int $port, int $sockType): bool|Swoole\Server\Port
```

!> Для прослушивания портов ниже `1024` требуется `root` привилегия.  
Основной сервер работает по протоколу `WebSocket` или `HTTP`, новые TCP порты, на которые добавляется прослушивание, по умолчанию наследуют настройки протокола основного `Server`. Для активации нового протокола необходимо отдельно вызвать метод `set` и настроить новый протокол [смотрите подробное описание](/server/port).
Можно посмотреть подробное описание [Swoole\Server\Port](https://github.com/swoole/swoole-src/blob/master/docs/Server/Port.md). 

  * **Параметры**

    * `string $host`

      * Функция: та же, что и в `__construct()` `$host`
      * По умолчанию: та же, что и в `__construct()` `$host`
      * Другие значения: та же, что и в `__construct()` `$host`

    * `int $port`

      * Функция: та же, что и в `__construct()` `$port`
      * По умолчанию: та же, что и в `__construct()` `$port`
      * Другие значения: та же, что и в `__construct()` `$port`

    * `int $sockType`

      * Функция: та же, что и в `__construct()` `$sockType`
      * По умолчанию: та же, что и в `__construct()` `$sockType`
      * Другие значения: та же, что и в `__construct()` `$sockType`
  
  * **Возвращаемое значение**

    * Возвращает `Swoole\Server\Port`, что означает успешное выполнение операции, или `false` - неудачу операции.
!> - В режиме Unix socket параметр `$host` должен быть заполнен путьом к доступному каталогу, параметр `$port` игнорируется  

- В режиме Unix socket клиентское сокетное fd больше не будет числом, а строкой пути к файлу сокета  
- В системах Linux после прослушивания IPv6 порта можно использоватьIPv4 адрес для подключения


## listen()

Этот метод является синонимом для `addlistener`.

```php
Swoole\Server->listen(string $host, int $port, int $type): bool|Swoole\Server\Port
```


## addProcess()

Добавьте пользовательский рабочий процесс. Эта функция обычно используется для создания специального рабочего процесса,任务的 мониторинга, отчетности или других особых задач.

```php
Swoole\Server->addProcess(Swoole\Process $process): int
```

!> Не требуется запуск `start`. Когда `Server` запустится, он автоматически создает процессы и выполняет указанные функции дочерних процессов

  * **Параметры**
  
    * [Swoole\Process](/process/process)

      * Функция: объект Swoole\Process
      * По умолчанию: нет
      * Прочие значения: нет

  * **Возвращаемое значение**

    * Возвращает идентификационный номер процесса в случае успешного операции, в противном случае функция抛出 смертельный ошибочный запрос.

  * **Примечание**

    !> - Созданные дочерние процессы могут использовать различные методы предоставляемого объекта `$server`, такие как `getClientList/getClientInfo/stats`.                                     
    - В процессах Worker/Task можно использовать методы, предоставляемые `$process`, для общения с дочерними процессами.        
    - В пользовательских процессах можно использовать метод `$server->sendMessage` для общения с процессами Worker/Task.      
    - Внутри пользовательского процесса нельзя использовать интерфейсы `Server->task/taskwait`.              
    - Внутри пользовательского процесса можно использовать интерфейсы `Server->send/close`.         
    - Внутри пользовательского процесса следует использовать бесконечный цикл (например, создание таймера), как показано ниже, или **[EventLoop](/learn?id=что такоеeventloop)** (например, создание таймера), иначе пользовательский процесс будет постоянно завершаться и重新 lanzироваться.         

  * **Жизнь**

    ?> - Жизненный цикл пользовательского процесса такой же, как у `Master` и [Manager](/learn?id=manager процесс), он не подвержен влиянию команды [reload](/server/methods?id=reload).     
    - Пользовательский процесс не подвержен контролю команды `reload`, и при `reload` не поступают какие-либо сообщения в пользовательский процесс.        
    - При закрытии сервера с помощью команды `shutdown` будет отправлен сигнал `SIGTERM` пользователю процессу, чтобы закрыть его.            
    - Пользовательский процесс будет托管 к `Manager` процессу, и в случае возникновения смертельной ошибки `Manager` Prozess создаст новый.         
    - Пользовательский процесс также не будет вызвать события, такие как `onWorkerStop`. 

  * **Пример**

    ```php
    $server = new Swoole\Server('127.0.0.1', 9501);
    
    /**
     * Пользовательский процесс реализует функцию вещания,收件ает сообщения через unixSocket в цикле и пересылает все они всем связанным с сервером соединениям
     */
    $process = new Swoole\Process(function ($process) use ($server) {
        $socket = $process->exportSocket();
        while (true) {
            $msg = $socket->recv();
            foreach ($server->connections as $conn) {
                $server->send($conn, $msg);
            }
        }
    }, false, 2, 1);
    
    $server->addProcess($process);
    
    $server->on('receive', function ($serv, $fd, $reactor_id, $data) use ($process) {
        // Отправка сообщений всем клиентам
        $socket = $process->exportSocket();
        $socket->send($data);
    });
    
    $server->start();
    ```

    Смотрите раздел о [процессах межпроцессного общения](/process/process?id=exportsocket).


## start()

Запустить сервер,监听 все `TCP/UDP` порты.

```php
Swoole\Server->start(): bool
```

!> Напоминание: ниже приведен пример в режиме [SWOOLE_PROCESS](/learn?id=swoole_process)

  * **Напоминание**

    - После успешного запуска будет создано `worker_num+2` процессов. `Master` процесс + `Manager` процесс + `serv->worker_num` рабочих процессов.  
    - Если запуск неудачен, он немедленно вернет `false`.
    - После успешного запуска будет запущена 事件ная петля, ожидающаяrequests от клиентов. Code после метода `start` не будет выполнен.  
    - После закрытия сервера функция `start` вернет `true` и продолжит выполнения вниз по течению.  
    - Если установлено значение `task_worker_num`, количество соответствующих [Taskprocesses](/learn?id=taskworker процесс) увеличится.   
    - Методы до `start` в списке могут быть использованы только до вызова `start`, методы после `start` могут быть использованы только в обратных функциях событий, таких как [onWorkerStart](/server/events?id=onworkerstart), [onReceive](/server/events?id=onreceive) и т.д.

  * **Расширение**
  
    * Master главный процесс

      * Внутри главного процесса есть несколько [Reactor](/learn?id=reactor线程) нитей, которые используют `epoll/kqueue/select` для ротационной проверки сетевых событий. После получения данных они пересылаются рабочим процессам для обработки.
    
    * Manager процесс

      * Управление всеми рабочими процессами, рабочие процессы автоматически récupерируются и создаваются заново после окончания их жизненного цикла или возникновения исключений.
    
    * Рабочий процесс

      * Обработка полученных данных, включая декодирование протоколов и ответ на запросы. Если не установлено значение `worker_num`, то будет запущено столько же рабочих процессов, сколько CPU.
      * В случае неудачного запуска расширение выбрасывает смертельный ошибочный запрос, пожалуйста, проверьте соответствующую информацию в `php error_log`. `errno={number}` - это стандартный `Linux Errno`, который можно referencing к соответствующим документам.
      * Если установлена настройка `log_file`, информация будет выведена в указанный `Log` файл.

  * **Возвращаемое значение**

    * Возвращает `true`, если операция выполнена успешно, возвращает `false`, если операция выполнена неудачно
       
  * **Случайные ошибки при запуске**

    * Невозможно привязать порт, потому что другой процесс уже занимает этот порт.
    * Не определена необходимая обратная функция, запуск завершается неудачей.
    * В PHP коде есть смертельная ошибка, пожалуйста, проверьте информацию о ошибках PHP `php_errors.log`.
    * Выполните команду `ulimit -c unlimited`, откройте `core dump`, чтобыeriksa наличие segmentation fault.
    - Откройте `daemonize`, отключите `log`, чтобы сообщения об ошибках могли быть выведены на экран.


## reload()

Безопасно перезапустить все рабочие/задачные процессы.

```php
Swoole\Server->reload(bool $only_reload_taskworker = false): bool
```

!> Например: Если у和后端 сервера, который всегда обрабатывает запросы, управляющий administrатор убил процесс командой `kill` для завершения/перезапуска программы сервера, это может привести к тому, что код будет прерван恰好 в середине выполнения.  
В таких случаях может возникнуть несогласованность данных. Например, в системе платежей следующая часть логики - отправка товара, предположим, что после логики оплаты процесс завершается и进程 убивается. Это приведет к тому, что пользователь оплачивает деньги, но товар не отправляется, что приводит к очень серьезным последствиям.  
Swoole предоставляет гибкий механизм завершения/перезапуска, и администратору достаточно отправить определенному сигнал серверу, чтобы рабочие процессы Server могли безопасно завершить работу. Смотрите [как правильно перезапустить обслуживание](/question/use?id=swoole как правильно перезапустить обслуживание).

  * **Параметры**
  
    * `bool $only_reload_taskworker`

      * Функция: следует ли перезапустить только [задачные процессы](/learn?id=taskworker процесс).
      * По умолчанию: нет
      * Прочие значения: да


!> - перезапуск с защитой, если происходит перезапуск, то при получении нового сигнала перезапуска старый будет брошен.

- Если установлены `$user/group`, рабочие процессы могут не иметь привилегий отправлять информацию в главный процесс, в таких случаях необходимо использовать аккаунт `root`, чтобы в оболочке выполнить команду `kill` для перезапуска.
- Команда reload не действует на пользовательские процессы, добавленные с помощью метода [addProcess](/server/methods?id=addProcess), они не будут перераспределены во время выполнения команды reload.

  * **Возвращаемое значение**

    * Возвращает `true` в случае успешного выполнения операции, возвращает `false` в случае неудачи.

  * **Расширение**
  
    * **Отправление сигнала**
    
        * `SIGTERM`: отправьте этот сигнал главному процессу/администрированию, и сервер будет безопасно остановлен.
        В PHP-коде можно вызвать метод `$serv->shutdown()` для выполнения этой операции.
        * `SIGUSR1`: отправьте сигнал `SIGUSR1` главному процессу/администрированию, чтобы безопасно перезапустить все рабочие процессы и задачные рабочие процессы.
        * `SIGUSR2`: отправьте сигнал `SIGUSR2` главному процессу/администрированию, чтобы безопасно перезапустить все задачи.
        В PHP-коде можно вызвать метод `$serv->reload()` для выполнения этой операции.
        
    ```shell
    # Перезапустить все рабочие процессы
    kill -USR1 главный процесс PID
    
    # Только перезапустить задачи
    kill -USR2 главный процесс PID
    ```
      
      > [Смотрите: Список сигналов Linux](/other/signal)

    * **Процессный режим**
    
        В процессе, запущенном в режиме Process, TCP-соединения от клиентов поддерживаются внутри главного процесса, перезапуск рабочих процессов и необычное завершение не влияют на соединения.

    * **Базовый режим**
    
        В базовом режиме соединения с клиентами напрямую поддерживаются внутри рабочих процессов, поэтому при reload все соединения будут прераны.

    !> В базовом режиме не поддерживается reload [задачных процессов](/learn?id=taskworker процесс).
    
    * **Применение reload**

      Операция reload может перезапустить только те PHP-файлы, которые были загружены после запуска рабочего процесса. Используйте функцию `get_included_files` для получения списка файлов, которые были загружены до `WorkerStart`. PHP-файлы, указанные в этом списке, не могут быть перезапущены даже после выполнения операции reload. Для их перезагрузки необходимо закрыть и переосмыслить весь сервер.

    ```php
    $serv->on('WorkerStart', function(Swoole\Server $server, int $workerId) {
        var_dump(get_included_files()); //Файлы этого массива были загружены до запуска процесса, поэтому reload им нельзя
    });
    ```

    * **APC/OPcache**
    
        Если в PHP включен APC/OPcache, то перезагрузка может быть повлияна, есть 2 решения.
        
        * Откройте `stat` для APC/OPcache, и если обнаружите обновление файла, APC/OPcache автоматически обновит `OPCode`.
        * Перед тем как в `onWorkerStart`加载 файлы (функции require, include и т.д.), выполните `apc_clear_cache` или `opcache_reset`, чтобы очистить кэш `OPCode`.

  * **Примечание**

    !> - Безопасное возобновление применимо только к PHP-файлам, включенным и必需的 в рабочих процессах с помощью `/server/events?id=onworkerstart` или `/server/events?id=onreceive`.
    - PHP-файлы, включенные и必需的 перед запуском сервера `Server`, не могут быть перезагружены путем безопасного возобновления.
    - Для перезагрузки настроек сервера, то есть параметров, переданных в `Server` с помощью `$serv->set()`, необходимо закрыть/перезапустить весь `Server` для перезагрузки.
    - `Server` может слушать внутренний сетевой порт и затем принимать командные команды от remoto человека для перезапуска всех рабочих процессов.
## stop()

Остановить текущий процесс `Worker` и немедленно вызвать обратный вызов функции `onWorkerStop`.

```php
Swoole\Server->stop(int $workerId = -1, bool $waitEvent = false): bool
```

  * **Параметры**

    * `int $workerId`

      * Функция: указать `worker id`
      * По умолчанию: -1, означает текущий процесс
      * Другие значения: нет

    * `bool $waitEvent`

      * Функция: контролировать политику выхода, `false` означает немедленный выход, `true` означает ожидание, пока цикл событий не станет пустым, затем выход
      * По умолчанию: false
      * Другие значения: true

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, возвращает `false`, если операция失败

  * **Примечание**

    !> -[Асинхронный IO](/learn?id=syncioasynchronousio) сервер при вызове `stop` для остановки процесса может все еще иметь события в ожидании. Например, если используется `Swoole\MySQL->query`, отправлен `SQL` запрос, но все еще ждет возврата результатов от `MySQL` сервера. В этом случае, если процесс принудительно остановится, результаты выполнения `SQL` будут потеряны.  
    - При设置为 `$waitEvent = true` под了一层 будет использовать стратегию безопасного перезапуска [асинхронно](/question/use?id=swoole как правильно перезапустить сервис). Сначала уведомить `Manager` процесс, перезапустить новый `Worker` для обработки новых запросов. Текущий старый `Worker` будет ждать событий, пока цикл событий не станет пустым или превысит `max_wait_time`, затем выйти из процесса, максимально обеспечивая безопасность асинхронных событий.


## shutdown()

Завершить обслуживание.

```php
Swoole\Server->shutdown(): bool
```

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, возвращает `false`, если операция失败

  * **Примечание**

    * Эта функция может использоваться внутри `Worker` процесса.
    * Отправка `SIGTERM` главному процессу также может быть использована для завершения обслуживания.

```shell
kill -15 главному процессу PID
```


## tick()

Добавьте таймер `tick`, можно настроить пользовательскую обратную функцию. Эта функция является алиасом для [Swoole\Timer::tick](/timer?id=tick).

```php
Swoole\Server->tick(int $millisecond, callable $callback): void
```

  * **Параметры**

    * `int $millisecond`

      * Функция: интервал времени 【миллисекунды】
      * По умолчанию: нет
      * Другие значения: нет

    * `callable $callback`

      * Функция: обратная функция
      * По умолчанию: нет
      * Другие значения: нет

  * **Примечание**
  
    !> -После завершения работы `Worker` процесса все таймеры будут автоматически уничтожены  
    -Таймеры `tick/after` не могут использоваться до `Server->start`  
    -После `Swoole5` этот способ использования алиаса был удален, пожалуйста, используйте напрямую `Swoole\Timer::tick()`

  * **Пример**

    * Использование в [onReceive](/server/events?id=onreceive)

    ```php
    function onReceive(Swoole\Server $server, int $fd, int $reactorId, mixed $data)
    {
        $server->tick(1000, function () use ($server, $fd) {
            $server->send($fd, "hello world");
        });
    }
    ```

    * Использование в [onWorkerStart](/server/events?id=onworkerstart)

    ```php
    function onWorkerStart(Swoole\Server $server, int $workerId)
    {
        if (!$server->taskworker) {
            $server->tick(1000, function ($id) {
              var_dump($id);
            });
        } else {
            //task
            $server->tick(1000);
        }
    }
    ```


## after()

Добавьте одноразовый таймер, который будет уничтожен после выполнения. Эта функция является алиасом для [Swoole\Timer::after](/timer?id=after).

```php
Swoole\Server->after(int $millisecond, callable $callback)
```

  * **Параметры**

    * `int $millisecond`

      * Функция: время выполнения 【миллисекунды】
      * По умолчанию: нет
      * Другие значения: нет
      * Версия влияния: в версиях ниже `Swoole v4.2.10` максимальное значение не должно превышать `86400000`

    * `callable $callback`

      * Функция: обратная функция, должна быть callable, `callback` функция не принимает никаких параметров
      * По умолчанию: нет
      * Другие значения: нет

  * **Примечание**
  
    !> -Жизнь таймера на уровне процесса, когда используется `reload` или `kill` для перезапуска и закрытия процесса, все таймеры будут полностью уничтожены  
    -Если некоторые таймеры содержат ключевую логику и данные, пожалуйста, реализуйте это в обратной функции `onWorkerStop`, или обратитесь к [как правильно перезапустить сервис](/question/use?id=swoole как правильно перезапустить сервис)  
    -После `Swoole5` этот способ использования алиаса был удален, пожалуйста, используйте напрямую `Swoole\Timer::after()`


## defer()

Отложить выполнение функции, это алиас для [Swoole\Event::defer](/event?id=defer).

```php
Swoole\Server->defer(Callable $callback): void
```

  * **Параметры**

    * `Callable $callback`

      * Функция: обратная функция【обязательна】, может быть исполняемой функцией переменной, может быть строкой, массивом, анонимной функцией
      * По умолчанию: нет
      * Другие значения: нет

  * **Примечание**

    !> -Внутри будет выполнена эта функция после завершения [EventLoop](/learn?id=что такоеeventloop). Цель этой функции заключается в том, чтобы некоторые PHP-коды могли быть отложены для выполнения, а программное обеспечение приоритетно обрабатывало другие `IO` события. Например, если у какой-то обратной функции есть CPU-тяжелое вычисление и это не так срочно, можно позволить процессу обработать другие события, прежде чем начать CPU-тяжелое вычисление  
    -Внутри не гарантируется, что функция `defer` будет выполнена немедленно, если это ключевая логика системы и необходимо выполнить ее как можно скорее, пожалуйста, используйте таймер `after` для реализации  
    -При выполнении `defer` в обратной функции `onWorkerStart` необходимо дождаться возникновения события, прежде чем будет вызван обратный вызов
    -После `Swoole5` этот способ использования алиаса был удален, пожалуйста, используйте напрямую `Swoole\Event::defer()`

  * **Пример**

```php
function query($server, $db) {
    $server->defer(function() use ($db) {
        $db->close();
    });
}
```


## clearTimer()

Удалить таймер `tick/after`, эта функция является алиасом для [Swoole\Timer::clear](/timer?id=clear).

```php
Swoole\Server->clearTimer(int $timerId): bool
```

  * **Параметры**

    * `int $timerId`

      * Функция: указать идентификатор таймера
      * По умолчанию: нет
      * Другие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, возвращает `false`, если операция失败

  * **Примечание**

    !> -`clearTimer` может использоваться только для удаления таймеров текущего процесса     
    -После `Swoole5` этот способ использования алиаса был удален, пожалуйста, используйте напрямую `Swoole\Timer::clear()` 

  * **Пример**

```php
$timerId = $server->tick(1000, function ($timerId) use ($server) {
    $server->clearTimer($timerId);//$id - идентификатор таймера
});
```


## close()

Завершить соединение с клиентом.

```php
Swoole\Server->close(int $fd, bool $reset = false): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: указать `fd` (файловый дескриптор), который следует закрыть
      * По умолчанию: нет
      * Другие значения: нет

    * `bool $reset`

      * Функция: установите `true`, чтобы принудительно закрыть соединение, отбросить данные из очереди отправки
      * По умолчанию: `false`
      * Другие значения: `true`

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, возвращает `false`, если операция失败

  * **Примечание**
  !> -`Сервер` активно закрывает соединение, это также активирует событие [onClose](/server/events?id=onclose)  

- Не пишите логику очистки после `close`. Она должна быть размещена в обратном вызове [onClose](/server/events?id=onclose) для обработки  

- `fd` `HTTP\Server` получается в верхнем уровневом обратном методе `response`

  * **Пример**

```php
$server->on('request', function ($request, $response) use ($server) {
    $server->close($response->fd);
});
```


## send()

Отправка данных клиенту.

```php
Swoole\Server->send(int|string $fd, string $data, int $serverSocket = -1): bool
```

  * **Параметры**

    * `int|string $fd`

      * Функция: указывает файловый дескриптор клиента или путь к unix socket
      * По умолчанию: нет
      * Другие значения: нет

    * `string $data`

      * Функция: отправляемые данные, максимальное значение для `TCP` протокола составляет `2M`, можно изменить [buffer_output_size](/server/setting?id=buffer_output_size) для изменения максимально допустимой длины отправляемого пакета
      * По умолчанию: нет
      * Другие значения: нет

    * `int $serverSocket`

      * Функция: требуется для отправки данных на противоположный конец [UnixSocket DGRAM](https://github.com/swoole/swoole-src/blob/master/examples/unixsock/dgram_server.php), TCP клиенты не должны его填写
      * По умолчанию: -1, означает текущий слушаемый udp порт
      * Другие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, возвращает `false`, если операция потерпела неудачу

  * **Примечание**

    !> Процесс отправки является асинхронным, на нижнем уровне автоматически слушается возможность написания, данные постепенно отправляются клиенту, то есть не после возврата `send` противоположный конец получает данные.

    * безопасность
      * Операция `send` атомарна, если несколько процессов одновременно вызывают `send` для отправки данных на одно и то же `TCP` соединение, данные не смешиваются

    * ограничения длины
      * Если необходимо отправить данные более `2M`, можно написать данные в временный файл, затем отправить их через интерфейс `sendfile`
      * Можно изменить ограничение длины отправки путем установки [buffer_output_size](/server/setting?id=buffer_output_size)
      * При отправке данных более `8K`, на нижнем уровне будет активирован общий память `Worker` процесса, требуется операции `Mutex->lock`

    * буфер
      * Когда буфер [unixSocket](/learn?id=что такое IPC) `Worker` процесса заполнен, отправка `8K` данных активирует временное хранение на диске
      * Если непрерывно отправлять большое количество данных одному и тому же клиенту, и клиент не успевает их принять, это может привести к засорению памяти буфера `Socket`, и Swoole на нижнем уровне немедленно вернет `false`, когда `false`, можно сохранить данные на диске, ждать, пока клиент接收ит уже отправленные данные, а затем отправить их снова

    * [Синхронизация](/coroutine?id=синхронизация)
      * При включении [send_yield](/server/setting?id=send_yield) в режиме синхронной работы `send` при полной нагрузке буфера автоматически замораживается, и когда часть данных прочитана противоположным концом, синхронизация возобновляется, и продолжается отправка данных.

    * [UnixSocket](/learn?id=что такое IPC)
      * При прослушивании порта [UnixSocket DGRAM](https://github.com/swoole/swoole-src/blob/master/examples/unixsock/dgram_server.php) можно использовать `send` для отправки данных на противоположный конец.

      ```php
      $server->on("packet", function (Swoole\Server $server, $data, $addr){
          $server->send($addr['address'], 'SUCCESS', $addr['server_socket']);
      });
      ```


## sendfile()

Отправка файла на соединение `TCP` клиента.

```php
Swoole\Server->sendfile(int $fd, string $filename, int $offset = 0, int $length = 0): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: указывает файловый дескриптор клиента
      * По умолчанию: нет
      * Другие значения: нет

    * `string $filename`

      * Функция: путь к отправляемому файлу, если файл отсутствует, функция вернет `false`
      * По умолчанию: нет
      * Другие значения: нет

    * `int $offset`

      * Функция: указывает смещение в файле, с которого следует начать отправку данных
      * По умолчанию: 0 【По умолчанию `0`, означает отправку данных с начала файла】
      * Другие значения: нет

    * `int $length`

      * Функция: указывает длину отправляемых данных
      * По умолчанию: размер файла
      * Другие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, возвращает `false`, если операция потерпела неудачу

  * **Примечание**

  !> Эта функция и `Server->send` оба отправляют данные клиенту, отличие в том, что данные `sendfile` исходят из указанного файла


## sendto()

Отправка `UDP` пакета任意 client `IP:PORT`.

```php
Swoole\Server->sendto(string $ip, int $port, string $data, int $serverSocket = -1): bool
```

  * **Параметры**

    * `string $ip`

      * Функция: указывает `ip` client
      * По умолчанию: нет
      * Другие значения: нет

      ?> `$ip` является строкой `IPv4` или `IPv6`, например, `192.168.1.102`. Если `IP` недействителен, будет возвращаться ошибка

    * `int $port`

      * Функция: указывает `port` client
      * По умолчанию: нет
      * Другие значения: нет

      ?> `$port` является сетевым портом от `1` до `65535`, если порт неверен, отправка потерпит неудачу

    * `string $data`

      * Функция: содержание данных для отправки, которое может быть текстом или двоичным содержимым
      * По умолчанию: нет
      * Другие значения: нет

    * `int $serverSocket`

      * Функция: указывает соответствующий порт `server_socket` для отправки пакетов данных 【можно получить в `ClientInfo` события `/server/events?id=onPacket`】
      * По умолчанию: -1, означает текущий слушаемый udp порт
      * Другие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, возвращает `false`, если операция потерпела неудачу

      ?> Сервер может одновременно слушать несколько `UDP` портов, смотрите [слушивание нескольких портов](/server/port), этот параметр может указывать, какой порт использовать для отправки пакетов

  * **Примечание**

  !> Необходимо слушать `UDP` порт, чтобы отправлять данные по `IPv4` адресу  
  Необходимо слушать `UDP6` порт, чтобы отправлять данные по `IPv6` адресу

  * **Пример**

```php
// Отправьте字符串 "hello world" на порт 9502 хоста с IP-адресом 220.181.57.216.
$server->sendto('220.181.57.216', 9502, "hello world");
// Отправьте UDP пакет на сервер IPv6
$server->sendto('2600:3c00::f03c:91ff:fe73:e98f', 9501, "hello world");
```


## sendwait()

Синхронно отправка данных клиенту.

```php
Swoole\Server->sendwait(int $fd, string $data): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: указывает файловый дескриптор клиента
      * По умолчанию: нет
      * Другие значения: нет

    * `string $data`

      * Функция: данные для отправки
      * По умолчанию: нет
      * Другие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, возвращает `false`, если операция потерпела неудачу

  * **Примечание**

    * В некоторых особых случаях `Сервер` должен непрерывно отправлять данные клиенту, а интерфейс отправки данных `Server->send` полностью асинхронен, массовая отправка данных может привести к засорению очереди отправки памяти.

    * Использование `Server->sendwait` может решить эту проблему, `Server->sendwait` будет ждать, пока соединение будет доступно для написания. Ожидание продолжится до завершения отправки данных.

  * **Примечание**

  !> `sendwait` в настоящее время может использоваться только в режиме [SWOOLE_BASE](/learn?id=swoole_base)  
  `sendwait` используется только для внутреннего или внутренней сети коммуникации, внешние соединения не должны использовать `sendwait`, и не следует использовать эту функцию, когда `enable_coroutine` установлен в `true` (по умолчанию включено), это может заблокировать другие корутины, и может использоваться только для синхронно блокирующихся серверов.
## отправка сообщения

Отправьте сообщение любому процессу `Worker` или [процессу Task](/learn?id=taskworkerпроцесс). Это можно сделать в неосновном процессе и управляющем процессе. Получивший сообщение процесс будет активировать событие `onPipeMessage`.

```php
Swoole\Server->sendMessage(mixed $message, int $workerId): bool
```

  * **Параметры**

    * `mixed $message`

      * Функция: содержание отправляемого сообщения, нет ограничений по длине, но если оно превышает `8K`, то будет создан временный файл в памяти
      * По умолчанию: нет
      * Прочие значения: нет

    * `int $workerId`

      * Функция: `ID` целевого процесса, диапазон см. в [$worker_id](/server/properties?id=worker_id)
      * По умолчанию: нет
      * Прочие значения: нет

  * **Примечания**

    * В процессе `Worker` вызов `sendMessage` является [асинхронным IO](/learn?id=синхронныйioасинхронныйio), сообщение сначала сохраняется в буфере, и когда оно может быть отправлено, это сообщение отправляется по [unixSocket](/learn?id=что такоеIPC)
    * В [процессах Task](/learn?id=taskworkerпроцесс) вызов `sendMessage` по умолчанию является [синхронным IO](/learn?id=синхронныйioасинхронныйio), но в некоторых случаях он автоматически превращается в асинхронный IO, см. [синхронный IO в асинхронный IO](/learn?id=синхронныйioвасинхронныйio)
    * В [процессах User](/server/methods?id=addprocess) вызов `sendMessage` такой же, как и в Task, по умолчанию синхронный и блокирующий, см. [синхронный IO в асинхронный IO](/learn?id=синхронныйioвасинхронныйio)

  * **Важное**


  !> - Если `sendMessage()` является [асинхронным IO](/learn?id=синхронныйioвасинхронныйio), и за какой-либо причиной противоположный процесс не принимает данные, ни в коем случае не продолжайте вызывать `sendMessage()`, это может привести к значительному потреблению памяти. Можно добавить механизм ответа, если противоположный процесс не отвечает, то暂停 вызов;  

- В `MacOS/FreeBSD` при размере более `2K` используется временный файл для хранения;  

- Для использования [sendMessage](/server/methods?id=sendMessage) необходимо зарегистрировать обратный вызов функции `onPipeMessage`;  
- Если установлен [task_ipc_mode](/server/setting?id=task_ipc_mode) = 3, то невозможно использовать [sendMessage](/server/methods?id=sendMessage) для отправки сообщений определенным процессам Task.

  * **Пример**

```php
$server = new Swoole\Server('0.0.0.0', 9501);

$server->set(array(
    'worker_num'      => 2,
    'task_worker_num' => 2,
));
$server->on('pipeMessage', function ($server, $src_worker_id, $data) {
    echo "#{$server->worker_id} message from #$src_worker_id: $data\n";
});
$server->on('task', function ($server, $task_id, $src_worker_id, $data) {
    var_dump($task_id, $src_worker_id, $data);
});
$server->on('finish', function ($server, $task_id, $data) {

});
$server->on('receive', function (Swoole\Server $server, $fd, $reactor_id, $data) {
    if (trim($data) == 'task') {
        $server->task("async task coming");
    } else {
        $worker_id = 1 - $server->worker_id;
        $server->sendMessage("hello task process", $worker_id);
    }
});

$server->start();
```


## существование()

Проверьте, существует ли соединение, соответствующее заданному `fd`.

```php
Swoole\Server->exist(int $fd): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: файловый дескриптор
      * По умолчанию: нет
      * Прочие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если существует, и `false`, если нет

  * **Примечания**
  
    * Этот интерфейс основан на совместной памяти, без каких-либо `IO` операций


## pauз()

Остановите прием данных.

```php
Swoole\Server->pause(int $fd): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: указание файла дескриптора
      * По умолчанию: нет
      * Прочие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если операция прошла успешно, и `false`, если unsuccessful

  * **Примечания**

    * После вызова этой функции соединение будет удалено из [EventLoop](/learn?id=что такоеeventloop) и больше не будет принимать данные от клиента.
    * Эта функция не влияет на обработку очереди отправки
    * Можно вызвать `pause` только в режиме `SWOOLE_PROCESS`, после чего, возможно, некоторые данные уже достигнут `Worker` процесса, поэтому все еще может быть активировано событие [onReceive](/server/events?id=onreceive)


## возобновление()

Восстановите прием данных. Используется в паре с методом `pause`.

```php
Swoole\Server->resume(int $fd): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: указание файла дескриптора
      * По умолчанию: нет
      * Прочие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если операция прошла успешно, и `false`, если unsuccessful

  * **Примечания**

    * После вызова этой функции соединение будет снова добавлено в [EventLoop](/learn?id=что такоеeventloop) и будет продолжать принимать данные от клиента


## getCallback()

Получить обратный вызов функции Server с указанным именем

```php
Swoole\Server->getCallback(string $event_name): \Closure|string|null|array
```

  * **Параметры**

    * `string $event_name`

      * Функция: имя события, не нужно добавлять `on`, не区分大小写
      * По умолчанию: нет
      * Прочие значения: см. [события](/server/events)

  * **Возвращаемое значение**

    * Если соответствующий обратный вызов функции существует, то возвращается `Closure` / `string` / `array` в зависимости от способа настройки обратного вызова функции [Four Ways to Set Callback Function](/learn?id=четыре способа установки обратного вызова функции)
    * Если соответствующий обратный вызов функции не существует, то возвращается `null`


## getClientInfo()

Получить информацию о подключении, также известная как `Swoole\Server->connection_info()`

```php
Swoole\Server->getClientInfo(int $fd, int $reactorId = -1, bool $ignoreError = false): false|array
```

  * **Параметры**

    * `int $fd`

      * Функция: указание файла дескриптора
      * По умолчанию: нет
      * Прочие значения: нет

    * `int $reactorId`

      * Функция: `ID`线程 [Reactor](/learn?id=reactorthread), который обслуживает соединение, в настоящее время он не выполняет никакой функции, он просто сохраняет совместимость API
      * По умолчанию: -1
      * Прочие значения: нет

    * `bool $ignoreError`

      * Функция: игнорировать ли ошибку, если установлено `true`, даже если соединение закрыто, будет возвращена информация о соединении, `false` означает, что если соединение закрыто, то вернется `false`
      * По умолчанию: false
      * Прочие значения: нет

  * **Примечания**

    * Клиентское сертификаты

      * Можно получить сертификат только в процессе, активированном с помощью [onConnect](/server/events?id=onconnect)
      * Формат сертификата `x509`, можно использовать функцию `openssl_x509_parse` для получения информации о сертификате

    * Когда используется [dispatch_mode](/server/setting?id=dispatch_mode) = 1/3 для настройки, учитывая эту стратегию распределения пакетов для безгосударственных услуг, когда соединение закрывается, соответствующая информация будет удалена непосредственно из памяти, поэтому `Server->getClientInfo` не сможет получить информацию о соответствующем соединении.

  * **Возвращаемое значение**

    * Если вызов потерпел неудачу, то возвращается `false`
    * Если вызов успешно, то возвращается `array` с информацией о клиенте

```php
$fd_info = $server->getClientInfo($fd);
var_dump($fd_info);

array(15) {
  ["server_port"]=>
  int(9501)
  ["server_fd"]=>
  int(4)
  ["socket_fd"]=>
  int(25)
  ["socket_type"]=>
  int(1)
  ["remote_port"]=>
  int(39136)
  ["remote_ip"]=>
  string(9) "127.0.0.1"
  ["reactor_id"]=>
  int(1)
  ["connect_time"]=>
  int(1677322106)
  ["last_time"]=>
  int(1677322106)
  ["last_recv_time"]=>
  float(1677322106.901918)
  ["last_send_time"]=>
  float(0)
  ["last_dispatch_time"]=>
  float(0)
  ["close_errno"]=>
  int(0)
  ["recv_queued_bytes"]=>
  int(78)
  ["send_queued_bytes"]=>
  int(0)
}
```
Параметры | Функция
---|---
server_port | Порт, на котором слушает сервер
server_fd | Фид сервера
socket_fd | Фид клиента
socket_type | Тип сокета
remote_port | Порт клиента
remote_ip | IP-адрес клиента
reactor_id | Из какого Reactor-треда пришел запрос
connect_time | Время подключения клиента к серверу, в секундах, установлено главным процессом
last_time | Время последнего приема данных, в секундах, установлено главным процессом
last_recv_time | Время последнего приема данных, в секундах, установлено главным процессом
last_send_time | Время последнего отправки данных, в секундах, установлено главным процессом
last_dispatch_time | Время, когда рабочий процесс получил данные
close_errno | Код ошибки при закрытии соединения, если соединение закрывалось необычно, close_errno не равен нулю, можно посмотреть список ошибок Linux
recv_queued_bytes | Количество данных, ожидающих обработки
send_queued_bytes | Количество данных, ожидающих отправки
websocket_status | [Опционально] Состояние WebSocket-соединения, если сервер является Swoole\WebSocket\Server, к этому信息服务 добавляется дополнительная информация
uid | [Опционально] Если используется bind для привязывания пользовательского ID, к этому信息服务 добавляется дополнительная информация
ssl_client_cert | [Опционально] Если используется SSL-туннель и клиент установил сертификат, к этому信息服务 добавляется дополнительная информация

## getClientList()

Проходит через все текущие соединения с клиентами `Server`, метод `Server::getClientList` основан на совместной памяти, нет `IOWait`, и скорость遍历 очень высока. Кроме того, `getClientList` возвращает все `TCP` соединения, а не только те, которые принадлежат текущему `Worker` процессу. алиас - `Swoole\Server->connection_list()`

```php
Swoole\Server->getClientList(int $start_fd = 0, int $pageSize = 10): false|array
```

  * **Параметры**

    * `int $start_fd`

      * Функция: Указать начальный `fd`
      * По умолчанию: 0
      * Прочие значения: нет

    * `int $pageSize`

      * Функция: Сколько записей за страницу взять, максимальное значение - `100`
      * По умолчанию: 10
      * Прочие значения: нет

  * **Возвращаемое значение**

    * Если вызов успешен, будет возвращен массив индексов числовых значений, элементы которого являются полученными `$fd`. массив будет упорядочен от минимального к максимальному. Последний `$fd` становится новым `start_fd` и снова используется для получения информации
    * Если вызов неудачен, возвращается `false`

  * **Примечания**

    * Рекомендуется использовать итератор [Server::$connections](/server/properties?id=connections) для обхода соединений
    * `getClientList` может использоваться только с `TCP` клиентами, для `UDP` серверов необходимо самостоятельно сохранять информацию о клиентах
    * В режиме [SWOOLE_BASE](/learn?id=swoole_base) можно получить информацию только о соединениях текущего процесса

  * **Пример**
  
```php
$start_fd = 0;
while (true) {
  $conn_list = $server->getClientList($start_fd, 10);
  if ($conn_list === false || count($conn_list) === 0) {
      echo "finish\n";
      break;
  }
  $start_fd = end($conn_list);
  var_dump($conn_list);
  foreach ($conn_list as $fd) {
      $server->send($fd, "broadcast");
  }
}
```


## bind()

Привязывает соединение к пользовательски определенному `UID`, можно установить [dispatch_mode](/server/setting?id=dispatch_mode)=5, чтобы использовать эту значение для `hash` фиксированного распределения. Это может обеспечить, что все соединения с определенным `UID` будут распределены в одном и том же `Worker` процессе.

```php
Swoole\Server->bind(int $fd, int $uid): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: Указать `fd` соединения
      * По умолчанию: нет
      * Прочие значения: нет

    * `int $uid`

      * Функция: Указать `UID`, который будет привязан, должен быть не нулевым числом
      * По умолчанию: нет
      * Прочие значения: максимальное значение `UID` не должно превышать `4294967295`, минимальное - не менее `-2147483648`

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешна, и `false`, если unsuccessful

  * **Примечания**

    * Можно использовать `$serv->getClientInfo($fd)` для просмотра значения привязанного `UID` соединения
    * В стандартном режиме работы [dispatch_mode](/server/setting?id=dispatch_mode)=2, `Server` распределяет данные соединений между разными `Worker` процессами на основе `socket fd`. Поскольку `fd` нестабильны, после reconnection клиента после обрыва, `fd` изменится, и данные этого клиента будут распределены между другими `Worker` процессами. После использования `bind` данные могут быть распределены на основе пользовательского `UID`. Даже после reconnection, данные TCP-соединений с одинаковым `UID` будут распределены в одном и том же `Worker` процессе.

    * Проблемы с временем

      * После подключения клиента к серверу и отправки нескольких пакетов подряд могут возникнуть проблемы со временем. Во время операции `bind` последующие пакеты могут уже быть `dispatched`, и эти пакеты все равно будут распределены между текущим процессом на основе `fd`. Только новые пакеты, полученные после `bind`, будут распределены на основе `UID`.
      * Поэтому, если использовать механизм `bind`, необходимо спроектировать握手-шаг в сетевом протоколе. После успешного подключения клиента, сначала отправляется запрос на handshake, затем клиент не должен отправлять никаких пакетов. После того как сервер `bind`ся и ответил, клиент может отправить новый запрос.

    * Переувеличение привязанности

      * В некоторых случаях бизнес-логика требует переувеличения привязанности соединения к `UID`. В таких случаях можно отключить соединение, затем снова установить TCP-соединение и провести handshake, чтобы привязать его к новому `UID`.

    * Привязанность к отрицательному `UID`

      * Если привязанный `UID` отрицательный, он будет преобразован в `32-bit Unsigned Integer` на нижнем уровне, а PHP-уровень должен превратить его в `32-bit Signed Integer`, что можно сделать следующим образом:
      
  ```php
  $uid = -10;
  $server->bind($fd, $uid);
  $bindUid = $server->connection_info($fd)['uid'];
  $bindUid = $bindUid >> 31 ? (~($bindUid - 1) & 0xFFFFFFFF) * -1 : $bindUid;
  var_dump($bindUid === $uid);
  ```

  * **Примечание**


!> - Работает только при установленном `dispatch_mode=5`  

- Если `UID` не привязан, по умолчанию используется `fd` для распределения  
- Одна и та же связь может быть привязана только один раз, если она уже привязана к `UID`, последующий вызов `bind` вернет `false`

  * **Пример**

```php
$serv = new Swoole\Server('0.0.0.0', 9501);

$serv->fdlist = [];

$serv->set([
    'worker_num' => 4,
    'dispatch_mode' => 5,   //uid dispatch
]);

$serv->on('connect', function ($serv, $fd, $reactor_id) {
    echo "{$fd} connect, worker:" . $serv->worker_id . PHP_EOL;
});

$serv->on('receive', function (Swoole\Server $serv, $fd, $reactor_id, $data) {
    $conn = $serv->connection_info($fd);
    print_r($conn);
    echo "worker_id: " . $serv->worker_id . PHP_EOL;
    if (empty($conn['uid'])) {
        $uid = $fd + 1;
        if ($serv->bind($fd, $uid)) {
            $serv->send($fd, "bind {$uid} success");
        }
    } else {
        if (!isset($serv->fdlist[$fd])) {
            $serv->fdlist[$fd] = $conn['uid'];
        }
        print_r($serv->fdlist);
        foreach ($serv->fdlist as $_fd => $uid) {
            $serv->send($_fd, "{$fd} say:" . $data);
        }
    }
});

$serv->on('close', function ($serv, $fd, $reactor_id) {
    echo "{$fd} Close". PHP_EOL;
    unset($serv->fdlist[$fd]);
});

$serv->start();
```
## stats()

Получить информацию о текущем числе активных `TCP` подключений к `Server`, времени запуска и другие данные, а также общее количество `accept/close` (установление соединения/закрытие соединения) и т.д.

```php
Swoole\Server->stats(): array
```

  * **Пример**

```php
array(25) {
  ["start_time"]=>
  int(1677310656)
  ["connection_num"]=>
  int(1)
  ["abort_count"]=>
  int(0)
  ["accept_count"]=>
  int(1)
  ["close_count"]=>
  int(0)
  ["worker_num"]=>
  int(2)
  ["task_worker_num"]=>
  int(4)
  ["user_worker_num"]=>
  int(0)
  ["idle_worker_num"]=>
  int(1)
  ["dispatch_count"]=>
  int(1)
  ["request_count"]=>
  int(0)
  ["response_count"]=>
  int(1)
  ["total_recv_bytes"]=>
  int(78)
  ["total_send_bytes"]=>
  int(165)
  ["pipe_packet_msg_id"]=>
  int(3)
  ["session_round"]=>
  int(1)
  ["min_fd"]=>
  int(4)
  ["max_fd"]=>
  int(25)
  ["worker_request_count"]=>
  int(0)
  ["worker_response_count"]=>
  int(1)
  ["worker_dispatch_count"]=>
  int(1)
  ["task_idle_worker_num"]=>
  int(4)
  ["tasking_num"]=>
  int(0)
  ["coroutine_num"]=>
  int(1)
  ["coroutine_peek_num"]=>
  int(1)
  ["task_queue_num"]=>
  int(1)
  ["task_queue_bytes"]=>
  int(1)
}
```


Параметры | Функция
---|---
start_time | Время запуска сервера
connection_num | Текущее количество подключений
abort_count | Количество отказанных подключений
accept_count | Количество принятых подключений
close_count | Количество закрытых подключений
worker_num  | Количество запущенных worker процессов
task_worker_num  | Количество запущенных task_worker процессов【`v4.5.7` доступно】
user_worker_num  | Количество запущенных task worker процессов
idle_worker_num | Количество свободных worker процессов
dispatch_count | Количество пакетов, отправленных Server на Worker【`v4.5.7` доступно, только в режиме [SWOOLE_PROCESS](/learn?id=swoole_process)】
request_count | Количество полученных Server запросов【считаются только запросы на onReceive, onMessage, onRequset, onPacket】
response_count | Количество отправленных Server ответов
total_recv_bytes| Общее количество полученных данных
total_send_bytes | Общее количество отправленных данных
pipe_packet_msg_id | ID межпроцессного общения
session_round | Начальный session ID
min_fd | Минимальный файловый descriptor соединения
max_fd | Максимальный файловый descriptor соединения
worker_request_count | Количество полученных текущими Worker процессами запросов【если worker_request_count превышает max_request, рабочий процесс будет завершен】
worker_response_count | Количество ответов текущими Worker процессами
worker_dispatch_count | Количество задач, переданных master процессу текущему Worker процессу, увеличивается приDispatched в [master процессе](/learn?id=reactor线程)
task_idle_worker_num | Количество свободных task процессов
tasking_num | Количество работающих task процессов
coroutine_num | Текущее количество корутин【для Coroutine】,获取更多 информации смотрите [эту раздел](/coroutine/gdb)
coroutine_peek_num | Общее количество корутин
task_queue_num | Количество task в очереди сообщений【для Task】
task_queue_bytes | Объем памяти, занимаемый очереди сообщений【для Task】


## task()

Отправьте асинхронную задачу в пул `task_worker`. Эта функция не блокирует и немедленно возвращается после выполнения. `Worker` процессы могут продолжать обработку новых запросов. Для использования функции `Task` необходимо сначала настроить `task_worker_num`, а также установить回调 функции событий [onTask](/server/events?id=ontask) и [onFinish](/server/events?id=onfinish) для `Server`.

```php
Swoole\Server->task(mixed $data, int $dstWorkerId = -1, callable $finishCallback): int
```

  * **Параметры**

    * `mixed $data`

      * Функция: данные задачи, которые необходимо отправить, должны быть сериализируемыми PHP переменными
      * По умолчанию: нет
      * Другие значения: нет

    * `int $dstWorkerId`

      * Функция: можно указать, к какому [Task процессу](/learn?id=taskworker进程) отправить задачу, просто укажите `ID` Task процесса, диапазон `[0, $server->setting['task_worker_num']-1]`
      * По умолчанию: `-1`【по умолчанию `-1`, что означает случайное отправление, и на уровне будет автоматически выбран свободный [Task процесс](/learn?id=taskworker进程)】
      * Другие значения: `[0, $server->setting['task_worker_num']-1]`

    * `callable $finishCallback`

      * Функция:回调 функция `finish`, если для задачи установлена回调 функция, то когда `Task` вернет результат, будет немедленно вызвана указанная回调 функция, и не будет вызвана回调 функция `Server` [onFinish](/server/events?id=onfinish), она может быть вызвана только если задача отправлена в `Worker` процессе
      * По умолчанию: `null`
      * Другие значения: нет

  * **Возвращаемое значение**

    * Если вызов успешен, возвращается целое число `$task_id`, представляющее `ID` этой задачи. Если установлена回调 функция `finish`, в回调е [onFinish](/server/events?id=onfinish) будет передан параметр `$task_id`
    * Если вызов неудачен, возвращается `false`, и `$task_id` может быть `0`, поэтому необходимо использовать `===` для определения неудачи

  * **Примечания**

    * Эта функция используется для асинхронного выполнения медленных задач, например, для чата-сервера, где можно использовать его для отправки широковещаний. Когда задача завершена, в [task процессе](/learn?id=taskworker进程) можно вызвать `$serv->finish("finish")` чтобы сообщить `worker` процессу, что эта задача завершена. Конечно, `Swoole\Server->finish` - это опция.
    * `task` на основе использования [unixSocket](/learn?id=что такое IPC) для коммуникации, полностью в памяти, без `IO` потребления. Один процесс может читать и писать с скоростью до `1 миллион/с`, разные процессы используют разные `unixSocket` для коммуникации, что позволяет максимально использовать многоядерный процессор.
    * Если не указать целевой [Task процесс](/learn?id=taskworker进程), метод `task` будет определять состояние занятости [Task процессов](/learn?id=taskworker进程), и на уровне будут доставляться задачи только в свободные [Task процессы](/learn?id=taskworker进程). Если все [Task процессы](/learn?id=taskworker进程) заняты, на уровне будет происходить чередование задач между процессами. Можно использовать метод [server->stats](/server/methods?id=stats) для получения текущего количества задач в очереди.
    * Третий параметр позволяет напрямую установить функцию [onFinish](/server/events?id=onfinish). Если для задачи установлена回调 функция, то когда `Task` вернет результат, будет немедленно вызвана указанная回调 функция, и не будет вызвана回调 функция `Server` [onFinish](/server/events?id=onfinish), она может быть вызвана только если задача отправлена в `Worker` процессе

    ```php
    $server->task($data, -1, function (Swoole\Server $server, $task_id, $data) {
        echo "Task Callback: ";
        var_dump($task_id, $data);
    });
    ```

    * `$task_id` - это целое число от `0` до `4294967295`, уникальное в текущем процессе
    * По умолчанию функция `task` не активирована, необходимо вручную настроить `task_worker_num` для ее включения
    * Количество `TaskWorker` регулируется в параметрах [Server->set()](/server/methods?id=set), например, `task_worker_num => 64`, означает запуск `64` процессов для приема асинхронных задач

  * **Конфигурационные параметры**

    * `Server->task/taskwait/finish` три метода активируют использование временных файлов для хранения при передаче данных `$data`, превышающих `8K`. Когда содержание временного файла превышает
    [server->package_max_length](/server/setting?id=package_max_length), на уровне будет вы抛出 предупреждение. Это предупреждение не влияет на передачу данных, слишком большие `Task` могут иметь проблемы с производительность.
    
    ```shell
    WARN: task package is too big.
    ```

  * **Односторонняя задача**

    * Задания, отправленные из `Master`, `Manager`, `UserProcess` процессов, односторонние и не позволяют использовать методы `return` или `Server->finish()` в `TaskWorker` процессе для возврата результатов данных.

  * **Примечание**
  !> -`Метод`задача`не может быть вызван в процессе [задачник](/learn?id=taskworker процесс)  

-Использование `задачи` требует установки [onTask](/server/events?id=ontask) и [onFinish](/server/events?id=onfinish) обратных вызовов для `Сервера`, иначе `Сервер->start` потерпит неудачу  

- Количество операций `задачи` должно быть меньше скорости обработки [onTask](/server/events?id=ontask). Если объем задач превышает возможности обработки, данные `задачи` будут заполнять буфер, что приведет к блокировке процесса `Рабочего`. Процесс `Рабочего` не сможет принимать новые запросы  
- В пользовательских процессах, добавленных с помощью [addProcess](/server/method?id=addProcess), можно использовать `задачу` для односторонней отправки задач, но нельзя вернуть результаты данных. Пожалуйста, используйте интерфейс [sendMessage](/server/methods?id=sendMessage) для общения с процессами `Рабочий/Задача`

  * **Пример**

```php
$server = new Swoole\Server("127.0.0.1", 9501, SWOOLE_BASE);

$server->set(array(
    'worker_num'      => 2,
    'task_worker_num' => 4,
));

$server->on('Receive', function (Swoole\Server $server, $fd, $reactor_id, $data) {
    echo "Получено данные" . $data . "\n";
    $data    = trim($data);
    $server->task($data, -1, function (Swoole\Server $server, $task_id, $data) {
        echo "В callback задачи: ";
        var_dump($task_id, $data);
    });
    $task_id = $server->task($data, 0);
    $server->send($fd, "Задача распределена, ID задачи: $task_id\n");
});

$server->on('Task', function (Swoole\Server $server, $task_id, $reactor_id, $data) {
    echo "Процесс задачер получил данные";
    echo "#{$server->worker_id}\tonTask: [PID={$server->worker_pid}]: task_id=$task_id, длина данных=" . strlen($data) . "." . PHP_EOL;
    $server->finish($data);
});

$server->on('Finish', function (Swoole\Server $server, $task_id, $data) {
    echo "Задача#$task_id завершена, длина данных=" . strlen($data) . PHP_EOL;
});

$server->on('workerStart', function ($server, $worker_id) {
    global $argv;
    if ($worker_id >= $server->setting['worker_num']) {
        swoole_set_process_name("php {$argv[0]}: task_worker");
    } else {
        swoole_set_process_name("php {$argv[0]}: worker");
    }
});

$server->start();
```


## taskwait()

`taskwait` работает так же, как и метод `задача`, для отправки асинхронной задачи в [pool задач](/learn?id=taskworker процесс) для выполнения. В отличие от `задачи`, `taskwait` является синхронным и ждет, пока задача не будет завершена или время истечет. `$result` содержит результат выполнения задачи, который отправляется с помощью функции `$server->finish`. Если задача просрочена, здесь будет возвращено `false`.

```php
Swoole\Server->taskwait(mixed $data, float $timeout = 0.5, int $dstWorkerId = -1): mixed
```

  * **Параметры**

    * `mixed $data`

      * Функция: отправляемые данные задачи, могут быть любого типа, если тип не является строкой, то на нижнем уровне будет автоматически произведена сериализация
      * По умолчанию: нет
      * Другие значения: нет

    * `float $timeout`

      * Функция: время ожидания, числое значение в секундах, минимальное支持的 granularity `1ms`, если в течение установленного времени [Task процесс](/learn?id=taskworker процесс) не возвращает данные, `taskwait` вернет `false` и больше не будет обрабатываться результат задач
      * По умолчанию: 0.5
      * Другие значения: нет

    * `int $dstWorkerId`

      * Функция: указывает, к какому [Task процессу](/learn?id=taskworker процесс) отправить задачу, необходимо передать `ID` Task процесса, диапазон `[0, $server->setting['task_worker_num']-1]`
      * По умолчанию: -1【по умолчанию `-1` означает случайную отправку, на нижнем уровне автоматически выбирается свободное [Task процесс](/learn?id=taskworker процесс)】
      * Другие значения: `[0, $server->setting['task_worker_num']-1]`

  * **Возвращаемое значение**

      * Возвращение `false` означает неудачную отправку
      * Если в событии `onTask` был вызван метод `finish` или `return`, то `taskwait` вернет результат отправленной в `onTask`.

  * **Примечание**

    * **Синхронный режим**

      * Начиная с версии `4.0.4`, метод `taskwait` поддерживает [координацию задач](/coroutine?id=координация задач), и когда в координации задач вызывается `Server->taskwait()`, она будет автоматически [координирована](/coroutine?id=координация задач), и ожидание будет не блокирующим.
      * С помощью [координации задач](/coroutine?id=координация задач) `taskwait` может выполнять параллельные вызовы.
      * В событии `onTask` может быть только один `return` или один `Server->finish`, иначе после выполнения лишних `return` или `Server->finish` будет выведена предупреждение о том, что task[1] истек.

    * **Асинхронный режим**

      * В синхронном блокирующем режиме `taskwait` использует [UnixSocket](/learn?id=что такое IPC) для общения и совместное использование памяти, чтобы вернуть данные рабочему процессу, этот процесс синхронный и блокирующий.

    * **Особый случай**

      * Если в [onTask](/server/events?id=ontask) нет никаких [синхронных IO](/learn?id=синхронный io асинхронный io) операций, на нижнем уровне есть только два процесса переключения, и не возникает ожидание IO, поэтому в этом случае `taskwait` можно считать не блокирующим. Фактическое тестирование [onTask](/server/events?id=ontask), где читаются и пишутся только PHP массивы, показывает, что после 100 тысяч вызовов `taskwait`, общее время составляет всего 1 секунду, со средним временем выполнения 10 микросекунд

  * **Примечание**


  !> -Не используйте `Swoole\Server::finish`, не используйте `taskwait`  
- Метод `taskwait` не может быть вызван в [процесс задач](/learn?id=taskworker процесс)


## taskWaitMulti()

Параллельное выполнение нескольких асинхронных задач с помощью метода `задача`, этот метод не поддерживает [координацию задач](/coroutine?id=координация задач), что приведет к началу других координации, в условиях координации необходимо использовать следующий `taskCo`.

```php
Swoole\Server->taskWaitMulti(array $tasks, float $timeout = 0.5): false|array
```

  * **Параметры**

    * `array $tasks`

      * Функция: должен быть числовым индексным массивом, не поддерживается ассоциативный индексный массив, на нижнем уровне будет iterated `$tasks`, чтобы отправить задачи по одному в [Task процесс](/learn?id=taskworker процесс)
      * По умолчанию: нет
      * Другие значения: нет

    * `float $timeout`

      * Функция: числовое значение в секундах
      * По умолчанию: 0.5 секунды
      * Другие значения: нет

  * **Возвращаемое значение**

    * Если задачи завершены или истекло время, возвращается массив результатов. Порядок результатов в массиве соответствует `$tasks`, например, результат для `$tasks[2]` будет в `$result[2]`
    * Отложение выполнения какой-либо задачи не влияет на другие задачи, в возвращенных результатах данных не будут включены задачи, которые истекли во времени

  * **Примечание**

  !> - Максимальная параллельная количество задач не должна превышать `1024`

  * **Пример**

```php
$tasks[] = mt_rand(1000, 9999); // Задача 1
$tasks[] = mt_rand(1000, 9999); // Задача 2
$tasks[] = mt_rand(1000, 9999); // Задача 3
var_dump($tasks);

// Ожидание возвращения результатов всех задач, максимальное время ожидания 10 секунд
$results = $server->taskWaitMulti($tasks, 10.0);

if (!isset($results[0])) {
    echo "Задача 1 выполнилась с опозданием\n";
}
if (isset($results[1])) {
    echo "Результаты выполнения задачи 2: {$results[1]}\n";
}
if (isset($results[2])) {
    echo "Результаты выполнения задачи 3: {$results[2]}\n";
}
```
## taskCo()

Конкурентно выполнить `Task` и провести [координацию корутинов](/coroutine?id=координация_корутинов) для поддержки функции `taskWaitMulti` в контексте корутинов.

```php
Swoole\Server->taskCo(array $tasks, float $timeout = 0.5): false|array
```

* `$tasks` - список задач, должен быть массивом. В底层 будет пройдена по массиву, и каждый элемент будет отправлен в `Task` процессный пул как `task`
* `$timeout` - время ожидания, по умолчанию `0.5` секунды. Если задач не завершатся в назначенное время, они будут немедленно прераны и возвращены результаты
* Если задачи завершены или истекло время ожидания, будет возвращен массив результатов. Порядок результатов в массиве соответствует `$tasks`, например: результат `$tasks[2]` будет в `$result[2]`
* Если какая-либо задача терпит неудачу или истекает время ожидания, соответствующий элемент в массиве результатов будет `false`, например: если `$tasks[2]` потерпела неудачу, то значение `$result[2]` будет `false`

!> Максимальная并发任务不得超过`1024`  

  * **Процесс диспетчеризации**

    * Каждая задача в `$tasks` списка будет случайно отправлена на рабочий процесс `Task`, после отправки задача `yield` уступит контроль текущему корутину и установит таймер на `$timeout` секунд
    * В `onFinish` собираются результаты соответствующих задач и сохраняются в массиве результатов. Если не все задачи вернули результаты, продолжаем ждать. Если все - возобновляем выполнение соответствующих корутинов и очищаем таймер ожидания
    * Если задач не завершатся в назначенное время, таймер сработает первыми, и в底层 очищается состояние ожидания. Результаты незавершенных задач помечаются как `false`, и немедленно возобновляется выполнение соответствующих корутинов

  * **Пример**

```php
$server = new Swoole\Http\Server("127.0.0.1", 9502, SWOOLE_BASE);

$server->set([
    'worker_num'      => 1,
    'task_worker_num' => 2,
]);

$server->on('Task', function (Swoole\Server $serv, $task_id, $worker_id, $data) {
    echo "#{$serv->worker_id}\tonTask: worker_id={$worker_id}, task_id=$task_id\n";
    if ($serv->worker_id == 1) {
        sleep(1);
    }
    return $data;
});

$server->on('Request', function ($request, $response) use ($server) {
    $tasks[0] = "hello world";
    $tasks[1] = ['data' => 1234, 'code' => 200];
    $result   = $server->taskCo($tasks, 0.5);
    $response->end('Test End, Result: ' . var_export($result, true));
});

$server->start();
```


## finish()

Используется для уведомления `Worker` процесса в [Task процессе](/learn?id=taskworker процесс) о том, что отправленная задача завершена. Эта функция может передать результаты обработки задачи `Worker` процессу.

```php
Swoole\Server->finish(mixed $data): bool
```

  * **Параметры**

    * `mixed $data`

      * Функция: содержание результата обработки задачи
      * По умолчанию: нет
      * Другие значения: нет

  * **Возвращаемое значение**

    * Возвращает `true`, если операция прошла успешно, и `false`, если unsuccessful

  * **Примечание**
    * Метод `finish` может быть вызван несколько раз подряд, и `Worker` процесс будет несколько раз активирован событием [onFinish](/server/events?id=onfinish)
    * После вызова метода `finish` в обратном вызове [onTask](/server/events?id=ontask), данные `return` все равно вызовут событие [onFinish](/server/events?id=onfinish)
    * Метод `Server->finish` является необязательным. Если `Worker` процесс не интересуется результатом выполнения задачи, не нужно вызывать эту функцию
    * В обратном вызове [onTask](/server/events?id=ontask) если `return` строку, это эквивалентно вызову `finish`

  * **Наблюдение**

  !> Для использования функции `Server->finish` необходимо установить обратный вызов [onFinish](/server/events?id=onfinish) для `Server`. Этот метод может использоваться только в обратном вызове [onTask](/server/events?id=ontask) [Task процесса](/learn?id=taskworker процесс)


## heartbeat()

В отличие от пассивного обнаружения с помощью [heartbeat_check_interval](/server/setting?id=heartbeat_check_interval), этот метод активно проверяет все соединения на сервере и обнаруживает те, которые уже превысили установленное время. Если указано `if_close_connection`, то автоматически закроются соединения, которые просрочили время. Если не указано, то будет возвращен только массив `fd` соединений.

```php
Swoole\Server->heartbeat(bool $ifCloseConnection = true): bool|array
```

  * **Параметры**

    * `bool $ifCloseConnection`

      * Функция: закрывать ли соединения, которые просрочили время
      * По умолчанию: true
      * Другие значения: false

  * **Возвращаемое значение**

    * Если успешно вызван, вернет непрерывный массив, элементы которого являются закрытыми `$fd`
    * Если вызвана неудачно, вернет `false`

  * **Пример**

```php
$closeFdArrary = $server->heartbeat();
```


## getLastError()

Получить код ошибки последнего операции. В бизнес-коде можно выполнять различные логики в зависимости от типа ошибки.

```php
Swoole\Server->getLastError(): int
```

  * **Возвращаемое значение**


Код ошибки | Объяснение
---|---
1001 | Соединение уже было закрыто со стороны `Server`, эта ошибка обычно возникает, когда в коде уже был вызван `$server->close()` для закрытия определенного соединения, но все еще был вызван `$server->send()` для отправки данных на это соединение
1002 | Соединение было закрыто со стороны `Client`, `Socket` уже закрыт и невозможно отправить данные на противоположную сторону
1003 | В настоящее время выполняется `close`, в обратном вызове [onClose](/server/events?id=onclose) нельзя использовать `$server->send()`
1004 | Соединение закрыто
1005 | Соединение не существует,传入 `$fd` может быть ошибочным
1007 | Получена просроченная данные, после закрытия `TCP` соединения, возможно, часть данных останется в [unixSocket](/learn?id=что такое IPC) буфере, эта часть данных будет отброшена
1008 | Отправочный буфер已满 и невозможно выполнить операцию `send`, эта ошибка возникает, когда противоположная сторона соединения не может своевременно принимать данные, что приводит к переполнению отправочного буфера
1202 | Отправленные данные превышают [server->buffer_output_size](/server/setting?id=buffer_output_size)
9007 | Появляется только при использовании [dispatch_mode](/server/setting?id=dispatch_mode)=3, означает, что в настоящее время нет доступных процессов, можно увеличить количество процессов `worker_num`


## getSocket()

Вызвать этот метод можно получить доступ к основному `socket` хэндлеру, возвращаемый объект является ресурсом `sockets`.

```php
Swoole\Server->getSocket(): false|\Socket
```

!> Этот метод требует зависимости PHP расширения `sockets`, и при компиляции `Swoole` необходимо включить опцию `--enable-sockets`

  * **Слушание порта**

    * Порт, добавленный с помощью метода `listen`, может быть получен с помощью метода `getSocket` объекта `Swoole\Server\Port`.

    ```php
    $port = $server->listen('127.0.0.1', 9502, SWOOLE_SOCK_TCP);
    $socket = $port->getSocket();
    ```

    * С помощью функции `socket_set_option` можно установить более основные параметры `socket`.

    ```php
    $socket = $server->getSocket();
    if (!socket_set_option($socket, SOL_SOCKET, SO_REUSEADDR, 1)) {
        echo 'Не удалось установить опцию на сокете: '. socket_strerror(socket_last_error()) . PHP_EOL;
    }
    ```

  * **Поддержка мультикастинга**

    * Установка параметра `MCAST_JOIN_GROUP` с помощью функции `socket_set_option` позволяет присоединиться к мультикастинговой группе и слушать сетевые мультикастинговые пакеты.

```php
$server = new Swoole\Server('0.0.0.0', 9905, SWOOLE_BASE, SWOOLE_SOCK_UDP);
$server->set(['worker_num' => 1]);
$socket = $server->getSocket();

$ret = socket_set_option(
    $socket,
    IPPROTO_IP,
    MCAST_JOIN_GROUP,
    array(
        'group' => '224.10.20.30', // указывает адрес мультикастинга
        'interface' => 'eth0' // указывает имя сетевого интерфейса, которое может быть числом или строкой, например, eth0, wlan0
    )
);

if ($ret === false) {
    throw new RuntimeException('Не удалось присоединиться к мультикастинговой группе');
}

$server->on('Packet', function (Swoole\Server $server, $data, $addr) {
    $server->sendto($addr['address'], $addr['port'], "Swoole: $data");
    var_dump($addr, strlen($data));
});

$server->start();
```
## protect()

Установить защиту клиента, чтобы он не был отключен от线程 сердцебиения.

```php
Swoole\Server->protect(int $fd, bool $is_protected = true): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: Указать ID клиента $fd
      * По умолчанию: нет
      * Другие значения: нет

    * `bool $is_protected`

      * Функция: Установленный статус
      * По умолчанию: true 【означает защищенный статус】
      * Другие значения: false 【означает незащищенный】

  * **Возвращаемое значение**

    * Возвращает `true`, если операция успешно, и `false`, если unsuccessful


## confirm()

Подтвердить соединение, используется в сочетании с [enable_delay_receive](/server/setting?id=enable_delay_receive). Когда клиент устанавливает соединение, он не слушает события чтения, а только активирует回调 функции [onConnect](/server/events?id=onconnect). В回调е [onConnect](/server/events?id=onconnect) выполняется `confirm`, чтобы подтвердить соединение, после чего сервер начинает слушать события чтения и принимать данные от клиента.

!> Версия Swoole >= `v4.5.0` доступна

```php
Swoole\Server->confirm(int $fd): bool
```

  * **Параметры**

    * `int $fd`

      * Функция: уникальный идентификатор соединения
      * По умолчанию: нет
      * Другие значения: нет

  * **Возвращаемое значение**
  
    * Возвращает `true`, если подтверждение успешно
    * Возвращает `false`, если соединение с `$fd` не существует, уже закрыто или уже находится в состоянии прослушивания, подтверждение терпит неудачу

  * **Применение**
  
    Эта функция обычно используется для защиты сервера от атак с перегружением трафика. Когда收到 соединение от клиента, функция [onConnect](/server/events?id=onconnect) активируется, можно проверить источник `IP`, разрешить ли отправку данных на сервер.

  * **Пример**
    
```php
// Создание объекта Server, прослушивание на порту 127.0.0.1:9501
$serv = new Swoole\Server("127.0.0.1", 9501); 
$serv->set([
    'enable_delay_receive' => true,
]);

// Слушание события подключения
$serv->on('Connect', function ($serv, $fd) {  
    // Здесь проверяем этот $fd, если все в порядке, то подтверждаем
    $serv->confirm($fd);
});

// Слушание события приема данных
$serv->on('Receive', function ($serv, $fd, $reactor_id, $data) {
    $serv->send($fd, "Сервер: ".$data);
});

// Слушание события закрытия соединения
$serv->on('Close', function ($serv, $fd) {
    echo "Клиент: Закрытие.\n";
});

// Запуск сервера
$serv->start(); 
```


## getWorkerId()

Получить ID текущего `Worker` процесса (не PID процесса), который совпадает с `$workerId` во время [onWorkerStart](/server/events?id=onworkerstart)

```php
Swoole\Server->getWorkerId(): int|false
```

!> Версия Swoole >= `v4.5.0RC1` доступна


## getWorkerPid()

Получить PID указанного `Worker` процесса

```php
Swoole\Server->getWorkerPid(int $worker_id = -1): int|false
```

  * **Параметры**

    * `int $worker_id`

      * Функция: получить PID указанного процесса
      * По умолчанию: -1 【-1 обозначает текущий процесс】
      * Другие значения: нет

!> Версия Swoole >= `v4.5.0RC1` доступна


## getWorkerStatus()

Получить статус `Worker` процесса

```php
Swoole\Server->getWorkerStatus(int $worker_id = -1): int|false
```

!> Версия Swoole >= `v4.5.0RC1` доступна

  * **Параметры**

    * `int $worker_id`

      * Функция: получить статус процесса
      * По умолчанию: -1 【-1 обозначает текущий процесс】
      * Другие значения: нет

  * **Возвращаемое значение**
  
    * Возвращает статус `Worker` процесса, см. значения статуса процесса
    * Если не `Worker` процесс или процесс не существует, возвращает `false`

  * **Значения статуса процесса**

    Константа | Значение | Описание | Версия зависимости
    ---|---|---|---
    SWOOLE_WORKER_BUSY | 1 | Занят | v4.5.0RC1
    SWOOLE_WORKER_IDLE | 2 | Свободен | v4.5.0RC1
    SWOOLE_WORKER_EXIT | 3 | При включении [reload_async](/server/setting?id=reload_async) один и тот же `worker_id` может иметь два процесса, новый и старый, старый процесс получает статус código EXIT. | v4.5.5


## getManagerPid()

Получить PID текущего сервисного `Manager` процесса

```php
Swoole\Server->getManagerPid(): int
```

!> Версия Swoole >= `v4.5.0RC1` доступна


## getMasterPid()

Получить PID текущего сервисного `Master` процесса

```php
Swoole\Server->getMasterPid(): int
```

!> Версия Swoole >= `v4.5.0RC1` доступна


## addCommand()

Добавьте пользовательский командный `command`

```php
Swoole\Server->addCommand(string $name, int $accepted_process_types, Callable $callback): bool
```

!> - Версия Swoole >= `v4.8.0` доступна         
  - Эта функция может быть вызвана только до запуска сервера, если существует команда с таким же именем, она будет возвращать `false`

* **Параметры**

    * `string $name`

        * Функция: имя команды `command`
        * По умолчанию: нет
        * Другие значения: нет

    * `int $accepted_process_types`

      * Функция:接受的请求进程类型，如果想支持多种进程类型，可以使用`|`连接，例如`SWOOLE_SERVER_COMMAND_MASTER | SWOOLE_SERVER_COMMAND_MANAGER`
      * По умолчанию: нет
      * Другие значения:
        * `SWOOLE_SERVER_COMMAND_MASTER` master进程
        * `SWOOLE_SERVER_COMMAND_MANAGER` manager进程
        * `SWOOLE_SERVER_COMMAND_EVENT_WORKER` worker进程
        * `SWOOLE_SERVER_COMMAND_TASK_WORKER` task进程

    * `callable $callback`

        * Функция: обратный вызов функции, у нее два входных параметра, первый - класс `Swoole\Server`, второй - пользовательский переменный, который передается в четвертый параметр функции `Swoole\Server::command()`
        * По умолчанию: нет
        * Другие значения: нет

* **Возвращаемое значение**

    * Возвращает `true`, если пользовательская команда успешно добавлена, и `false`, если unsuccessful

## command()

Зовем пользовательскую команду `command`

```php
Swoole\Server->command(string $name, int $process_id, int $process_type, mixed $data, bool $json_decode = true): false|string|array
```

!> Версия Swoole >= `v4.8.0` доступна, в режимах `SWOOLE_PROCESS` и `SWOOLE_BASE` эта функция может использоваться только в `master` процессе.  


* **Параметры**

    * `string $name`

        * Функция: имя команды `command`
        * По умолчанию: нет
        * Другие значения: нет

    * `int $process_id`

        * Функция: ID процесса
        * По умолчанию: нет
        * Другие значения: нет

    * `int $process_type`

        * Функция: тип процесса запроса, следующие другие значения можно выбирать только один.
        * По умолчанию: нет
        * Другие значения:
          * `SWOOLE_SERVER_COMMAND_MASTER` master进程
          * `SWOOLE_SERVER_COMMAND_MANAGER` manager进程
          * `SWOOLE_SERVER_COMMAND_EVENT_WORKER` worker进程
          * `SWOOLE_SERVER_COMMAND_TASK_WORKER` task进程

    * `mixed $data`

        * Функция: данные запроса, эти данные должны быть сериализуемыми
        * По умолчанию: нет
        * Другие значения: нет

    * `bool $json_decode`

        * Функция: использовать ли `json_decode` для декодирования
        * По умолчанию: true
        * Другие значения: false
  
  * **Пример использования**
    ```php
    <?php
    use Swoole\Http\Server;
    use Swoole\Http\Request;
    use Swoole\Http\Response;

    $server = new Server('127.0.0.1', 9501, SWOOLE_BASE);
    $server->addCommand('test_getpid', SWOOLE_SERVER_COMMAND_MASTER | SWOOLE_SERVER_COMMAND_EVENT_WORKER,
        function ($server, $data) {
          var_dump($data);
          return json_encode(['pid' => posix_getpid()]);
        });
    $server->set([
        'log_file' => '/dev/null',
        'worker_num' => 2,
    ]);

    $server->on('start', function (Server $serv) {
        $result = $serv->command('test_getpid', 0, SWOOLE_SERVER_COMMAND_MASTER, ['type' => 'master']);
        Assert::eq($result['pid'], $serv->getMasterPid());
        $result = $serv->command('test_getpid', 1, SWOOLE_SERVER_COMMAND_EVENT_WORKER, ['type' => 'worker']);
        Assert::eq($result['pid'], $serv->getWorkerPid(1));
        $result = $serv->command('test_not_found', 1, SWOOLE_SERVER_COMMAND_EVENT_WORKER, ['type' => 'worker']);
        Assert::false($result);

        $serv->shutdown();
    });

    $server->on('request', function (Request $request, Response $response) {
    });
    $server->start();
    ```
