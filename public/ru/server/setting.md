# Конфигурация

Функция [Swoole\Server->set()](/server/methods?id=set) используется для установки различных параметров работы `Server`. Все подстраницы этого раздела являются элементами конфигурационного массива.

!> Начиная с версии [v4.5.5](/version/log?id=v455),底层 будет проверять правильность установленных параметров конфигурации, и если установлен параметр, который не предоставлен `Swoole`, то будет выведен Warning.

```shell
PHP Warning:  unsupported option [foo] in @swoole-src/library/core/Server/Helper.php 
```


### debug_mode

?> Установите режим日志ирования в `debug` дляDebuggング, который будет работать только если в процессе сборки был включен флаг `--enable-debug`.

```php
$server->set([
  'debug_mode' => true
])
```


### trace_flags

?> Установите метки для отслеживания журналов, чтобы печатать только часть отслеживающих журналов. `trace_flags` поддерживает использование `|` или операционного оператора для установки нескольких пунктов отслеживания. Это будет работать только если в процессе сборки был включен флаг `--enable-trace-log`.

Нижний уровень поддерживает следующие пункты отслеживания, которые можно использовать для отслеживания всех пунктов с помощью `SWOOLE_TRACE_ALL`:

* `SWOOLE_TRACE_SERVER`
* `SWOOLE_TRACE_CLIENT`
* `SWOOLE_TRACE_BUFFER`
* `SWOOLE_TRACE_CONN`
* `SWOOLE_TRACE_EVENT`
* `SWOOLE_TRACE_WORKER`
* `SWOOLE_TRACE_REACTOR`
* `SWOOLE_TRACE_PHP`
* `SWOOLE_TRACE_HTTP2`
* `SWOOLE_TRACE_EOF_PROTOCOL`
* `SWOOLE_TRACE_LENGTH_PROTOCOL`
* `SWOOLE_TRACE_CLOSE`
* `SWOOLE_TRACE_HTTP_CLIENT`
* `SWOOLE_TRACE_COROUTINE`
* `SWOOLE_TRACE_REDIS_CLIENT`
* `SWOOLE_TRACE_MYSQL_CLIENT`
* `SWOOLE_TRACE_AIO`
* `SWOOLE_TRACE_ALL`


### log_file

?> **Установите файл для ошибок `Swoole`**

?> Информация об исключениях, возникающих во время работы `Swoole`, будет записываться в этот файл, по умолчанию она будет выведена на экран. Когда активирован режим守护进程 `(daemonize => true)`, стандартный вывод будет перенаправлен на `log_file`. Содержание, которое печатается на экран в PHP-коде с помощью `echo/var_dump/print` и т.д., будет записываться в файл `log_file`.

  * **Примечание**

    * Журнал в `log_file` используется только для записи ошибок во время работы и не нуждается в длительном хранении.

    * **Номер журнала**

      ?> В информации о журнале перед процессом ID будут добавлены некоторые обозначения, указывающие тип потока/процесса, который создал журнал.

        * `#` Главный процесс
        * `$` Менеджер процесс
        * `*` Рабочий процесс
        * `^` Task процесс

    * **Перезапись журнала**

      ?> Если во время работы программы серверного процесса журналовый файл будет `mv` перемещен или `unlink` удален, информация о журнале не сможет быть нормально записана, в этот момент можно отправить сигнал `SIGRTMIN` серверу для перезаписи журнала.

      * Поддерживается только на `Linux` платформе
      * Не поддерживается для процессов [UserProcess](/server/methods?id=addProcess)

  * **Примечание**

    !> `log_file` не будет автоматически разделяться по файлам, поэтому необходимо регулярно очищать этот файл. Наблюдение за выходом `log_file` может помочь получить информацию об различных исключениях и предупреждениях сервера.


### log_level

?> **Установите уровень печати ошибок `Server`, диапазон от `0` до `6`. Журнал с уровнем ниже установленного `log_level` не будет выведен.**【По умолчанию: `SWOOLE_LOG_INFO`】

См. постоянные значения уровней в [Уровень журналов](/consts?id=日志等级)

  * **Примечание**

    !> `SWOOLE_LOG_DEBUG` и `SWOOLE_LOG_TRACE` доступны только в версиях, собранных с [--enable-debug-log](/environment?id=debug参数) и [--enable-trace-log](/environment?id=debug参数);  
    Когда активирован режим守护进程 `daemonize`, нижний уровень будет записывать все содержание, которое печатается на экран в программе, в [log_file](/server/setting?id=log_file), и это содержание не контролируется `log_level`.


### log_date_format

?> **Установите формат времени для журналов `Server`**, формат следует использовать согласно [strftime](https://www.php.net/manual/zh/function.strftime.php) `format`

```php
$server->set([
    'log_date_format' => '%Y-%m-%d %H:%M:%S',
]);
```


### log_date_with_microseconds

?> **Установите точность журналов `Server`, включать ли микросекунды**【По умолчанию: `false`】


### log_rotation

?> **Установите разделение журналов `Server`**【По умолчанию: `SWOOLE_LOG_ROTATION_SINGLE`】

| Константа                             | Описание   | Информация о версии |
| -------------------------------------- | ---------- | ------------------- |
| SWOOLE_LOG_ROTATION_SINGLE             | Не активировано | -                   |
| SWOOLE_LOG_ROTATION_MONTHLY            | ежемесячно | v4.5.8              |
| SWOOLE_LOG_ROTATION_DAILY              | Каждый день | v4.5.2              |
| SWOOLE_LOG_ROTATION_HOURLY             | Каждый час | v4.5.8              |
| SWOOLE_LOG_ROTATION_EVERY_MINUTE        | Каждый минутный | v4.5.8              |


### display_errors

?> Активировать / Выключить информацию об ошибках `Swoole`.

```php
$server->set([
  'display_errors' => true
])
```


### dns_server

?> Установите IP-адрес для запросов DNS.


### socket_dns_timeout

?> Время ожидания решения доменного имени, если на сервере активирован кластерный клиент с协程ами, этот параметр может контролировать время ожидания решения доменного имени клиента, в секундах.


### socket_connect_timeout

?> Время ожидания подключения клиента, если на сервере активирован кластерный клиент с协程ами, этот параметр может контролировать время ожидания подключения клиента, в секундах.


### socket_write_timeout / socket_send_timeout

?> Время ожидания написания данных клиентом, если на сервере активирован кластерный клиент с协程ами, этот параметр может контролировать время ожидания написания данных клиента, в секундах.   
Эта конфигурация также может использоваться для контроля времени ожидания выполнения `shell_exec` после `协程изации` или [Swoole\Coroutine\System::exec()](/coroutine/system?id=exec).   


### socket_read_timeout / socket_recv_timeout

?> Время ожидания чтения данных клиентом, если на сервере активирован кластерный клиент с协程ами, этот параметр может контролировать время ожидания чтения данных клиента, в секундах.


### max_coroutine / max_coro_num :id=max_coroutine

?> **Установите максимальное количество координационных процессов для текущего рабочего процесса.**【По умолчанию: `100000`, по умолчанию для версий Swoole младше `v4.4.0-beta` - `3000`】

?> Если количество координационных процессов превышает `max_coroutine`, нижний уровень не сможет создать новые координационные процессы, Swoole на сервере抛出ет ошибку `exceed max number of coroutine`, `TCP Server` закроет соединение, `Http Server` вернет HTTP-status 503.

?> На самом деле максимальное количество координационных процессов, которые можно создать в программе `Server`, равно `worker_num * max_coroutine`, количество координационных процессов для task-процессов и UserProcess-процессов учитывается отдельно.

```php
$server->set(array(
    'max_coroutine' => 3000,
));
```


### enable_deadlock_check

?> Активировать проверку заDeadlock координационных процессов.

```php
$server->set([
  'enable_deadlock_check' => true
]);
```


### hook_flags

?> **Установите диапазон функций для `односторонней координационной` Hook.**【По умолчанию: не hook】

!> Версия Swoole `v4.5+` или [4.4LTS](https://github.com/swoole/swoole-src/tree/v4.4.x) доступна, подробности смотрите в [односторонней координационной](/runtime)

```php
$server->set([
    'hook_flags' => SWOOLE_HOOK_SLEEP,
]);
```
Нижний уровень поддерживает следующие пункты координации, которые можно использовать для координации всех:

* `SWOOLE_HOOK_TCP`
* `SWOOLE_HOOK_UNIX`
* `SWOOLE_HOOK_UDP`
* `SWOOLE_HOOK_UDG`
* `SWOOLE_HOOK_SSL`
* `SWOOLE_HOOK_TLS`
* `SWOOLE_HOOK_SLEEP`
* `SWOOLE_HOOK_FILE`
* `SWOOLE_HOOK_STREAM_FUNCTION`
* `SWOOLE_HOOK_BLOCKING_FUNCTION`
* `SWOOLE_HOOK_PROC`
* `SWOOLE_HOOK_CURL`
* `SWOOLE_HOOK_NATIVE_CURL`
* `SWOOLE_HOOK_SOCKETS`
* `SWOOLE_HOOK_STDIO`
* `SWOOLE_HOOK_PDO_PGSQL`
* `SWOOLE_HOOK_PDO_ODBC`
* `SWOOLE_HOOK_PDO_ORACLE`
* `SWOOLE_HOOK_PDO_SQLITE`
* `SWOOLE_HOOK_ALL`
### enable_preemptive_scheduler

?>啟启用协程抢占式调度，以避免某个协程执行时间过长而导致其他协程饿死，协程的最大执行时间为`10ms`。

```php
$server->set([
  'enable_preemptive_scheduler' => true
]);
```

### c_stack_size / stack_size

?>设置单个协程初始 C 栈的内存尺寸，默认为 2M。

### aio_core_worker_num

?>设置`AIO`最小工作线程数，默认值为`cpu`核数。

### aio_worker_num 

?>设置`AIO`最大工作线程数，默认值为`cpu`核数 * 8。

### aio_max_wait_time

?>工作线程等待任务的最大时间，单位为秒。

### aio_max_idle_time

?>工作线程的最大空闲时间，单位为秒。

### reactor_num

?>**设置启动的 [Reactor](/learn?id=reactor线程) 线程数。**【默认值：`CPU`核数】

?>通过此参数来调节主进程内事件处理线程的数量，以充分利用多核。默认会启用`CPU`核数相同的数量。  
`Reactor`线程是可以利用多核，如：机器有`128`核，那么底层会启动`128`线程。  
每个线程能都会维持一个[EventLoop](/learn?id=什么是eventloop)。线程之间是无锁的，指令可以被`128`核`CPU`并行执行。  
考虑到操作系统调度存在一定程度的性能损失，可以设置为CPU核数*2，以便最大化利用CPU的每一个核。

  * **提示**

    * `reactor_num`建议设置为`CPU`核数的`1-4`倍
    * `reactor_num`最大不得超过 [swoole_cpu_num()](/functions?id=swoole_cpu_num) * 4

  * **注意**


  !> -`reactor_num`必须小于或等于`worker_num` ；  

-如果设置的`reactor_num`大于`worker_num`，会自动调整使`reactor_num`等于`worker_num` ；  
-在超过`8`核的机器上`reactor_num`默认设置为`8`。
	

### worker_num

?>**设置启动的`Worker`进程数。**【默认值：`CPU`核数】

?>如`1`个请求耗时`100ms`，要提供`1000QPS`的处理能力，那必须配置`100`个进程或更多。  
但开的进程越多，占用的内存就会大大增加，而且进程间切换的开销就会越来越大。所以这里适当即可。不要配置过大。

  * **提示**

    * 如果业务代码是全[异步IO](/learn?id=同步io异步io)的，这里设置为`CPU`核数的`1-4`倍最合理
    * 如果业务代码为[同步IO](/learn?id=同步io异步io)，需要根据请求响应时间和系统负载来调整，例如：`100-500`
    * 默认设置为[swoole_cpu_num()](/functions?id=swoole_cpu_num)，最大不得超过[swoole_cpu_num()](/functions?id=swoole_cpu_num) * 1000
    * 假设每个进程占用`40M`内存，`100`个进程就需要占用`4G`内存。


### max_request

?>**设置`worker`进程的最大任务数。**【默认值：`0` 即不会退出进程】

?>一个`worker`进程在处理完超过此数值的任务后将自动退出，进程退出后会释放所有内存和资源

!> 这个参数的主要作用是解决由于程序编码不规范导致的PHP进程内存泄露问题。PHP应用程序有缓慢的内存泄漏，但无法定位到具体原因、无法解决，可以通过设置`max_request`临时解决，需要找到内存泄漏的代码并修复，而不是通过此方案，可以使用Swoole Tracker发现泄漏的代码。

  * **提示**

    * 达到max_request不一定马上关闭进程，参考[max_wait_time](/server/setting?id=max_wait_time)。
    * [SWOOLE_BASE](/learn?id=swoole_base)下，达到max_request重启进程会导致客户端连接断开。

  !> 当`worker`进程内发生致命错误或者人工执行`exit`时，进程会自动退出。`master`进程会重新启动一个新的`worker`进程来继续处理请求


### max_conn / max_connection

?>**服务器程序，最大允许的连接数。**【默认值：`ulimit -n`】

?>如`max_connection => 10000`, 此参数用来设置`Server`最大允许维持多少个`TCP`连接。超过此数量后，新进入的连接将被拒绝。

  * **提示**

    * **默认设置**

      * 应用层未设置`max_connection`，底层将使用`ulimit -n`的值作为缺省设置
      * 在`4.2.9`或更高版本，当底层检测到`ulimit -n`超过`100000`时将默认设置为`100000`，原因是某些系统设置了`ulimit -n`为`100万`，需要分配大量内存，导致启动失败

    * **最大上限**

      * 请勿设置`max_connection`超过`1M`

    * **最小设置**    
     
      * 此选项设置过小底层会抛出错误，并设置为`ulimit -n`的值。
      * 最小值为`(worker_num + task_worker_num) * 2 + 32`

    ```shell
    serv->max_connection is too small.
    ```

    * **内存占用**

      * `max_connection`参数不要调整得过大，根据机器内存的实际情况来设置。`Swoole`会根据此数值一次性分配一块大内存来保存`Connection`信息，一个`TCP`连接的`Connection`信息，需要占用`224`字节。

  * **注意**

  !> `max_connection`最大不得超过操作系统`ulimit -n`的值，否则会报一条警告信息，并重置为`ulimit -n`的值

  ```shell
  WARN swServer_start_check: serv->max_conn is exceed the maximum value[100000].

  WARNING set_max_connection: max_connection is exceed the maximum value, it's reset to 10240
  ```


### task_worker_num

?>**配置 [Task进程](/learn?id=taskworker进程)的数量。**

?>配置此参数后将会启用`task`功能。所以`Server`务必要注册[onTask](/server/events?id=ontask)、[onFinish](/server/events?id=onfinish) 2 个事件回调函数。如果没有注册，服务器程序将无法启动。

  * **提示**

    *  [Task进程](/learn?id=taskworker进程)是同步阻塞的

    * 最大值不得超过[swoole_cpu_num()](/functions?id=swoole_cpu_num) * 1000
    
    * **计算方法**
      * 单个`task`的处理耗时，如`100ms`，那一个进程1秒就可以处理`1/0.1=10`个task
      * `task`投递的速度，如每秒产生`2000`个`task`
      * `2000/10=200`，需要设置`task_worker_num => 200`，启用`200`个Task进程

  * **注意**

    !> - [Task进程](/learn?id=taskworker进程)内不能使用`Swoole\Server->task`方法
### Задача IPC режима

?> **Установите способ коммуникации между [процессом Task](/learn?id=taskworker процесс) и `Worker` процессами.** 【По умолчанию: `1`】 
 
?> Пожалуйста, сначала прочтите [IPC коммуникация под Swoole](/learn?id=что такое IPC).


Режим | Функция
---|---
1 | Использование коммуникации через `Unix Socket` 【По умолчательный режим】
2 | Использование коммуникации через очередь сообщений `sysvmsg`
3 | Использование коммуникации через очередь сообщений `sysvmsg` в режиме гонки

  * **Примечание**

    * **Режим `1`**
      * При использовании режима `1` поддерживается целенаправленная доставка, и в методах [task](/server/methods?id=task) и [taskwait](/server/methods?id=taskwait) можно использовать `dst_worker_id`, чтобы указать целевой `Task процесс`.
      * Когда `dst_worker_id` установлен на `-1`, низкий уровень будет оценивать состояние каждого [Task процесса](/learn?id=taskworker процесс) и доставлять задания процессу, который в настоящее время находится в состоянии свободного.

    * **Режимы `2` и `3`**
      * режима очереди сообщений использует память, предоставляемую операционной системой, для хранения данных. Если не указан ключ очереди сообщений `mssage_queue_key`, будет использоваться частная очередь, которая будет удалена после остановки программы `Server`.
      * После остановки программы `Server` и указания ключа очереди сообщений данные в очереди сообщений не будут удалены, поэтому процесс может получить данные после перезапуска.
      * Можно вручную удалить данные из очереди сообщений с помощью команды `ipcrm -q ID очереди сообщений`.
      * Различие между режимами `2` и `3` заключается в том, что режим `2` поддерживает целенаправленную доставку, и `$serv->task($data, $task_worker_id)` может указать, к какому [task процессу](/learn?id=taskworker процесс) передать данные. режим `3` является полностью конкурентным, и [task процессы](/learn?id=taskworker процесс) будут соревноваться за очередь, что не позволит использовать целенаправленную доставку, и методы `task/taskwait` не смогут указывать целевой процесс `ID`, даже если `dst_worker_id` был указан, он будет неэффективен в режиме `3`.

  * **Важное примечание**

    !> -Режим `3` повлияет на метод [sendMessage](/server/methods?id=sendMessage), заставляя сообщения, отправленные с помощью [sendMessage](/server/methods?id=sendMessage), быть получены случайно одним из [task процессов](/learn?id=taskworker процесс).  
    - Использование очереди сообщений для коммуникации может привести к блокировке `Worker` процессов, если способность `Task процессов` обрабатывать данные ниже скорости доставки.  
    - После использования очереди сообщений для коммуникации `task` процессы не смогут поддерживать协程 (включение [task_enable_coroutine](/server/setting?id=task_enable_coroutine)).  


### task_max_request

?> **Установите максимальное количество задач для [task процесса](/learn?id=taskworker процесс).** 【По умолчанию: `0`】

Установите максимальное количество задач для `task` процесса. Один `task` процесс будет автоматически завершаться после обработки более чем этого количества задач. Этот параметр используется для предотвращения переполнения памяти PHP процессов. Если вы не хотите, чтобы процесс автоматически завершался, можно установить его на `0`.


### task_tmpdir

?> **Установите временную папку для task данных.** 【По умолчанию: Linux `/tmp` директория】

?> В `Server`, если передаваемые данные превышают `8180` байтов, будет активирован временный файл для хранения данных. Здесь `task_tmpdir` используется для установки местоположения для хранения временных файлов.

  * **Примечание**

    * По умолчанию, низкий уровень использует директорию `/tmp` для хранения данных `task`, если ваш Linux ядро версии слишком низка и `/tmp` директория не является памяти, можно установить ее на `/dev/shm/`
    * Если директория `task_tmpdir` не существует, низкий уровень попробует автоматически создать ее

  * **Важное примечание**

    !> - Если создание falts, `Server->start` будет потерпеть неудачу


### task_enable_coroutine

?> **Включите поддержку协程 для `Task`.** 【По умолчанию: `false`】, начиная с v4.2.12 поддерживается

?> После включения автоматически создаются协程 и [контейнер для协程](/coroutine/scheduler) в обратном вызове [onTask](/server/events?id=ontask), и PHP код может напрямую использовать API для协程.

  * **Пример**

```php
$server->on('Task', function ($serv, Swoole\Server\Task $task) {
    // из какого Worker процесса
    $task->worker_id;
    // номер задачи
    $task->id;
    // тип задачи, taskwait, task, taskCo, taskWaitMulti могут использовать разные флаги
    $task->flags;
    // данные задачи
    $task->data;
    // время отправки, добавлено в v4.6.0
    $task->dispatch_time;
    // API для协程
    co::sleep(0.2);
    // завершение задачи, окончание и возврат данных
    $task->finish([123, 'hello']);
});
```

  * **Важное примечание**

    !> - Для использования `task_enable_coroutine` необходимо, чтобы [enable_coroutine](/server/setting?id=enable_coroutine) было `true`  
    - После включения `task_enable_coroutine`, `Task` рабочие процессы поддерживают协程  
    - Если `task_enable_coroutine` не включено, поддерживается только синхронный блокирующий


### task_use_object/task_object :id=task_use_object

?> **Используйте объектно-ориентированный стиль обратного вызова для Task. ** 【По умолчанию: `false`】

?> Когда установлен на `true`, обратный вызов [onTask](/server/events?id=ontask) станет объектным стилем.

  * **Пример**

```php
<?php

$server = new Swoole\Server('127.0.0.1', 9501);
$server->set([
    'worker_num'      => 1,
    'task_worker_num' => 3,
    'task_use_object' => true,
//    'task_object' => true, // v4.6.0版本增加的别名
]);
$server->on('receive', function (Swoole\Server $server, $fd, $tid, $data) {
    $server->task(['fd' => $fd,]);
});
$server->on('Task', function (Swoole\Server $server, Swoole\Server\Task $task) {
    // здесь $task - это объект Swoole\Server\Task
    $server->send($task->data['fd'], json_encode($server->stats()));
});
$server->start();
```


### dispatch_mode

?> **Стратегия распределения пакетов данных.** 【По умолчанию: `2`】


Значение режима | Режим | Функция
---|---|---
1 | Циклический режим | Полученные пакеты будут распределяться между каждым `Worker` процессом по очереди
2 | Фиксированный режим | Распределение `Worker` происходит на основе файла的描述符 соединения. Это обеспечивает, что данные от одного и того же соединения обрабатываются одним и тем же `Worker`
3 | Превзойденный режим | Главный процесс будет выбирать для передачи пакет на основе состояния занятости `Worker`, передавая только те, которые находятся в состоянии свободного
4 | Распределение по IP | Распределение на основе IP-адреса клиента с использованием模运算 `hash`, чтобы отправить пакет определенному `Worker` процессу.<br>Это обеспечивает, что данные от одного и того же источника IP всегда будут распределяться между одним и тем же `Worker` процессом. Алгоритм следующий: `inet_addr_mod(ClientIP, worker_num)`
5 | Распределение по UID | Необходимо в пользовательском коде вызвать [Server->bind()](/server/methods?id=bind), чтобы связать один соединение с одним `uid`. Затем низкий уровень распределяет его между разными `Worker` процессами на основе значения `UID`.<br>Алгоритм следующий: `UID % worker_num`, если необходимо использовать строку в качестве `UID`, можно использовать `crc32(UID_STRING)`
7 | режим потока | Свободные `Worker` будут принимать соединения и принимать новые запросы от [Reactor](/learn?id=reactor线程)

  * **Примечание**

    * **Совет по использованию**
    
      * Безсостоянные `Server` могут использовать `1` или `3`, синхронные блокирующие `Server` используют `3`, асинхронные неблокирующие `Server` используют `1`
      * Состоянные используют `2`, `4`, `5`
      
    * **Протокол UDP**

      * Когда `dispatch_mode=2/4/5`, используется фиксированное распределение, низкий уровень использует IP-адрес клиента для хеширования и распределения между разными `Worker` процессами
      * Когда `dispatch_mode=1/3`, пакеты распределяются случайно между разными `Worker` процессами
      * Функция `inet_addr_mod`

```
    function inet_addr_mod($ip, $worker_num) {
        $ip_parts = explode('.', $ip);
        if (count($ip_parts) != 4) {
            return false;
        }
        $ip_parts = array_reverse($ip_parts);
    
        $ip_long = 0;
        foreach ($ip_parts as $part) {
            $ip_long <<= 8;
            $ip_long |= (int) $part;
        }
    
        return $ip_long % $worker_num;
    }
```
  * **Базовый режим**
    * Конфигурация `dispatch_mode` в [SWOOLE_BASE](/learn?id=swoole_base) режиме неэффективна, поскольку в `BASE` нет задач для доставки, и когда получены данные от клиента, они немедленно обрабатываются в текущем потоке/процессе с помощью обратного вызова [onReceive](/server/events?id=onreceive), не требуя доставки `Worker` процессов.

  * **Важное примечание**

    !> - Когда `dispatch_mode=1/3`, низкий уровень будет игнорировать события `onConnect/onClose`, поскольку в этих двух режимах невозможно обеспечить порядок `onConnect/onClose/onReceive`;  
    - Для серверных программ, которые не являются реакционными на запросы, не следует использовать режимы `1` или `3`. Например: HTTP-сервис является реакционным и может использовать `1` или `3`, в то время как для TCP-длинных подключений не следует использовать `1` или `3`.
### dispatch_func

?> Установите функцию `dispatch`, в основе Swoole встроено `6` способов [dispatch_mode](/server/setting?id=dispatch_mode), если это все еще не удовлетворяет потребности. Можно использовать написание функций на `C++` или `PHP`, чтобы реализовать логику `dispatch`.

  * **Способ использования**

```php
$server->set(array(
  'dispatch_func' => 'my_dispatch_function',
));
```

  * **Примечание**

    * После установки `dispatch_func` система автоматически игнорирует конфигурацию `dispatch_mode`
    * Если функция, соответствующая `dispatch_func`, не существует, система抛出ет критическую ошибку
    * Если необходимо `dispatch` пакет размером более 8K, `dispatch_func` может получить только `0-8180` байтов содержания

  * **Написание функции на PHP**

    ?> Поскольку `ZendVM` не поддерживает многоп线程ную среду, даже при установке нескольких [Reactor](/learn?id=reactor线程)线程, одновременно может выполняться только одна `dispatch_func`. Поэтому при выполнении этой PHP функции система проводит операции блокировки, что может привести к проблемам с конкуренцией за блокировку. Не следует выполнять в `dispatch_func` какие-либо блокирующие операции, иначе это приведет к остановке группы Reactor线程.

    ```php
    $server->set(array(
        'dispatch_func' => function ($server, $fd, $type, $data) {
            var_dump($fd, $type, $data);
            return intval($data[0]);
        },
    ));
    ```

    * `$fd` - уникальный идентификатор подключения клиента, который можно получить с помощью `Server::getClientInfo`
    * `$type` - тип данных, `0` означает отправка данных от клиента, `4` означает установление соединения с клиентом, `3` означает закрытие соединения с клиентом
    * `$data` - содержание данных, следует отметить: если активированы такие параметры протоколов, как `HTTP`, `EOF`, `Length`, то система будет拼接 пакеты. Но в функции `dispatch_func` можно передать только первые 8K содержания пакета, не можно получить полный пакет.
    * **Необходимо** вернуть число от `0` до `(server->worker_num - 1)`, представляющее целое число целевого процесса работы `ID`, которому следует доставить пакет
    * Если возвращаемое значение меньше `0` или равно или больше `server->worker_num`, это будет исключительным целевым `ID`, данные для `dispatch` будут отброшены

  * **Написание функции на C++**

    **В других PHP расширениях, используйте swoole_add_function для регистрации функций длины в движке Swoole.**

    ?> При вызове функции на C++ система не проводит блокировки, необходимо обеспечить线程овую безопасность вызывающей стороной

    ```c++
    int dispatch_function(swServer *serv, swConnection *conn, swEventData *data);

    int dispatch_function(swServer *serv, swConnection *conn, swEventData *data)
    {
        printf("cpp, type=%d, size=%d\n", data->info.type, data->info.len);
        return data->info.len % serv->worker_num;
    }

    int register_dispatch_function(swModule *module)
    {
        swoole_add_function("my_dispatch_function", (void *) dispatch_function);
    }
    ```

    * Функция `dispatch` должна вернуть целое число целевого `worker` процесса, которому следует доставить пакет
    * Возвращаемое `worker_id` не должно превышать `server->worker_num`, иначе система抛出ет сегментную ошибку
    * Возвращение отрицательного числа `(return -1)` означает отброс этого пакета
    * В `data` можно прочитать тип и длину события
    * `conn` содержит информацию о подключении, если это пакет UDP, то `conn` будет `NULL`

  * **Примечание**

    !> -`dispatch_func` работает только в режиме [SWOOLE_PROCESS](/learn?id=swoole_process), и подходит для серверов типов [UDP/TCP/UnixSocket](/server/methods?id=__construct)  
    - Возвращаемое `worker_id` не должно превышать `server->worker_num`, иначе система抛出ет сегментную ошибку


### message_queue_key

?> **Установите `KEY` для очереди сообщений.** 【По умолчанию: `ftok($php_script_file, 1)`】

?> Используется только когда [task_ipc_mode](/server/setting?id=task_ipc_mode) = 2/3. Установленная `Key` служит только для `Task` очереди задач, см. [IPC общение в Swoole](/learn?id=что такое IPC).

?> Ожидаемые `task` очереди не будут уничтожены после завершения `server`, и после перезапуска программы [task进程](/learn?id=taskworker进程) продолжат обрабатывать задания в очереди. Если вы не хотите, чтобы после перезапуска программы выполнялись старые `Task` задания, вы можете вручную удалить эту очередь сообщений.

```shell
ipcs -q 
ipcrm -Q [msgkey]
```


### daemonize

?> **Демонизация** 【По умолчанию: `false`】

?> Когда установите `daemonize => true`, программа будет работать в качестве демона в фоновом режиме. Для длительно работающего серверного программного обеспечения необходимо включить это.  
Если не активировать демона, то когда SSH терминал закроется, программа будет остановлена.

  * **Примечание**

    * После активации демона стандартный вход и выход будут перенаправлены на `log_file`
    * Если `log_file` не настроено, то они будут перенаправлены на `/dev/null`, и все сообщения, отпечатанные на экран, будут потеряны
    * После активации демона значение переменной окружения `CWD` (текущая директория) изменится, и чтение/запись файлов с относительными путями будет ошибиться. В `PHP` программах необходимо использовать абсолютные пути

    * **systemd**

      * Когда используете `systemd` или `supervisord` для управления Swoole сервисом, не устанавливайте `daemonize => true`. Основная причина заключается в том, что механизм `systemd` отличается от `init`. PID процесса `init` составляет `1`, после использования `daemonize` программа отделяется от терминала и в конечном итоге управляется процессом `init`,之间的关系 становится родительским и детским.
      * Но `systemd` запускает отдельный задний процесс, который самостоятельно `fork` управляет другими сервисными процессами, поэтому не требуется `daemonize`, напротив, использование `daemonize => true` может привести к тому, что Swoole программа потеряет отношения родительского и детского процесса с этим управляющим процессом.


### backlog

?> **Установите длину очереди `Listen`**

?> Например, если `backlog => 128`, этот параметр определяет максимальное количество одновременно ожидающих `accept` подключений.

  * **О `TCP` backlog**

    ?> У `TCP` есть трехсторонний процесс рукопожатия: клиент `syn=>сервер` `syn+ack=>клиент` `ack`, когда сервер получает `ack` от клиента, он помещает соединение в очередь под названием `accept queue` (примечание 1),  
    Размер очереди определяется минимальным значением параметров `backlog` и `somaxconn`, которые можно проверить командой `ss -lt`. С помощью команды `netstat -s|grep 'times the listen queue of a socket overflowed'` можно посмотреть на логи сбросов в очереди прослушивания сокета. Если возникают вышеупомянутые явления, следует увеличить эту значение. К счастью, режим SWOOLE_PROCESS Swoole отличается от PHP-FPM/Apache и других программ и не зависит от `backlog` для решения проблем с очередью подключений. Поэтому вышеупомянутое явление практически не встречается.

    * Примечание 1: После `linux2.2` процесс рукопожатия делится на две очереди: `syn queue` и `accept queue`, длина `syn queue` определяется parameter `tcp_max_syn_backlog`.
    * Примечание 2: В новых версиях ядра используется `accept4`, чтобы сэкономить один системный вызов `set no block`.
    * Примечание 3: Клиент считает, что соединение успешно установлено, когда получает пакет `syn+ack`, на самом деле сервер все еще находится в состоянии частичной связи и может отправить клиенту пакет `rst`, в результате чего у клиента будет отображаться сообщение `Connection reset by peer`.
    * Примечание 4: Успех достигается через механизм пересылки TCP, соответствующие настройки включают `tcp_synack_retries` и `tcp_abort_on_overflow`.
### open_tcp_keepalive

?> В `TCP` есть механизм `Keep-Alive`, который может обнаруживать мертвые соединения. Если приложение не чувствительно к циклу мертвых ссылок или не реализовало механизм сердцебиения, можно использовать механизм `keepalive`, предоставляемый операционной системой, чтобы отключить мертвые соединения.
В конфигурации [Server->set()](/server/methods?id=set) добавьте `open_tcp_keepalive => true`, чтобы включить `TCP keepalive`.
Кроме того, есть `3` опции, которые можно использовать для настройки деталей `keepalive`.

  * **Опции**

     * **tcp_keepidle**

        В секундах, если соединение не требует данных в течение `n` секунд, начнется проверка этого соединения.

     * **tcp_keepcount**

        Количество проверок, после чего соединение будет закрыто.

     * **tcp_keepinterval**

        Интервал проверки, в секундах.

  * **Пример**

```php
$serv = new Swoole\Server("192.168.2.194", 6666, SWOOLE_PROCESS);
$serv->set(array(
    'worker_num' => 1,
    'open_tcp_keepalive' => true,
    'tcp_keepidle' => 4, //4 секунды без передачи данных начинается проверка
    'tcp_keepinterval' => 1, //раз в секунду проводит проверку
    'tcp_keepcount' => 5, //количество проверок, после 5 раз без ответа закрывает соединение
));

$serv->on('connect', function ($serv, $fd) {
    var_dump("Клиент: Подключение $fd");
});

$serv->on('receive', function ($serv, $fd, $reactor_id, $data) {
    var_dump($data);
});

$serv->on('close', function ($serv, $fd) {
  var_dump("закрытие fd $fd");
});

$serv->start();
```


### heartbeat_check_interval

?> **Включить проверку сердцебиения** 【по умолчанию: `false`】

?> Эта опция указывает, как часто следует проводить循环 проверки, в секундах. Например, `heartbeat_check_interval => 60` означает, что каждые `60` секунд будет проведена проверка всех подключений, и если соединение не отправляет никаких данных на сервер в течение `120` секунд (если `heartbeat_idle_time` не настроено, то по умолчанию это удвоение времени между проверками), такое соединение будет принудительно закрыто. Если опция не настроена, то проверка сердцебиения не будет активирована, и по умолчанию она отключена.

  * **Примечание**
    * `Сервер` не будет активно отправлять сердцебиенные пакеты клиентам, а будет пассивно ждать их отправки. Серверная проверка сердцебиения просто проверяет, когда последний раз был отправлен пакет данными на соединение, и если это происходит более чем через ограниченное время, соединение будет отключено.
    * Соединения, отключенные проверкой сердцебиения, все равно будут вызывать回调 события [onClose](/server/events?id=onclose)

  * **Важное примечание**

    !> `heartbeat_check` поддерживает только `TCP` соединения


### heartbeat_idle_time

?> **Максимальное время允许 для бездействия соединения**

?> Необходимо использовать в сочетании с `heartbeat_check_interval`

```php
array(
    'heartbeat_idle_time'      => 600, // означает, что если соединение не отправляет никаких данных на сервер в течение 600 секунд, оно будет принудительно закрыто
    'heartbeat_check_interval' => 60,  // означает, что каждые 60 секунд будет проведена проверка
);
```

  * **Примечание**

    * После включения `heartbeat_idle_time` сервер не будет активно отправлять пакеты данных клиентам
    * Если установлены только `heartbeat_idle_time` и не установлена `heartbeat_check_interval`, то на уровне PHP не будет создано线程 для проверки сердцебиения, и в коде PHP можно вызвать метод `heartbeat` для ручного обработки timed-out соединений


### open_eof_check

?> **Включить проверку EOF** 【по умолчанию: `false`】, см. [Проблема границ TCP-пакетов](/learn?id=tcp数据包边界问题)

?> Эта опция будет проверять данные, отправленные клиентским подключением, и только когда конец пакета равен указанной строке, пакет будет передан процессу Worker. В противном случае пакет будет продолжаться拼接, пока не будет превышен буфер или не истечет время. В случае ошибки, низкий уровень будет считать это злонамеренным подключением, отбросить данные и принудительно закрыть соединение.  
Общие протоколы, такие как `Memcache/SMTP/POP`, заканчиваются `\r\n`, и для них можно использовать эту настройку. После включения можно гарантировать, что процесс Worker будет всегда получать один или несколько полных пакетов за один раз.

```php
array(
    'open_eof_check' => true,   // включение проверки EOF
    'package_eof'    => "\r\n", // установка EOF
)
```

  * **Важное примечание**

    !> Эта настройка применима только к типам сокетов `STREAM` (потоковые), таких как [TCP, Unix Socket Stream](/server/methods?id=__construct)   
    Проверка EOF не будет искать в середине данных字符串 EOF, поэтому процесс Worker может одновременно получать несколько пакетов, и в приложении необходимо самостоятельно разделять пакеты с помощью `explode("\r\n", $data)`.


### open_eof_split

?> **Включить автоматическое разделение пакетов на основе EOF**

?> Когда установлена опция `open_eof_check`, возможно, что несколько пакетов будут объединены в один. Параметр `open_eof_split` может решить эту проблему, см. [Проблема границ TCP-пакетов](/learn?id=tcp数据包边界问题).

?> Установка этого параметра требует анализа содержания всего пакета в поисках EOF, поэтому это потребует много ресурсов CPU. Предположим, что каждый пакет имеет размер `2M`, и每秒 приходит `10000` запросов, что может привести к `20G` istrукций сравнения символов CPU.

```php
array(
    'open_eof_split' => true,   // включение проверки EOF_SPLIT
    'package_eof'    => "\r\n", // установка EOF
)
```

  * **Примечание**

    * После включения параметра `open_eof_split` низкий уровень будет искать EOF в середине пакета и разделять пакеты. [onReceive](/server/events?id=onreceive) будет получать только один пакет, который заканчивается строкой EOF.
    * После включения параметра `open_eof_split`, независимо от того, установлена ли опция `open_eof_check`, `open_eof_split` будет работать.

    * **Отличия от `open_eof_check`**
    
        * `open_eof_check` проверяет только конец принятых данных на наличие EOF, поэтому его производительность лучше всего, и он практически не потребляет ресурсов
        * `open_eof_check` не решает проблему объединения нескольких пакетов, например, если одновременно отправляются два пакета с EOF, низкий уровень может вернуть их все за один раз
        * `open_eof_split` будет сравнивать данные по字节ам слева направо в поисках EOF для разделения пакетов, что имеет плохую производительность. Но он всегда вернет только один пакет


### package_eof

?> **Установить строку EOF.** См. [Проблема границ TCP-пакетов](/learn?id=tcp数据包边界问题)

?> Необходимо использовать в сочетании с `open_eof_check` или `open_eof_split`.

  * **Важное примечание**

    !> Максимально разрешена передача字符串ом длиной в `8` байтов


### open_length_check

?> **Включить проверку длины пакета** 【по умолчанию: `false`】, см. [Проблема границ TCP-пакетов](/learn?id=tcp数据包边界问题)

?> Проверка длины пакета обеспечивает анализ пакетов с фиксированным заголовком и телом. После включения можно гарантировать, что процесс Worker [onReceive](/server/events?id=onreceive) будет каждый раз получать полный пакет.  
Протокол проверки длины требует только одного расчета длины, обработка данных осуществляется только с помощью смещения указателя, что обеспечивает высокую производительность, **рекомендуемый для использования**.

  * **Примечание**

    * **Протокол проверки длины предлагает 3 опции для управления деталями протокола.**

      ?> Эта настройка применима только к типам сокетов `STREAM` (потоковые), таких как [TCP, Unix Socket Stream](/server/methods?id=__construct)

      * **package_length_type**

        ?> Некоторые поля в заголовке используются для хранения длины пакета, низкий уровень поддерживает 10 типов длины. См. [package_length_type](/server/setting?id=package_length_type)

      * **package_body_offset**

        ?> От какого байта начинается расчет длины, обычно есть два случая:

        * значение `length` включает весь пакет (заголовок + тело), `package_body_offset` равен `0`
        * Длина заголовка составляет `N` байтов, значение `length` не включает заголовок и включает только тело, `package_body_offset` установлено как `N`

      * **package_length_offset**

        ?> Какой байт в заголовке содержит значение длины `length`.

        * Пример:

        ```c
        struct
        {
            uint32_t type;
            uint32_t uid;
            uint32_t length;
            uint32_t serid;
            char body[0];
        }
        ```
        
    ?> В вышеупомянутом дизайне коммуникационного протокола длина заголовка составляет `4` целых числа, `16` байтов, значение длины `length` находится на третьем целом числе. Таким образом, `package_length_offset` установлено как `8`, первые `0-3` байта для `type`, следующие `4-7` байта для `uid`, следующие `8-11` байта для `length`, последние `12-15` байта для `serid`.

    ```php
    $server->set(array(
      'open_length_check'     => true,
      'package_max_length'    => 81920,
      'package_length_type'   => 'N',
      'package_length_offset' => 8,
      'package_body_offset'   => 16,
    ));
    ```
### package_length_type

?> **Тип значения длины**, принимает один параметр типа символа, совместим с функцией [pack](http://php.net/manual/zh/function.pack.php) в `PHP`.

В настоящее время `Swoole` поддерживает `10` типов:


Параметр символа | Функция
---|---
c | Сignaled, 1 byte
C | Unsigned, 1 byte
s | Signed, host byte order, 2 bytes
S | Unsigned, host byte order, 2 bytes
n | Unsigned, network byte order, 2 bytes
N | Unsigned, network byte order, 4 bytes
l | Signed, host byte order, 4 bytes (маленькая буква L)
L | Unsigned, host byte order, 4 bytes (большая буква L)
v | Unsigned, little-endian byte order, 2 bytes
V | Unsigned, little-endian byte order, 4 bytes


### package_length_func

?> **Установка функции 解析 длины**

?> Поддерживается `2` типа функций, написанных на `C++` или `PHP`. Функция длины должна возвращать целое число.


Возвращаемое значение | Функция
---|---
Возвращение `0` | Недостатка данных длины, необходимо принять больше данных
Возвращение `-1` | Ошибка данных, нижний уровень автоматически закроет соединение
Возвращение значения длины пакета (общая длина заголовка и тела пакета) | Низкий уровень автоматически склеит пакет и вернет его обратному вызову функции

  * **Примечание**

    * **Способ использования**

    ?> Принцип работы заключается в первом чтении небольшой части данных, которая содержит значение длины. Затем этот размер длины возвращается нижнему уровню. Затем нижний уровень завершает прием оставшейся данных и склеивает ее в пакет для `dispatch`.

    * **Функция 解析 длины PHP**

    ?> Поскольку `ZendVM` не поддерживает работу в многопроцессорной среде, нижний уровень автоматически использует `Mutex`互斥量 для блокировки функций `PHP` длины, чтобы избежать параллельного выполнения функций `PHP`. Доступно в версиях `1.9.3` и выше.

    !> Не выполняйте в функции 解析 длины блокирующие `IO` операции, что может привести к блокировке всех线程 [Reactor](/learn?id=reactor).

    ```php
    $server = new Swoole\Server("127.0.0.1", 9501);
    
    $server->set(array(
        'open_length_check'   => true,
        'dispatch_mode'       => 1,
        'package_length_func' => function ($data) {
          if (strlen($data) < 8) {
              return 0;
          }
          $length = intval(trim(substr($data, 0, 8)));
          if ($length <= 0) {
              return -1;
          }
          return $length + 8;
        },
        'package_max_length'  => 2000000,  // Максимальная длина протокола
    ));
    
    $server->on('receive', function (Swoole\Server $server, $fd, $reactor_id, $data) {
        var_dump($data);
        echo "#{$server->worker_id}>> received length=" . strlen($data) . "\n";
    });
    
    $server->start();
    ```

    * **Функция 解析 длины C++**

    ?> В других PHP расширениях используйте `swoole_add_function` для регистрации функций длины в движке `Swoole`.
    
    !> При вызове функций длины на уровне C++ нижний уровень не будет блокироваться, и необходимо обеспечить线程овую безопасность со стороны вызывающей стороны
    
    ```c++
    #include <string>
    #include <iostream>
    #include "swoole.h"
    
    using namespace std;
    
    int test_get_length(swProtocol *protocol, swConnection *conn, char *data, uint32_t length);
    
    void register_length_function(void)
    {
        swoole_add_function((char *) "test_get_length", (void *) test_get_length);
        return SW_OK;
    }
    
    int test_get_length(swProtocol *protocol, swConnection *conn, char *data, uint32_t length)
    {
        printf("cpp, size=%d\n", length);
        return 100;
    }
    ```


### package_max_length

?> **Установка максимальной размера пакета данных в字节. **【По умолчанию: `2M`, то есть `2 * 1024 * 1024`, минимальное значение `64K`】

?> После включения [open_length_check](/server/setting?id=open_length_check)/[open_eof_check](/server/setting?id=open_eof_check)/[open_eof_split](/server/setting?id=open_eof_split)/[open_http_protocol](/server/setting?id=open_http_protocol)/[open_http2_protocol](/http_server?id=open_http2_protocol)/[open_websocket_protocol](/server/setting?id=open_websocket_protocol)/[open_mqtt_protocol](/server/setting?id=open_mqtt_protocol) и других протоколов разборка, `Swoole` нижний уровень будет собирать пакеты данных, и в этот момент, когда пакет данных не был полностью получен, все данные сохраняются в памяти.  
Поэтому необходимо установить `package_max_length`, максимальное разрешенное размер占用 памяти одного пакета данных. Если одновременно есть 10 тысяч `TCP` подключений, отправляющие данные, каждый пакет `2M`, то в худшем случае это займет `20G` памяти.

  * **Примечание**

    * `open_length_check`: когда обнаруживается, что длина пакета превышает `package_max_length`, этот пакет данных будет напрямую отброшен, и соединение будет закрыто, не занимая никакой памяти;
    * `open_eof_check`: поскольку заранее неизвестна длина пакета данных, полученные данные все равно сохраняются в памяти и продолжают расти. Когда обнаруживается, что использование памяти превышает `package_max_length`, этот пакет данных будет напрямую отброшен, и соединение будет закрыто;
    * `open_http_protocol`: максимальное разрешенное значение для `GET` запросов составляет `8K`, и его невозможно изменить в конфигурации. Для `POST` запросов будет проверяться `Content-Length`, и если `Content-Length` превышает `package_max_length`, этот пакет данных будет напрямую отброшен, будет отправлен `http 400` ошибка и закрыто соединение;

  * **Важное примечание**

    !> Этот параметр не следует устанавливать слишком велик, иначе это может занимать большую память


### open_http_protocol

?> **Включение обработки протокола `HTTP`.**【По умолчанию: `false`】

?> Включение обработки протокола `HTTP`, [Swoole\Http\Server](/http_server) автоматически активирует эту опцию. Установка на `false` означает отключение обработки протокола `HTTP`.


### open_mqtt_protocol

?> **Включение обработки протокола `MQTT`.**【По умолчанию: `false`】

?> После включения будет декодирован заголовок `MQTT`, и каждый раз `worker` процесс [onReceive](/server/events?id=onreceive) вернет полный пакет данных `MQTT`.

```php
$server->set(array(
  'open_mqtt_protocol' => true
));
```


### open_redis_protocol

?> **Включение обработки протокола `Redis`.**【По умолчанию: `false`】

?> После включения будет декодирован протокол `Redis`, и каждый раз `worker` процесс [onReceive](/server/events?id=onreceive) вернет полный пакет данных `Redis`. Рекомендуется использовать напрямую [Redis\Server](/redis_server)

```php
$server->set(array(
  'open_redis_protocol' => true
));
```


### open_websocket_protocol

?> **Включение обработки протокола `WebSocket`.**【По умолчанию: `false`】

?> После включения обработки протокола `WebSocket`, [Swoole\WebSocket\Server](websocket_server) автоматически активирует эту опцию. Установка на `false` означает отключение обработки протокола `websocket`.  
После установки опции `open_websocket_protocol` в значение `true`, автоматически будет установлена также опция `open_http_protocol` в значение `true`.


### open_websocket_close_frame

?> **Включение фрейма закрытия в протоколе WebSocket.**【По умолчанию: `false`】

?> (фрейм с `opcode` `0x08`) Получен в обратном вызове `onMessage`

?> После включения можно в обратном вызове `onMessage` в `WebSocketServer` получать фреймы закрытия, отправленные клиентом или сервером, и разработчик может самостоятельно их обрабатывать.

```php
$server = new Swoole\WebSocket\Server("0.0.0.0", 9501);

$server->set(array("open_websocket_close_frame" => true));

$server->on('open', function (Swoole\WebSocket\Server $server, $request) {});

$server->on('message', function (Swoole\WebSocket\Server $server, $frame) {
    if ($frame->opcode == 0x08) {
        echo "Получен фрейм закрытия: код {$frame->code} Причина {$frame->reason}\n";
    } else {
        echo "Получена сообщение: {$frame->data}\n";
    }
});

$server->on('close', function ($server, $fd) {});

$server->start();
```
### open_tcp_nodelay

?> **Включить `open_tcp_nodelay`.** 【По умолчанию: `false`】

?> Когда включено, передача данных по `TCP` соединениям будет происходить без использования алгоритма `Nagle`, и данные будут отправлены немедленно на противоположный конец `TCP` соединения. В некоторых сценариях, например, в командной строковой оболочке, когда вы вводите команду, она должна быть немедленно отправлена на сервер, что может увеличить скорость ответа. Пожалуйста, изучите алгоритм Nagle самостоятельно.


### open_cpu_affinity 

?> **Включить настройки CPU-affinitизации.** 【По умолчанию `false`】

?> На платформах с множественными ядрами, включение этой функции привязывает `reactor-треды`/`worker-процессы` Swoole к определенному ядру. Это может избежать переключения процессов/тредов между различными ядрами во время выполнения, увеличивая темпы попадания в CPU-кэши.

  * **Напоминание**

    * **Используйте команду taskset для просмотра настроек CPU-affinitизации процесса:**

    ```bash
    taskset -p ProcessID
    pid 24666's current affinity mask: f
    pid 24901's current affinity mask: 8
    ```

    > Маска - это число в битовом представлении, где каждое бит соответствует одному ядру CPU. Если определенный бит равен `0`, это означает привязку к этому ядру, и процесс будет распределяться на это ядро. Если бит равен `1`, процесс не будет распределяться на это ядро. В примере `pid` 24666 имеет маску `f`, что означает, что процесс не привязан к какому-либо ядру CPU, и операционная система распределяет этот процесс между любыми ядрами CPU. `pid` 24901 имеет маску `8`, которая в двоичном виде равна `1000`, что означает, что процесс привязан к четвертому ядру CPU.


### cpu_affinity_ignore

?> **В программах, занятых IO, все сетевые прерывания обрабатываются на CPU0. Если сетевые IO очень тяжелые, из-за высокого нагрузки на CPU0 сетевые прерывания могут не обрабатываться вовремя, что приведет к снижению способности к приему и отправке сетевых пакетов.**

?> Если этот параметр не установлен, Swoole будет использовать все ядра CPU, и на нижнем уровне привязка к ядрам CPU будет происходить на основе modulusReactor_id или worker_id с количеством ядер CPU. Если у ядра и сетевого адаптера есть множество очередей, сетевые прерывания будут распределяться между множеством ядер, что может снизить нагрузку на сетевые прерывания.

```php
array('cpu_affinity_ignore' => array(0, 1)) // Принимает массив в качестве параметра, array(0, 1) означает не использовать CPU0 и CPU1, специально оставляя их для обработки сетевых прерывания.
```

  * **Напоминание**

    * **Смотреть сетевые прерывания**

```shell
[~]$ cat /proc/interrupts 
           CPU0       CPU1       CPU2       CPU3       
  0: 1383283707          0          0          0    IO-APIC-edge  timer
  1:          3          0          0          0    IO-APIC-edge  i8042
  3:         11          0          0          0    IO-APIC-edge  serial
  8:          1          0          0          0    IO-APIC-edge  rtc
  9:          0          0          0          0   IO-APIC-level  acpi
 12:          4          0          0          0    IO-APIC-edge  i8042
 14:         25          0          0          0    IO-APIC-edge  ide0
 82:         85          0          0          0   IO-APIC-level  uhci_hcd:usb5
 90:         96          0          0          0   IO-APIC-level  uhci_hcd:usb6
114:    1067499          0          0          0       PCI-MSI-X  cciss0
130:   96508322          0          0          0         PCI-MSI  eth0
138:     384295          0          0          0         PCI-MSI  eth1
169:          0          0          0          0   IO-APIC-level  ehci_hcd:usb1, uhci_hcd:usb2
177:          0          0          0          0   IO-APIC-level  uhci_hcd:usb3
185:          0          0          0          0   IO-APIC-level  uhci_hcd:usb4
NMI:      11370       6399       6845       6300 
LOC: 1383174675 1383278112 1383174810 1383277705 
ERR:          0
MIS:          0
```

`eth0/eth1` - это количество сетевых прерывания. Если распределение между `CPU0 - CPU3` равномерно, это означает, что сетевой адаптер поддерживает множественные очереди. Если все прерывания сосредоточены на одном ядре, это означает, что все сетевые прерывания обрабатываются этим `CPU`. Как только этот `CPU` превышает `100%`, система не сможет обрабатывать сетевые запросы. В таких случаях необходимо использовать `cpu_affinity_ignore` для освобождения этого `CPU`, чтобы он использовался исключительно для обработки сетевых прерывания.

В соответствии с вышеизложенным образом, следует установить `cpu_affinity_ignore => array(0)`

?> Используйте команду `top` и Enter, чтобы увидеть использование каждого ядра.

  * **Примечание**

    !> Эта опция должна быть установлена одновременно с `open_cpu_affinity`, чтобы она сработала.


### tcp_defer_accept

?> **Включить функцию `tcp_defer_accept`.** 【По умолчанию: `false`】

?> Можно установить как число, означающее, что `accept` будет срабатывать, когда на `TCP` соединении есть данные для отправки.

```php
$server->set(array(
  'tcp_defer_accept' => 5
));
```

  * **Примечание**

    * **После включения функции `tcp_defer_accept`, время между `accept` и [onConnect](/server/events?id=onconnect) изменится. Если установлено значение `5` секунд:**

      * После подключения клиента к серверу `accept` не будет срабатывать немедленно
      * Если в течение `5` секунд клиент отправляет данные, то одновременно будут срабатывать `accept/onConnect/onReceive`
      * Если в течение `5` секунд клиент не отправляет никаких данных, то будет срабатывать только `accept/onConnect`


### ssl_cert_file / ssl_key_file :id=ssl_cert_file

?> **Установить шифрование для SSL туннеля.**

?> Установите значение как строку с именем файла, указывающую путь к сертификату cert и ключу key.

  * **Примечание**

    * **Преобразование PEM в DER**

    ```shell
    openssl x509 -in cert.crt -outform der -out cert.der
    ```

    * **Преобразование DER в PEM**

    ```shell
    openssl x509 -in cert.crt -inform der -outform pem -out cert.pem
    ```

  * **Примечание**

    !> Для `HTTPS` приложений браузер должен доверять сертификату, чтобы можно было просматривать веб-страницы;  
    - Для `wss` приложений страница, на которой начинается `WebSocket` соединение, должна использовать `HTTPS`;  
    - Если браузер не доверяет SSL сертификату, то невозможно использовать `wss`;  
    - Файлы должны быть в формате PEM, поддержка DER форматом отсутствует, можно использовать инструмент openssl для преобразования.

    !> Для использования SSL при разработке Swoole необходимо включить опцию [--enable-openssl](/environment?id=编译选项) при сборке

    ```php
    $server = new Swoole\Server('0.0.0.0', 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);
    $server->set(array(
        'ssl_cert_file' => __DIR__.'/config/ssl.crt',
        'ssl_key_file' => __DIR__.'/config/ssl.key',
    ));
    ```


### ssl_method

!> Этот параметр был удален в версии [v4.5.4](/version/bc?id=_454), пожалуйста, используйте `ssl_protocols`

?> **Установить алгоритм шифрования OpenSSL для туннеля.** 【По умолчанию: `SWOOLE_SSLv23_METHOD`】, поддерживаемые алгоритмы смотрите в [Методы SSL](/consts?id=ssl-加密方法)

?> Алгоритмы, используемые `Сервером` и `Клиентом`, должны совпадать, иначе握手 `SSL/TLS` потерпит неудачу, и соединение будет прервано

```php
$server->set(array(
    'ssl_method' => SWOOLE_SSLv3_CLIENT_METHOD,
));
```
### ssl_protocols

?> **Установка протоколов для шифрования туннеля OpenSSL.** 【По умолчанию: `0`, поддерживает все протоколы】, поддерживаемые виды смотрите в [Протоколы SSL](/consts?id=ssl-протоколы)

!> Версия Swoole >= `v4.5.4` доступна

```php
$server->set(array(
    'ssl_protocols' => 0,
));
```


### ssl_sni_certs

?> **Установка сертификатов SNI (Server Name Identification)**

!> Версия Swoole >= `v4.6.0` доступна

```php
$server->set([
    'ssl_cert_file' => __DIR__ . '/server.crt',
    'ssl_key_file' => __DIR__ . '/server.key',
    'ssl_protocols' => SWOOLE_SSL_TLSv1_2 | SWOOLE_SSL_TLSv1_3 | SWOOLE_SSL_TLSv1_1 | SWOOLE_SSL_SSLv2,
    'ssl_sni_certs' => [
        'cs.php.net' => [
            'ssl_cert_file' => __DIR__ . '/sni_server_cs_cert.pem',
            'ssl_key_file' => __DIR__ . '/sni_server_cs_key.pem',
        ],
        'uk.php.net' => [
            'ssl_cert_file' =>  __DIR__ . '/sni_server_uk_cert.pem',
            'ssl_key_file' => __DIR__ . '/sni_server_uk_key.pem',
        ],
        'us.php.net' => [
            'ssl_cert_file' => __DIR__ . '/sni_server_us_cert.pem',
            'ssl_key_file' => __DIR__ . '/sni_server_us_key.pem',
        ],
    ]
]);
```


### ssl_ciphers

?> **Установка алгоритмов шифрования OpenSSL.** 【По умолчанию: `EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH`】

```php
$server->set(array(
    'ssl_ciphers' => 'ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP',
));
```

  * **Примечание**

    * Когда `ssl_ciphers` установлено как пустая строка, `openssl` выбирает алгоритмы шифрования самостоятельно


### ssl_verify_peer

?> **Установка проверки сертификатов противоположной стороны для SSL.** 【По умолчанию: `false`】

?> По умолчанию выключено, то есть клиенты сертификаты не проверяются. Если включено, необходимо также установить опцию `ssl_client_cert_file`


### ssl_allow_self_signed

?> **Разрешение на использование самокertifikатов.** 【По умолчанию: `false`】


### ssl_client_cert_file

?> **Сертификат корневого证书的, используемый для проверки сертификатов клиентов.**

```php
$server = new Swoole\Server('0.0.0.0', 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);
$server->set(array(
    'ssl_cert_file'         => __DIR__ . '/config/ssl.crt',
    'ssl_key_file'          => __DIR__ . '/config/ssl.key',
    'ssl_verify_peer'       => true,
    'ssl_allow_self_signed' => true,
    'ssl_client_cert_file'  => __DIR__ . '/config/ca.crt',
));
```

!> Если проверка TCP-сервиса провалится, нижестоящий уровень будет активно закрывать соединение.


### ssl_compress

?> **Установка включения сжатия `SSL/TLS`.** Когда используется [Co\Client](/coroutine_client/client), у него есть псевдоним `ssl_disable_compression`


### ssl_verify_depth

?> **Если цепочка сертификатов слишком глубока и превышает значение, установленное этой опцией, то проверка будет прекращена.**


### ssl_prefer_server_ciphers

?> **Включение защиты на стороне сервера, предотвращение атаки BEAST.**


### ssl_dhparam

?> **Установка параметров Диффии-Хэлла для DH-шифраторов.**


### ssl_ecdh_curve

?> **Установка кривой, используемой в обмене ключами ECDH.**

```php
$server = new Swoole\Server('0.0.0.0', 9501, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);
$server->set([
    'ssl_compress'                => true,
    'ssl_verify_depth'            => 10,
    'ssl_prefer_server_ciphers'   => true,
    'ssl_dhparam'                 => '',
    'ssl_ecdh_curve'              => '',
]);
```


### user

?> **Установка пользователя для `Worker/TaskWorker` дочерних процессов.** 【По умолчанию: пользователь, выполняющий сценарий】

?> Если сервер должен слушать порты ниже `1024`, ему должен быть предоставлен доступ `root`. Но если программа работает под пользователем `root`, то в случае уязвимости кода злоумышленник может выполнить дистанционный командный доступ с правами `root`, что представляет большую опасность. После установки опции `user` главный процесс может работать с правами `root`, а дочерние процессы - с обычными пользовательскими правами.

```php
$server->set(array(
  'user' => 'Apache'
));
```

  * **Примечание**

    !> - действительно только при запуске с правами `root`  
    - Использование опции `user/group` для настройки рабочих процессов как обычных пользователей после этого не позволит рабочим процессам вызывать методы закрытия или перезагрузки службы, такие как `shutdown`/[reload](/server/methods?id=reload), и только root-аккаунт может использоваться в командной строке shell для выполнения команды `kill`.


### group

?> **Установка группы пользователей для `Worker/TaskWorker` дочерних процессов.** 【По умолчанию: группа пользователей, выполняющих сценарий】

?> Так же, как и опция `user`, эта настройка изменяет принадлежащую группе пользователей рабочих процессов, повышая безопасность серверной программы.

```php
$server->set(array(
  'group' => 'www-data'
));
```

  * **Примечание**

    !> действительно только при запуске с правами `root`


### chroot

?> **Перенаправление корневого каталога файловой системы для рабочих процессов.**

?> Эта настройка позволяет изолировать доступ рабочих процессов к файловой системе от реальной операционной системы, повышая тем самым безопасность.

```php
$server->set(array(
  'chroot' => '/data/server/'
));
```


### pid_file

?> **Установка адреса файла PID.**

?> Когда `Server` запускается, автоматически записывается PID `master` процесса в файл, а когда `Server` закрывается, автоматически удаляется файл PID.

```php
$server->set(array(
    'pid_file' => __DIR__.'/server.pid',
));
```

  * **Примечание**

    !> При использовании следует учитывать, что если `Server` завершается необычно, файл PID не будет удален, и необходимо использовать [Swoole\Process::kill($pid, 0)](/process/process?id=kill) для проверки на наличие процесса


### buffer_input_size / input_buffer_size :id=buffer_input_size

?> **Конфигурация размера памяти приемной буферной зоны. ** 【По умолчанию: `2M`】

```php
$server->set([
    'buffer_input_size' => 2 * 1024 * 1024,
]);
```


### buffer_output_size / output_buffer_size :id=buffer_output_size

?> **Конфигурация размера памяти отправной буферной зоны. ** 【По умолчанию: `2M`】

```php
$server->set([
    'buffer_output_size' => 32 * 1024 * 1024, //must be a number
]);
```

  * **Примечание**

    !> При Swoole версии >= `v4.6.7` по умолчанию равно максимальному значению беззнакового INT `UINT_MAX`

    * Единица измерения - байты, по умолчанию `2M`, например, установка `32 * 1024 * 1024` означает, что максимальное количество данных, которое может быть отправлено в один раз с помощью команды `Server->send`, составляет `32M` байтов
    * При использовании команд для отправки данных, таких как `Server->send`, `Http\Server->end/write`, `WebSocket\Server->push`, максимальное количество данных, которое может быть отправлено за один раз, не должно превышать значение, установленное в конфигурации `buffer_output_size`.

    !> Эта параметр применим только к [SWOOLE_PROCESS](/learn?id=swoole_process) режиму, поскольку в режиме PROCESS данные рабочих процессов должны быть отправлены на главный процесс, а затем к клиентам, поэтому каждый рабочий процесс будет иметь свой буфер для общения с главным процессом. [См. справку](/learn?id=reactor线程)


### socket_buffer_size

?> **Конфигурация размера буфера для клиентов. ** 【По умолчанию: `2M`】

?> В отличие от `buffer_output_size`, `buffer_output_size` - это ограничение размера одного отправления рабочих процессов, в то время как `socket_buffer_size` используется для установки общего размера буфера для коммуникации между `Worker` и `Master` процессами, см. [SWOOLE_PROCESS](/learn?id=swoole_process) режим.

```php
$server->set([
    'socket_buffer_size' => 128 * 1024 *1024, //must be a number, in bytes, for example, 128 * 1024 *1024 means that each TCP client connection is allowed to have up to 128M of data pending sending
]);
```
- **Данные для отправки в буфер**

    - Когда мастер-процесс отправляет клиенту большое количество данных, они не отправляются сразу. В это время данные сохраняются в памяти серверного буфера. Этот параметр позволяет настроить размер памяти буфера.
    
    - Если отправляемая информация слишком велика и занимает весь буфер, сервер будет сообщать следующую ошибку:
    
    ```bash
    swFactoryProcess_finish: send failed, session#1 output buffer has been overflowed.
    ```
    
    ?>Ошибка из-за переполнения отправочного буфера приводит к неудаче отправки, что влияет только на текущего клиента, другие клиенты не пострадают. Когда сервер имеет множество TCP-соединений, в худшем случае это может занять `serv->max_connection * socket_buffer_size` байтов памяти.
    
    - Особенно если это серверное приложение для внешней коммуникации, где сетевое общение медленное, и если данные отправляются непрерывно, буфер быстро наполняется. Отправляемые данные будут накоплены в памяти сервера. Поэтому такие приложения должны учитывать сетевую пропускную способность в своей конструкции, сначала сохранять сообщения на диск, и только после того, как клиент сообщит серверу о приеме, отправлять новые данные.
    
    - Например, в сервисе онлайн-трансляции видео, у пользователя A пропускная способность составляет `100M`, и отправка `10M` данных за `1` секунду вполне приемлема. У пользователя B пропускная способность составляет только `1M`, и если за `1` секунду отправлять `10M` данных, B может потребовать `100` секунд для их приема. В это время все данные будут накоплены в памяти сервера.
    
    - Можно применять различные подходы в зависимости от типа содержания данных. Если это содержимое может быть потеряно, например, в сервисах онлайн-трансляции видео, то в случае плохой сетевой связи потеря некоторых данных кадров вполне приемлема. Если содержание не может быть потеряно, например, сообщения в WeChat, то можно сначала сохранить их на диске сервера, по `100` сообщений за один пакет. Когда пользователь принимает этот пакет сообщений, можно прочитать следующий пакет с диска и отправить его клиенту.


### enable_unsafe_event

?> **Включение событий `onConnect/onClose`.** 【По умолчанию: `false`】

?> После того как `Swoole` настроен на [dispatch_mode](/server/setting?id=dispatch_mode)=1 или `3`, система не может гарантировать порядок `onConnect/onReceive/onClose`, поэтому по умолчанию отключены события `onConnect/onClose`;  
Если приложение требует событий `onConnect/onClose` и может принять потенциальные риски, связанные с проблемой порядка, можно включить события `onConnect/onClose`, установив `enable_unsafe_event` в `true`.


### discard_timeout_request

?> **Отказ от обработки данных для закрытых соединений.** 【По умолчанию: `true`】

?> После того как `Swoole` настроен на [dispatch_mode](/server/setting?id=dispatch_mode)=`1` или `3`, система не может гарантировать порядок `onConnect/onReceive/onClose`, поэтому некоторые данные могут достигать `Worker` процесса после закрытия соединения.

  * **Примечание**

    * По умолчанию `discard_timeout_request` установлен на `true`, что означает, что если `Worker` процесс получает данные для закрытого соединения, он их автоматически отбросит.
    * Если `discard_timeout_request` установлен на `false`, то `Worker` процесс будет обрабатывать данные независимо от того, закрыто ли соединение.


### enable_reuse_port

?> **Установка重用 порта.** 【По умолчанию: `false`】

?> После включения重用 порта можно повторно запустить программу-сервер, слушающую на одном и том же порту

  * **Примечание**

    * `enable_reuse_port = true` активирует重用 порта
    * `enable_reuse_port = false` отключает重用 порта

!> Только в ядрах Linux версии 3.9.0 и выше, а также в версиях Swoole 4.5 и выше


### enable_delay_receive

?> **Установка опции задержки при приеме клиентов.** 【По умолчанию: `false`】

?> После установки этой опции, после принятия соединения с клиентом, сервер не будет автоматически добавлен в [EventLoop](/learn?id=什么是eventloop). **По умолчанию: `false`**. После установки этой опции на `true`, после принятия соединения с клиентом, сервер не будет автоматически добавлен в [EventLoop](/learn?id=什么是eventloop), будет только вызвано событие [onConnect](/server/events?id=onconnect). `Worker` процесс может вызвать [$server->confirm($fd)](/server/methods?id=confirm) для подтверждения соединения, и только после этого `fd` будет добавлен в [EventLoop](/learn?id=什么是eventloop) для начала приема и отправки данных, также можно вызвать `$server->close($fd)` для закрытия этого соединения.

```php
//啟启用enable_delay_receive选项
$server->set(array(
    'enable_delay_receive' => true,
));

$server->on("Connect", function ($server, $fd, $reactorId) {
    $server->after(2000, function() use ($server, $fd) {
        //подтверждение соединения, начало приема данных
        $server->confirm($fd);
    });
});
```


### reload_async

?> **Установка переключателя для асинхронного перезагрузки.** 【По умолчанию: `true`】

?> Установка переключателя для асинхронного перезагрузки. Когда установлен на `true`, будет активирована функция безопасного асинхронного перезагрузки, и `Worker` процесс будет ждать завершения асинхронных событий перед выходом. Для подробной информации смотрите [как правильно перезапустить сервис](/question/use?id=swoole как правильно перезапустить сервис).

?> Основная цель установки `reload_async` - обеспечить нормальное завершение корутин или асинхронных задач во время перезагрузки сервиса. 

```php
$server->set([
  'reload_async' => true
]);
```

  * **Корутинный режим**

    * В версии `4.x`, когда включена [enable_coroutine](/server/setting?id=enable_coroutine), на нижнем уровне будет добавлена проверка количества корутин. Процесс будет выйти только тогда, когда нет никаких корутин, даже если `reload_async => false`, он будет принудительно включен `reload_async`.


### max_wait_time

?> **Установка максимальной времени ожидания `Worker` процесса после получения уведомления о прекращении службы**【По умолчанию: `3`】

?> Часто возникает ситуация, когда из-за блокировки `Worker` процесс не может нормально `reload`, что не удовлетворяет некоторым производственным сценариям, например, необходимости `reload` процесса для горячей обновления кода. Поэтому Swoole добавил опцию времени ожидания перезагрузки процесса. Для подробной информации смотрите [как правильно перезапустить сервис](/question/use?id=swoole как правильно перезапустить сервис).

  * **Примечание**

    * **После того как управляющий процесс получает сигнал о перезагрузке или закрытии или достигает `max_request`, управляющий процесс перезапустит этот `Worker` процесс. Процесс выполняется следующим образом:**

      * На нижнем уровне будет установлен таймер (`max_wait_time`) секунд. После активации таймера будет проверяться, существует ли процесс. Если он существует, он будет принудительно убран, и будет запущен новый процесс.
      * Необходимо выполнить收尾 работы в обратном вызове `onWorkerStop`.收尾 работы должны быть завершены в течение `max_wait_time` секунд.
      * Последовательно отправляются сигналы `SIGTERM` целевому процессу, убивая его.

  * **Примечание**

    !> До версии `v4.4.x` по умолчанию составляет `30` секунд


### tcp_fastopen

?> **Включение функции быстрой начальной handshake TCP.** 【По умолчанию: `false`】

?> Эта функция может увеличить скорость ответа для коротких TCP-соединений, в третьем шаге рукопожатия клиент отправляет пакет `SYN` с данными.

```php
$server->set([
  'tcp_fastopen' => true
]);
```

  * **Примечание**

    * Этот параметр может быть установлен на слушаемом порту. Тем, кто хочет лучше понять, можно посмотреть [google Paper](http://conferences.sigcomm.org/co-next/2011/papers/1569470463.pdf)


### request_slowlog_file

?> **Включение медленного логирования запросов.** Начиная с версии `v4.4.8` [удалено](https://github.com/swoole/swoole-src/commit/b1a400f6cb2fba25efd2bd5142f403d0ae303366)

!> Поскольку этот метод медленного логирования работает только в синхронных блокирующих процессах и не может быть использован в контексте корутин, а Swoole 4 по умолчанию использует корутины, следует избегать его использования. Вместо этого используйте [Swoole Tracker](https://business.swoole.com/tracker/index) для обнаружения блокировок.

?> После включения управляющий процесс установит сигнал часов, который регулярно проверяет все `Task` и `Worker` процессы. Как только процесс блокируется и приводит к тому, что запрос превышает установленные сроки, будет автоматически выведен стек вызовов PHP процесса.

?> На основе системного вызова `ptrace` реализовано на нижнем уровне, и некоторые системы могут禁用 `ptrace`, что не позволяет отслеживать медленные запросы. Пожалуйста, убедитесь, что параметр ядра `kernel.yama.ptrace_scope` установлен на `0`.

```php
$server->set([
  'request_slowlog_file' => '/tmp/trace.log',
]);
```

  * **Время ожидания**

```php
$server->set([
    'request_slowlog_timeout' => 2, // Установить время ожидания запроса в 2 секунды
    'request_slowlog_file' => '/tmp/trace.log',
]);
```

!> Файл должен иметь права на запись, иначе создание файла приведет кFatal error на нижнем уровне
    

### enable_coroutine

?> **Включить поддержку корутин в异步-стиле сервере**

?> Когда `enable_coroutine` выключено, корутины больше не создаются автоматически в [функциях обратной связи событий](/server/events), что может улучшить производительность, если корутины не нужны для этого. Смотрите [что такое Swoole корутины](/coroutine).

  * **Способы настройки**
    
    * В `php.ini` настроить `swoole.enable_coroutine = 'Off'` (см. [документацию по конфигурации INI](/other/config.md))
    * `$server->set(['enable_coroutine' => false]);` имеет более высокий приоритет, чем INI

  * **Влияние опции `enable_coroutine`**

      * onWorkerStart
      * onConnect
      * onOpen
      * onReceive
      * [setHandler](/redis_server?id=sethandler)
      * onPacket
      * onRequest
      * onMessage
      * onPipeMessage
      * onFinish
      * onClose
      * таймеры tick/after

!> Когда `enable_coroutine` включено, корутины автоматически создаются в вышеупомянутых функциях обратной связи

* Когда `enable_coroutine` установлен в `true`, корутины автоматически создаются в [функции обратной связи на запрос](/http_server?id=on) на уровне основы, и разработчикам не нужно явно использовать `go` функцию [создать корутину](/coroutine/coroutine?id=create)
* Когда `enable_coroutine` установлен в `false`, корутины не создаются автоматически, и если разработчикам нужны корутины, им нужно явно использовать `go` для создания корутин. Если корутиновые функции не нужны, то способ обработки полностью идентичен с `Swoole1.x`
* Обратите внимание, что включение этого не означает, что Swoole будет обрабатывать запросы с помощью корутин. Если в событии есть блокирующие функции, то необходимо заранее включить [одностороннюю корутинизацию](/runtime), чтобы активировать корутинизацию для таких блокирующих функций, как `sleep`, `mysqlnd` и других

```php
$server = new Swoole\Http\Server("127.0.0.1", 9501);

$server->set([
    // Отключить встроенные корутины
    'enable_coroutine' => false,
]);

$server->on("request", function ($request, $response) {
    if ($request->server['request_uri'] == '/coro') {
        go(function () use ($response) {
            co::sleep(0.2);
            $response->header("Content-Type", "text/plain");
            $response->end("Hello World\n");
        });
    } else {
        $response->header("Content-Type", "text/plain");
        $response->end("Hello World\n");
    }
});

$server->start();
```


### send_yield

?> **Когда в процессе отправки данных недостаточно места в буфере, текущая корутина будет [yield](/coroutine?id=协程调度) до тех пор, пока данные не будут отправлены и буфер не будет очищен, после чего корутина будет автоматически [resume](/coroutine?id=协程调度), и отправка данных продолжится.** 【По умолчанию: доступна при `dispatch_mod](/server/setting?id=dispatch_mode) 2/4 и по умолчанию включена】

* Когда `Server/Client->send` возвращает `false` и код ошибки `SW_ERROR_OUTPUT_BUFFER_OVERFLOW`, вместо того чтобы возвращать `false` на уровень PHP, текущая корутина будет [yield](/coroutine?id=协程调度)
* `Server/Client` слушает событие очистки буфера, и после его возникновения данные в буфере уже отправлены, и тогда соответствующая корутина будет [resume](/coroutine?id=协程调度)
* После возобновления корутины, можно продолжить использовать `Server/Client->send` для записи данных в буфер, и поскольку буфер уже пуст, отправка будет успешной

Перед улучшением

```php
for ($i = 0; $i < 100; $i++) {
    // Когда буфер заполнен, будет возвращаться false и возникнет ошибка output buffer overflow
    $server->send($fd, $data_2m);
}
```

После улучшения

```php
for ($i = 0; $i < 100; $i++) {
    // Когда буфер заполнен, текущая корутина будет yield, и после отправки данных resume продолжит выполнение
    $server->send($fd, $data_2m);
}
```

!> Эта функция изменяет默认ное поведение на уровне основы и может быть выключена вручную

```php
$server->set([
    'send_yield' => false,
]);
```

  * __Влияние__

    * [Swoole\Server::send](/server/methods?id=send)
    * [Swoole\Http\Response::write](/http_server?id=write)
    * [Swoole\WebSocket\Server::push](/websocket_server?id=push)
    * [Swoole\Coroutine\Client::send](/coroutine_client/client?id=send)
    * [Swoole\Coroutine\Http\Client::push](/coroutine_client/http_client?id=push)


### send_timeout

Установка времени ожидания отправки. Используется в сочетании с `send_yield`. Когда в течение установленного времени данные не могут быть отправлены в буфер, низший уровень возвращает `false` и устанавливает код ошибки `ETIMEDOUT`. Используйте метод [getLastError()](/server/methods?id=getlasterror) для получения кода ошибки.

> Тип: плавающая точка, единица измерения: секунды, минимальная точность: миллисекунда

```php
$server->set([
    'send_yield' => true,
    'send_timeout' => 1.5, // 1.5 секунды
]);

for ($i = 0; $i < 100; $i++) {
    if ($server->send($fd, $data_2m) === false and $server->getLastError() == SOCKET_ETIMEDOUT) {
      echo "Отправка Timeout\n";
    }
}
```


### hook_flags

?> **Установка диапазона функций для `односторонней корутинизации` Hook.** 【По умолчанию: не hook】

!> С版本的 Swoole `v4.5+` или [4.4LTS](https://github.com/swoole/swoole-src/tree/v4.4.x) доступны, подробности смотрите [односторонняя корутинизация](/runtime)

```php
$server->set([
    'hook_flags' => SWOOLE_HOOK_SLEEP,
]);
```


### buffer_high_watermark

?> **Установка верхнего предела буфера в字节.**

```php
$server->set([
    'buffer_high_watermark' => 8 * 1024 * 1024,
]);
```


### buffer_low_watermark

?> **Установка нижнего предела буфера в字节.**

```php
$server->set([
    'buffer_low_watermark' => 1 * 1024 * 1024,
]);
```


### tcp_user_timeout

?> опция TCP_USER_TIMEOUT является опцией сокета на уровне TCP, которая определяет максимальное время в миллисекундах, в течение которого сокет ожидает подтверждения ACK после отправки пакета данных. Для подробностей смотрите man-документацию

```php
$server->set([
    'tcp_user_timeout' => 10 * 1000, // 10 секунд
]);
```

!> С版本的 Swoole >= `v4.5.3-alpha` доступны


### stats_file

?> **Установите путь к файлу, в который будут записываться данные [stats()](/server/methods?id=stats). После настройки автоматически будет установлен таймер на [onWorkerStart](/server/events?id=onworkerstart), который будет регулярно записывать содержание [stats()](/server/methods?id=stats) в указанный файл**

```php
$server->set([
    'stats_file' => __DIR__ . '/stats.log',
]);
```

!> С版本的 Swoole >= `v4.5.5` доступны


### event_object

?> **После установки этой опции, функции обратной связи будут работать в [объектном стиле](/server/events?id=回调对象).** 【По умолчанию: `false`】

```php
$server->set([
    'event_object' => true,
]);
```

!> С版本的 Swoole >= `v4.6.0` доступны


### start_session_id

?> **Установите начальный ID сеанса**

```php
$server->set([
    'start_session_id' => 10,
]);
```

!> С版本的 Swoole >= `v4.6.0` доступны


### single_thread

?> **Установите в один поток.** После включения Reactor-поток будет объединен с главным потоком в главном процессе, и Logic будет обрабатываться главным потоком. При использовании режима `SWOOLE_PROCESS` в PHP ZTS, необходимо установить эту опцию как `true`.

```php
$server->set([
    'single_thread' => true,
]);
```

!> С版本的 Swoole >= `v4.2.13` доступны
### max_queued_bytes

?> **Установить максимальное количество字节 в очереди для приемной буферы. Если превышено, прием прекращается.**

```php
$server->set([
    'max_queued_bytes' => 1024 * 1024,
]);
```

!> Версия Swoole >= `v4.5.0` доступна


### admin_server

?> **Установить administration server для просмотра информации о сервисе и т.д. в [Swoole Dashboard](http://dashboard.swoole.com/).**

```php
$server->set([
    'admin_server' => '0.0.0.0:9502',
]);
```

!> Версия Swoole >= `v4.8.0` доступна


### bootstrap

?> **Файл входа в программу в многопроцессном режиме, по умолчанию это имя текущего выполняемого сценария. **

!> Версия Swoole >= `v6.0`, PHP в режиме ZTS, при компиляции Swoole включена опция `--enable-swoole-thread`

```php
$server->set([
    'bootstrap' => __FILE__,
]);
```

### init_arguments

?> **Установить данные для общего доступа в многопроцессном режиме, эта настройка требует обратной связи, которая будет автоматически вызвана при запуске сервера.**

!> В Swoole встроены многие безопасные для线程 контейнеры: [Синхронизированный Map](/thread/map), [Синхронизированный List](/thread/arraylist), [Синхронизированная очередь](/thread/queue), не возвращайте в функции небезопасные переменные.

!> Версия Swoole >= `v6.0`, PHP в режиме ZTS, при компиляции Swoole включена опция `--enable-swoole-thread`

```php
$server->set([
    'init_arguments' => function() { return new Swoole\Thread\Map(); },
]);

$server->on('request', function($request, $response) {
    $map = Swoole\Thread::getArguments();
});
```
